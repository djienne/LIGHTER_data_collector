================================================================================
File: .\gather_contents.py
================================================================================

import os

def gather_files_content(root_folder, output_file):
    """
    Collects the content of all .md and .py files under root_folder (recursively)
    and writes them into a single well-formatted .txt file.
    """
    with open(output_file, 'w', encoding='utf-8') as outfile:
        for dirpath, _, filenames in os.walk(root_folder):
            for filename in filenames:
                if filename.endswith(('.md', '.py')):
                    file_path = os.path.join(dirpath, filename)
                    try:
                        with open(file_path, 'r', encoding='utf-8') as infile:
                            content = infile.read()
                        outfile.write(f"{'='*80}\n")
                        outfile.write(f"File: {file_path}\n")
                        outfile.write(f"{'='*80}\n\n")
                        outfile.write(content)
                        outfile.write("\n\n\n")  # spacing between files
                    except Exception as e:
                        print(f"Could not read {file_path}: {e}")

if __name__ == "__main__":
    root_folder = "."  # Change this to your folder path
    output_file = "combined_output.txt"  # Name of the output file
    gather_files_content(root_folder, output_file)
    print(f"Content gathered in: {output_file}")




================================================================================
File: .\README.md
================================================================================

# Lighter Python

Python SDK for Lighter

## Requirements.

Python 3.8+

## Installation & Usage
### pip install

If the python package is hosted on a repository, you can install directly using:

```sh
pip install git+https://github.com/elliottech/lighter-python.git
```


Then import the package:
```python
import lighter
```

### Tests

Execute `pytest` to run the tests.

## Getting Started

Please follow the [installation procedure](#installation--usage) and then run the following:

```python

import lighter
import asyncio

async def main():
    client = lighter.ApiClient()
    account_api = lighter.AccountApi(client)
    account = await account_api.get_account(by="index", value="1")
    print(account)

if __name__ == "__main__":
    asyncio.run(main())

```

# Examples
## [Read API Functions](examples/get_info.py)
```sh
python examples/get_info.py
```

## [Websocket Sync Order Books & Accounts](examples/ws.py)
```sh
python examples/ws.py
```

## [Create & Cancel Orders](examples/create_cancel_order.py)
```sh
python examples/create_cancel_order.py
```

## Documentation for API Endpoints

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Class | Method | HTTP request | Description
------------ | ------------- | ------------- | -------------
*AccountApi* | [**account**](docs/AccountApi.md#account) | **GET** /api/v1/account | account
*AccountApi* | [**accounts_by_l1_address**](docs/AccountApi.md#accounts_by_l1_address) | **GET** /api/v1/accountsByL1Address | accountsByL1Address
*AccountApi* | [**apikeys**](docs/AccountApi.md#apikeys) | **GET** /api/v1/apikeys | apikeys
*AccountApi* | [**pnl**](docs/AccountApi.md#pnl) | **GET** /api/v1/pnl | pnl
*AccountApi* | [**public_pools**](docs/AccountApi.md#public_pools) | **GET** /api/v1/publicPools | publicPools
*BlockApi* | [**block**](docs/BlockApi.md#block) | **GET** /api/v1/block | block
*BlockApi* | [**blocks**](docs/BlockApi.md#blocks) | **GET** /api/v1/blocks | blocks
*BlockApi* | [**current_height**](docs/BlockApi.md#current_height) | **GET** /api/v1/currentHeight | currentHeight
*CandlestickApi* | [**candlesticks**](docs/CandlestickApi.md#candlesticks) | **GET** /api/v1/candlesticks | candlesticks
*CandlestickApi* | [**fundings**](docs/CandlestickApi.md#fundings) | **GET** /api/v1/fundings | fundings
*OrderApi* | [**account_inactive_orders**](docs/OrderApi.md#account_inactive_orders) | **GET** /api/v1/accountInactiveOrders | accountInactiveOrders
*OrderApi* | [**exchange_stats**](docs/OrderApi.md#exchange_stats) | **GET** /api/v1/exchangeStats | exchangeStats
*OrderApi* | [**order_book_details**](docs/OrderApi.md#order_book_details) | **GET** /api/v1/orderBookDetails | orderBookDetails
*OrderApi* | [**order_book_orders**](docs/OrderApi.md#order_book_orders) | **GET** /api/v1/orderBookOrders | orderBookOrders
*OrderApi* | [**order_books**](docs/OrderApi.md#order_books) | **GET** /api/v1/orderBooks | orderBooks
*OrderApi* | [**recent_trades**](docs/OrderApi.md#recent_trades) | **GET** /api/v1/recentTrades | recentTrades
*OrderApi* | [**trades**](docs/OrderApi.md#trades) | **GET** /api/v1/trades | trades
*RootApi* | [**info**](docs/RootApi.md#info) | **GET** /info | info
*RootApi* | [**status**](docs/RootApi.md#status) | **GET** / | status
*TransactionApi* | [**account_txs**](docs/TransactionApi.md#account_txs) | **GET** /api/v1/accountTxs | accountTxs
*TransactionApi* | [**block_txs**](docs/TransactionApi.md#block_txs) | **GET** /api/v1/blockTxs | blockTxs
*TransactionApi* | [**deposit_history**](docs/TransactionApi.md#deposit_history) | **GET** /api/v1/deposit/history | deposit_history
*TransactionApi* | [**next_nonce**](docs/TransactionApi.md#next_nonce) | **GET** /api/v1/nextNonce | nextNonce
*TransactionApi* | [**send_tx**](docs/TransactionApi.md#send_tx) | **POST** /api/v1/sendTx | sendTx
*TransactionApi* | [**send_tx_batch**](docs/TransactionApi.md#send_tx_batch) | **POST** /api/v1/sendTxBatch | sendTxBatch
*TransactionApi* | [**tx**](docs/TransactionApi.md#tx) | **GET** /api/v1/tx | tx
*TransactionApi* | [**tx_from_l1_tx_hash**](docs/TransactionApi.md#tx_from_l1_tx_hash) | **GET** /api/v1/txFromL1TxHash | txFromL1TxHash
*TransactionApi* | [**txs**](docs/TransactionApi.md#txs) | **GET** /api/v1/txs | txs
*TransactionApi* | [**withdraw_history**](docs/TransactionApi.md#withdraw_history) | **GET** /api/v1/withdraw/history | withdraw_history


## Documentation For Models

 - [Account](docs/Account.md)
 - [AccountApiKeys](docs/AccountApiKeys.md)
 - [AccountMarketStats](docs/AccountMarketStats.md)
 - [AccountMetadata](docs/AccountMetadata.md)
 - [AccountPnL](docs/AccountPnL.md)
 - [AccountPosition](docs/AccountPosition.md)
 - [AccountStats](docs/AccountStats.md)
 - [ApiKey](docs/ApiKey.md)
 - [Block](docs/Block.md)
 - [Blocks](docs/Blocks.md)
 - [BridgeSupportedNetwork](docs/BridgeSupportedNetwork.md)
 - [Candlestick](docs/Candlestick.md)
 - [Candlesticks](docs/Candlesticks.md)
 - [ContractAddress](docs/ContractAddress.md)
 - [CurrentHeight](docs/CurrentHeight.md)
 - [Cursor](docs/Cursor.md)
 - [DepositHistory](docs/DepositHistory.md)
 - [DepositHistoryItem](docs/DepositHistoryItem.md)
 - [DetailedAccount](docs/DetailedAccount.md)
 - [DetailedAccounts](docs/DetailedAccounts.md)
 - [DetailedCandlestick](docs/DetailedCandlestick.md)
 - [EnrichedTx](docs/EnrichedTx.md)
 - [ExchangeStats](docs/ExchangeStats.md)
 - [Funding](docs/Funding.md)
 - [Fundings](docs/Fundings.md)
 - [L1ProviderInfo](docs/L1ProviderInfo.md)
 - [Liquidation](docs/Liquidation.md)
 - [MarketInfo](docs/MarketInfo.md)
 - [NextNonce](docs/NextNonce.md)
 - [Order](docs/Order.md)
 - [OrderBook](docs/OrderBook.md)
 - [OrderBookDepth](docs/OrderBookDepth.md)
 - [OrderBookDetail](docs/OrderBookDetail.md)
 - [OrderBookDetails](docs/OrderBookDetails.md)
 - [OrderBookOrders](docs/OrderBookOrders.md)
 - [OrderBookStats](docs/OrderBookStats.md)
 - [OrderBooks](docs/OrderBooks.md)
 - [Orders](docs/Orders.md)
 - [PnLEntry](docs/PnLEntry.md)
 - [PositionFunding](docs/PositionFunding.md)
 - [PriceLevel](docs/PriceLevel.md)
 - [PublicPool](docs/PublicPool.md)
 - [PublicPoolInfo](docs/PublicPoolInfo.md)
 - [PublicPoolShare](docs/PublicPoolShare.md)
 - [PublicPools](docs/PublicPools.md)
 - [ReqGetAccount](docs/ReqGetAccount.md)
 - [ReqGetAccountApiKeys](docs/ReqGetAccountApiKeys.md)
 - [ReqGetAccountByL1Address](docs/ReqGetAccountByL1Address.md)
 - [ReqGetAccountInactiveOrders](docs/ReqGetAccountInactiveOrders.md)
 - [ReqGetAccountPnL](docs/ReqGetAccountPnL.md)
 - [ReqGetAccountTxs](docs/ReqGetAccountTxs.md)
 - [ReqGetBlock](docs/ReqGetBlock.md)
 - [ReqGetBlockTxs](docs/ReqGetBlockTxs.md)
 - [ReqGetByAccount](docs/ReqGetByAccount.md)
 - [ReqGetCandlesticks](docs/ReqGetCandlesticks.md)
 - [ReqGetDepositHistory](docs/ReqGetDepositHistory.md)
 - [ReqGetFundings](docs/ReqGetFundings.md)
 - [ReqGetL1Tx](docs/ReqGetL1Tx.md)
 - [ReqGetLatestDeposit](docs/ReqGetLatestDeposit.md)
 - [ReqGetNextNonce](docs/ReqGetNextNonce.md)
 - [ReqGetOrderBookDetails](docs/ReqGetOrderBookDetails.md)
 - [ReqGetOrderBookOrders](docs/ReqGetOrderBookOrders.md)
 - [ReqGetOrderBooks](docs/ReqGetOrderBooks.md)
 - [ReqGetPublicPools](docs/ReqGetPublicPools.md)
 - [ReqGetRangeWithCursor](docs/ReqGetRangeWithCursor.md)
 - [ReqGetRangeWithIndex](docs/ReqGetRangeWithIndex.md)
 - [ReqGetRangeWithIndexSortable](docs/ReqGetRangeWithIndexSortable.md)
 - [ReqGetRecentTrades](docs/ReqGetRecentTrades.md)
 - [ReqGetTrades](docs/ReqGetTrades.md)
 - [ReqGetTx](docs/ReqGetTx.md)
 - [ReqGetWithdrawHistory](docs/ReqGetWithdrawHistory.md)
 - [ResultCode](docs/ResultCode.md)
 - [SimpleOrder](docs/SimpleOrder.md)
 - [Status](docs/Status.md)
 - [SubAccounts](docs/SubAccounts.md)
 - [Ticker](docs/Ticker.md)
 - [Trade](docs/Trade.md)
 - [Trades](docs/Trades.md)
 - [Tx](docs/Tx.md)
 - [TxHash](docs/TxHash.md)
 - [TxHashes](docs/TxHashes.md)
 - [Txs](docs/Txs.md)
 - [ValidatorInfo](docs/ValidatorInfo.md)
 - [WithdrawHistory](docs/WithdrawHistory.md)
 - [WithdrawHistoryItem](docs/WithdrawHistoryItem.md)
 - [ZkLighterInfo](docs/ZkLighterInfo.md)


[//]: # (<a id="documentation-for-authorization"></a>)

[//]: # (## Documentation For Authorization)

[//]: # ()
[//]: # (Endpoints do not require authorization.)





================================================================================
File: .\docs\Account.md
================================================================================

# Account


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**account_type** | **int** |  | 
**index** | **int** |  | 
**l1_address** | **str** |  | 
**cancel_all_time** | **int** |  | 
**total_order_count** | **int** |  | 
**total_isolated_order_count** | **int** |  | 
**pending_order_count** | **int** |  | 
**available_balance** | **str** |  | 
**status** | **int** |  | 
**collateral** | **str** |  | 

## Example

```python
from lighter.models.account import Account

# TODO update the JSON string below
json = "{}"
# create an instance of Account from a JSON string
account_instance = Account.from_json(json)
# print the JSON string representation of the object
print(Account.to_json())

# convert the object into a dict
account_dict = account_instance.to_dict()
# create an instance of Account from a dict
account_from_dict = Account.from_dict(account_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountApi.md
================================================================================

# lighter.AccountApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**account**](AccountApi.md#account) | **GET** /api/v1/account | account
[**account_limits**](AccountApi.md#account_limits) | **GET** /api/v1/accountLimits | accountLimits
[**account_metadata**](AccountApi.md#account_metadata) | **GET** /api/v1/accountMetadata | accountMetadata
[**accounts_by_l1_address**](AccountApi.md#accounts_by_l1_address) | **GET** /api/v1/accountsByL1Address | accountsByL1Address
[**apikeys**](AccountApi.md#apikeys) | **GET** /api/v1/apikeys | apikeys
[**change_account_tier**](AccountApi.md#change_account_tier) | **POST** /api/v1/changeAccountTier | changeAccountTier
[**l1_metadata**](AccountApi.md#l1_metadata) | **GET** /api/v1/l1Metadata | l1Metadata
[**liquidations**](AccountApi.md#liquidations) | **GET** /api/v1/liquidations | liquidations
[**pnl**](AccountApi.md#pnl) | **GET** /api/v1/pnl | pnl
[**position_funding**](AccountApi.md#position_funding) | **GET** /api/v1/positionFunding | positionFunding
[**public_pools**](AccountApi.md#public_pools) | **GET** /api/v1/publicPools | publicPools
[**public_pools_metadata**](AccountApi.md#public_pools_metadata) | **GET** /api/v1/publicPoolsMetadata | publicPoolsMetadata


# **account**
> DetailedAccounts account(by, value)

account

Get account by account's index. <br>More details about account index: [Account Index](https://apidocs.lighter.xyz/docs/account-index)<hr>**Response Description:**<br><br>1) **Status:** 1 is active 0 is inactive.<br>2) **Collateral:** The amount of collateral in the account.<hr>**Position Details Description:**<br>1) **OOC:** Open order count in that market.<br>2) **Sign:** 1 for Long, -1 for Short.<br>3) **Position:** The amount of position in that market.<br>4) **Avg Entry Price:** The average entry price of the position.<br>5) **Position Value:** The value of the position.<br>6) **Unrealized PnL:** The unrealized profit and loss of the position.<br>7) **Realized PnL:** The realized profit and loss of the position.

### Example


```python
import lighter
from lighter.models.detailed_accounts import DetailedAccounts
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    by = 'by_example' # str | 
    value = 'value_example' # str | 

    try:
        # account
        api_response = await api_instance.account(by, value)
        print("The response of AccountApi->account:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->account: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **by** | **str**|  | 
 **value** | **str**|  | 

### Return type

[**DetailedAccounts**](DetailedAccounts.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **account_limits**
> AccountLimits account_limits(account_index, authorization=authorization, auth=auth)

accountLimits

Get account limits

### Example


```python
import lighter
from lighter.models.account_limits import AccountLimits
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    account_index = 56 # int | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)

    try:
        # accountLimits
        api_response = await api_instance.account_limits(account_index, authorization=authorization, auth=auth)
        print("The response of AccountApi->account_limits:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->account_limits: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 

### Return type

[**AccountLimits**](AccountLimits.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **account_metadata**
> AccountMetadatas account_metadata(by, value, authorization=authorization, auth=auth)

accountMetadata

Get account metadatas

### Example


```python
import lighter
from lighter.models.account_metadatas import AccountMetadatas
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    by = 'by_example' # str | 
    value = 'value_example' # str | 
    authorization = 'authorization_example' # str |  (optional)
    auth = 'auth_example' # str |  (optional)

    try:
        # accountMetadata
        api_response = await api_instance.account_metadata(by, value, authorization=authorization, auth=auth)
        print("The response of AccountApi->account_metadata:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->account_metadata: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **by** | **str**|  | 
 **value** | **str**|  | 
 **authorization** | **str**|  | [optional] 
 **auth** | **str**|  | [optional] 

### Return type

[**AccountMetadatas**](AccountMetadatas.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **accounts_by_l1_address**
> SubAccounts accounts_by_l1_address(l1_address)

accountsByL1Address

Get accounts by l1_address returns all accounts associated with the given L1 address

### Example


```python
import lighter
from lighter.models.sub_accounts import SubAccounts
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    l1_address = 'l1_address_example' # str | 

    try:
        # accountsByL1Address
        api_response = await api_instance.accounts_by_l1_address(l1_address)
        print("The response of AccountApi->accounts_by_l1_address:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->accounts_by_l1_address: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **l1_address** | **str**|  | 

### Return type

[**SubAccounts**](SubAccounts.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **apikeys**
> AccountApiKeys apikeys(account_index, api_key_index=api_key_index)

apikeys

Get account api key. Set `api_key_index` to 255 to retrieve all api keys associated with the account.

### Example


```python
import lighter
from lighter.models.account_api_keys import AccountApiKeys
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    account_index = 56 # int | 
    api_key_index = 255 # int |  (optional) (default to 255)

    try:
        # apikeys
        api_response = await api_instance.apikeys(account_index, api_key_index=api_key_index)
        print("The response of AccountApi->apikeys:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->apikeys: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **api_key_index** | **int**|  | [optional] [default to 255]

### Return type

[**AccountApiKeys**](AccountApiKeys.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **change_account_tier**
> RespChangeAccountTier change_account_tier(account_index, new_tier, authorization=authorization, auth=auth)

changeAccountTier

Change account tier

### Example


```python
import lighter
from lighter.models.resp_change_account_tier import RespChangeAccountTier
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    account_index = 56 # int | 
    new_tier = 'new_tier_example' # str | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)

    try:
        # changeAccountTier
        api_response = await api_instance.change_account_tier(account_index, new_tier, authorization=authorization, auth=auth)
        print("The response of AccountApi->change_account_tier:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->change_account_tier: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **new_tier** | **str**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 

### Return type

[**RespChangeAccountTier**](RespChangeAccountTier.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: multipart/form-data
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **l1_metadata**
> L1Metadata l1_metadata(l1_address, authorization=authorization, auth=auth)

l1Metadata

Get L1 metadata

### Example


```python
import lighter
from lighter.models.l1_metadata import L1Metadata
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    l1_address = 'l1_address_example' # str | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)

    try:
        # l1Metadata
        api_response = await api_instance.l1_metadata(l1_address, authorization=authorization, auth=auth)
        print("The response of AccountApi->l1_metadata:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->l1_metadata: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **l1_address** | **str**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 

### Return type

[**L1Metadata**](L1Metadata.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **liquidations**
> LiquidationInfos liquidations(account_index, limit, authorization=authorization, auth=auth, market_id=market_id, cursor=cursor)

liquidations

Get liquidation infos

### Example


```python
import lighter
from lighter.models.liquidation_infos import LiquidationInfos
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    account_index = 56 # int | 
    limit = 56 # int | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)
    market_id = 255 # int |  (optional) (default to 255)
    cursor = 'cursor_example' # str |  (optional)

    try:
        # liquidations
        api_response = await api_instance.liquidations(account_index, limit, authorization=authorization, auth=auth, market_id=market_id, cursor=cursor)
        print("The response of AccountApi->liquidations:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->liquidations: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **limit** | **int**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 
 **market_id** | **int**|  | [optional] [default to 255]
 **cursor** | **str**|  | [optional] 

### Return type

[**LiquidationInfos**](LiquidationInfos.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **pnl**
> AccountPnL pnl(by, value, resolution, start_timestamp, end_timestamp, count_back, authorization=authorization, auth=auth, ignore_transfers=ignore_transfers)

pnl

Get account PnL chart

### Example


```python
import lighter
from lighter.models.account_pn_l import AccountPnL
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    by = 'by_example' # str | 
    value = 'value_example' # str | 
    resolution = 'resolution_example' # str | 
    start_timestamp = 56 # int | 
    end_timestamp = 56 # int | 
    count_back = 56 # int | 
    authorization = 'authorization_example' # str |  (optional)
    auth = 'auth_example' # str |  (optional)
    ignore_transfers = False # bool |  (optional) (default to False)

    try:
        # pnl
        api_response = await api_instance.pnl(by, value, resolution, start_timestamp, end_timestamp, count_back, authorization=authorization, auth=auth, ignore_transfers=ignore_transfers)
        print("The response of AccountApi->pnl:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->pnl: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **by** | **str**|  | 
 **value** | **str**|  | 
 **resolution** | **str**|  | 
 **start_timestamp** | **int**|  | 
 **end_timestamp** | **int**|  | 
 **count_back** | **int**|  | 
 **authorization** | **str**|  | [optional] 
 **auth** | **str**|  | [optional] 
 **ignore_transfers** | **bool**|  | [optional] [default to False]

### Return type

[**AccountPnL**](AccountPnL.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **position_funding**
> PositionFundings position_funding(account_index, limit, authorization=authorization, auth=auth, market_id=market_id, cursor=cursor, side=side)

positionFunding

Get accounts position fundings

### Example


```python
import lighter
from lighter.models.position_fundings import PositionFundings
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    account_index = 56 # int | 
    limit = 56 # int | 
    authorization = 'authorization_example' # str |  (optional)
    auth = 'auth_example' # str |  (optional)
    market_id = 255 # int |  (optional) (default to 255)
    cursor = 'cursor_example' # str |  (optional)
    side = all # str |  (optional) (default to all)

    try:
        # positionFunding
        api_response = await api_instance.position_funding(account_index, limit, authorization=authorization, auth=auth, market_id=market_id, cursor=cursor, side=side)
        print("The response of AccountApi->position_funding:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->position_funding: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **limit** | **int**|  | 
 **authorization** | **str**|  | [optional] 
 **auth** | **str**|  | [optional] 
 **market_id** | **int**|  | [optional] [default to 255]
 **cursor** | **str**|  | [optional] 
 **side** | **str**|  | [optional] [default to all]

### Return type

[**PositionFundings**](PositionFundings.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **public_pools**
> PublicPools public_pools(index, limit, authorization=authorization, auth=auth, filter=filter, account_index=account_index)

publicPools

Get public pools

### Example


```python
import lighter
from lighter.models.public_pools import PublicPools
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    index = 56 # int | 
    limit = 56 # int | 
    authorization = 'authorization_example' # str |  (optional)
    auth = 'auth_example' # str |  (optional)
    filter = 'filter_example' # str |  (optional)
    account_index = 56 # int |  (optional)

    try:
        # publicPools
        api_response = await api_instance.public_pools(index, limit, authorization=authorization, auth=auth, filter=filter, account_index=account_index)
        print("The response of AccountApi->public_pools:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->public_pools: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **index** | **int**|  | 
 **limit** | **int**|  | 
 **authorization** | **str**|  | [optional] 
 **auth** | **str**|  | [optional] 
 **filter** | **str**|  | [optional] 
 **account_index** | **int**|  | [optional] 

### Return type

[**PublicPools**](PublicPools.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **public_pools_metadata**
> RespPublicPoolsMetadata public_pools_metadata(index, limit, authorization=authorization, auth=auth, filter=filter, account_index=account_index)

publicPoolsMetadata

Get public pools metadata

### Example


```python
import lighter
from lighter.models.resp_public_pools_metadata import RespPublicPoolsMetadata
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AccountApi(api_client)
    index = 56 # int | 
    limit = 56 # int | 
    authorization = 'authorization_example' # str |  (optional)
    auth = 'auth_example' # str |  (optional)
    filter = 'filter_example' # str |  (optional)
    account_index = 56 # int |  (optional)

    try:
        # publicPoolsMetadata
        api_response = await api_instance.public_pools_metadata(index, limit, authorization=authorization, auth=auth, filter=filter, account_index=account_index)
        print("The response of AccountApi->public_pools_metadata:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AccountApi->public_pools_metadata: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **index** | **int**|  | 
 **limit** | **int**|  | 
 **authorization** | **str**|  | [optional] 
 **auth** | **str**|  | [optional] 
 **filter** | **str**|  | [optional] 
 **account_index** | **int**|  | [optional] 

### Return type

[**RespPublicPoolsMetadata**](RespPublicPoolsMetadata.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\AccountApiKeys.md
================================================================================

# AccountApiKeys


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**api_keys** | [**List[ApiKey]**](ApiKey.md) |  | 

## Example

```python
from lighter.models.account_api_keys import AccountApiKeys

# TODO update the JSON string below
json = "{}"
# create an instance of AccountApiKeys from a JSON string
account_api_keys_instance = AccountApiKeys.from_json(json)
# print the JSON string representation of the object
print(AccountApiKeys.to_json())

# convert the object into a dict
account_api_keys_dict = account_api_keys_instance.to_dict()
# create an instance of AccountApiKeys from a dict
account_api_keys_from_dict = AccountApiKeys.from_dict(account_api_keys_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountLimits.md
================================================================================

# AccountLimits


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**max_llp_percentage** | **int** |  | 
**user_tier** | **str** |  | 

## Example

```python
from lighter.models.account_limits import AccountLimits

# TODO update the JSON string below
json = "{}"
# create an instance of AccountLimits from a JSON string
account_limits_instance = AccountLimits.from_json(json)
# print the JSON string representation of the object
print(AccountLimits.to_json())

# convert the object into a dict
account_limits_dict = account_limits_instance.to_dict()
# create an instance of AccountLimits from a dict
account_limits_from_dict = AccountLimits.from_dict(account_limits_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountMarginStats.md
================================================================================

# AccountMarginStats


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**collateral** | **str** |  | 
**portfolio_value** | **str** |  | 
**leverage** | **str** |  | 
**available_balance** | **str** |  | 
**margin_usage** | **str** |  | 
**buying_power** | **str** |  | 

## Example

```python
from lighter.models.account_margin_stats import AccountMarginStats

# TODO update the JSON string below
json = "{}"
# create an instance of AccountMarginStats from a JSON string
account_margin_stats_instance = AccountMarginStats.from_json(json)
# print the JSON string representation of the object
print(AccountMarginStats.to_json())

# convert the object into a dict
account_margin_stats_dict = account_margin_stats_instance.to_dict()
# create an instance of AccountMarginStats from a dict
account_margin_stats_from_dict = AccountMarginStats.from_dict(account_margin_stats_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountMarketStats.md
================================================================================

# AccountMarketStats


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | 
**daily_trades_count** | **int** |  | 
**daily_base_token_volume** | **float** |  | 
**daily_quote_token_volume** | **float** |  | 
**weekly_trades_count** | **int** |  | 
**weekly_base_token_volume** | **float** |  | 
**weekly_quote_token_volume** | **float** |  | 
**monthly_trades_count** | **int** |  | 
**monthly_base_token_volume** | **float** |  | 
**monthly_quote_token_volume** | **float** |  | 
**total_trades_count** | **int** |  | 
**total_base_token_volume** | **float** |  | 
**total_quote_token_volume** | **float** |  | 

## Example

```python
from lighter.models.account_market_stats import AccountMarketStats

# TODO update the JSON string below
json = "{}"
# create an instance of AccountMarketStats from a JSON string
account_market_stats_instance = AccountMarketStats.from_json(json)
# print the JSON string representation of the object
print(AccountMarketStats.to_json())

# convert the object into a dict
account_market_stats_dict = account_market_stats_instance.to_dict()
# create an instance of AccountMarketStats from a dict
account_market_stats_from_dict = AccountMarketStats.from_dict(account_market_stats_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountMetadata.md
================================================================================

# AccountMetadata


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**name** | **str** |  | 
**description** | **str** |  | 
**can_invite** | **bool** |  Remove After FE uses L1 meta endpoint | 
**referral_points_percentage** | **str** |  Remove After FE uses L1 meta endpoint | 

## Example

```python
from lighter.models.account_metadata import AccountMetadata

# TODO update the JSON string below
json = "{}"
# create an instance of AccountMetadata from a JSON string
account_metadata_instance = AccountMetadata.from_json(json)
# print the JSON string representation of the object
print(AccountMetadata.to_json())

# convert the object into a dict
account_metadata_dict = account_metadata_instance.to_dict()
# create an instance of AccountMetadata from a dict
account_metadata_from_dict = AccountMetadata.from_dict(account_metadata_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountMetadatas.md
================================================================================

# AccountMetadatas


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**account_metadatas** | [**List[AccountMetadata]**](AccountMetadata.md) |  | 

## Example

```python
from lighter.models.account_metadatas import AccountMetadatas

# TODO update the JSON string below
json = "{}"
# create an instance of AccountMetadatas from a JSON string
account_metadatas_instance = AccountMetadatas.from_json(json)
# print the JSON string representation of the object
print(AccountMetadatas.to_json())

# convert the object into a dict
account_metadatas_dict = account_metadatas_instance.to_dict()
# create an instance of AccountMetadatas from a dict
account_metadatas_from_dict = AccountMetadatas.from_dict(account_metadatas_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountPnL.md
================================================================================

# AccountPnL


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**resolution** | **str** |  | 
**pnl** | [**List[PnLEntry]**](PnLEntry.md) |  | 

## Example

```python
from lighter.models.account_pn_l import AccountPnL

# TODO update the JSON string below
json = "{}"
# create an instance of AccountPnL from a JSON string
account_pn_l_instance = AccountPnL.from_json(json)
# print the JSON string representation of the object
print(AccountPnL.to_json())

# convert the object into a dict
account_pn_l_dict = account_pn_l_instance.to_dict()
# create an instance of AccountPnL from a dict
account_pn_l_from_dict = AccountPnL.from_dict(account_pn_l_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountPosition.md
================================================================================

# AccountPosition


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | 
**symbol** | **str** |  | 
**initial_margin_fraction** | **str** |  | 
**open_order_count** | **int** |  | 
**pending_order_count** | **int** |  | 
**position_tied_order_count** | **int** |  | 
**sign** | **int** |  | 
**position** | **str** |  | 
**avg_entry_price** | **str** |  | 
**position_value** | **str** |  | 
**unrealized_pnl** | **str** |  | 
**realized_pnl** | **str** |  | 
**liquidation_price** | **str** |  | 
**total_funding_paid_out** | **str** |  | [optional] 
**margin_mode** | **int** |  | 
**allocated_margin** | **str** |  | 

## Example

```python
from lighter.models.account_position import AccountPosition

# TODO update the JSON string below
json = "{}"
# create an instance of AccountPosition from a JSON string
account_position_instance = AccountPosition.from_json(json)
# print the JSON string representation of the object
print(AccountPosition.to_json())

# convert the object into a dict
account_position_dict = account_position_instance.to_dict()
# create an instance of AccountPosition from a dict
account_position_from_dict = AccountPosition.from_dict(account_position_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountStats.md
================================================================================

# AccountStats


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**collateral** | **str** |  | 
**portfolio_value** | **str** |  | 
**leverage** | **str** |  | 
**available_balance** | **str** |  | 
**margin_usage** | **str** |  | 
**buying_power** | **str** |  | 
**cross_stats** | [**AccountMarginStats**](AccountMarginStats.md) |  | 
**total_stats** | [**AccountMarginStats**](AccountMarginStats.md) |  | 

## Example

```python
from lighter.models.account_stats import AccountStats

# TODO update the JSON string below
json = "{}"
# create an instance of AccountStats from a JSON string
account_stats_instance = AccountStats.from_json(json)
# print the JSON string representation of the object
print(AccountStats.to_json())

# convert the object into a dict
account_stats_dict = account_stats_instance.to_dict()
# create an instance of AccountStats from a dict
account_stats_from_dict = AccountStats.from_dict(account_stats_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AccountTradeStats.md
================================================================================

# AccountTradeStats


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**daily_trades_count** | **int** |  | 
**daily_volume** | **float** |  | 
**weekly_trades_count** | **int** |  | 
**weekly_volume** | **float** |  | 
**monthly_trades_count** | **int** |  | 
**monthly_volume** | **float** |  | 
**total_trades_count** | **int** |  | 
**total_volume** | **float** |  | 

## Example

```python
from lighter.models.account_trade_stats import AccountTradeStats

# TODO update the JSON string below
json = "{}"
# create an instance of AccountTradeStats from a JSON string
account_trade_stats_instance = AccountTradeStats.from_json(json)
# print the JSON string representation of the object
print(AccountTradeStats.to_json())

# convert the object into a dict
account_trade_stats_dict = account_trade_stats_instance.to_dict()
# create an instance of AccountTradeStats from a dict
account_trade_stats_from_dict = AccountTradeStats.from_dict(account_trade_stats_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Announcement.md
================================================================================

# Announcement


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**title** | **str** |  | 
**content** | **str** |  | 
**created_at** | **int** |  | 

## Example

```python
from lighter.models.announcement import Announcement

# TODO update the JSON string below
json = "{}"
# create an instance of Announcement from a JSON string
announcement_instance = Announcement.from_json(json)
# print the JSON string representation of the object
print(Announcement.to_json())

# convert the object into a dict
announcement_dict = announcement_instance.to_dict()
# create an instance of Announcement from a dict
announcement_from_dict = Announcement.from_dict(announcement_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\AnnouncementApi.md
================================================================================

# lighter.AnnouncementApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**announcement**](AnnouncementApi.md#announcement) | **GET** /api/v1/announcement | announcement


# **announcement**
> Announcements announcement()

announcement

Get announcement

### Example


```python
import lighter
from lighter.models.announcements import Announcements
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.AnnouncementApi(api_client)

    try:
        # announcement
        api_response = await api_instance.announcement()
        print("The response of AnnouncementApi->announcement:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling AnnouncementApi->announcement: %s\n" % e)
```



### Parameters

This endpoint does not need any parameter.

### Return type

[**Announcements**](Announcements.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\Announcements.md
================================================================================

# Announcements


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**announcements** | [**List[Announcement]**](Announcement.md) |  | 

## Example

```python
from lighter.models.announcements import Announcements

# TODO update the JSON string below
json = "{}"
# create an instance of Announcements from a JSON string
announcements_instance = Announcements.from_json(json)
# print the JSON string representation of the object
print(Announcements.to_json())

# convert the object into a dict
announcements_dict = announcements_instance.to_dict()
# create an instance of Announcements from a dict
announcements_from_dict = Announcements.from_dict(announcements_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ApiKey.md
================================================================================

# ApiKey


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**api_key_index** | **int** |  | 
**nonce** | **int** |  | 
**public_key** | **str** |  | 

## Example

```python
from lighter.models.api_key import ApiKey

# TODO update the JSON string below
json = "{}"
# create an instance of ApiKey from a JSON string
api_key_instance = ApiKey.from_json(json)
# print the JSON string representation of the object
print(ApiKey.to_json())

# convert the object into a dict
api_key_dict = api_key_instance.to_dict()
# create an instance of ApiKey from a dict
api_key_from_dict = ApiKey.from_dict(api_key_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Block.md
================================================================================

# Block


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**commitment** | **str** |  | 
**height** | **int** |  | 
**state_root** | **str** |  | 
**priority_operations** | **int** |  | 
**on_chain_l2_operations** | **int** |  | 
**pending_on_chain_operations_pub_data** | **str** |  | 
**committed_tx_hash** | **str** |  | 
**committed_at** | **int** |  | 
**verified_tx_hash** | **str** |  | 
**verified_at** | **int** |  | 
**txs** | [**List[Tx]**](Tx.md) |  | 
**status** | **int** |  | 
**size** | **int** |  | 

## Example

```python
from lighter.models.block import Block

# TODO update the JSON string below
json = "{}"
# create an instance of Block from a JSON string
block_instance = Block.from_json(json)
# print the JSON string representation of the object
print(Block.to_json())

# convert the object into a dict
block_dict = block_instance.to_dict()
# create an instance of Block from a dict
block_from_dict = Block.from_dict(block_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\BlockApi.md
================================================================================

# lighter.BlockApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**block**](BlockApi.md#block) | **GET** /api/v1/block | block
[**blocks**](BlockApi.md#blocks) | **GET** /api/v1/blocks | blocks
[**current_height**](BlockApi.md#current_height) | **GET** /api/v1/currentHeight | currentHeight


# **block**
> Blocks block(by, value)

block

Get block by its height or commitment

### Example


```python
import lighter
from lighter.models.blocks import Blocks
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.BlockApi(api_client)
    by = 'by_example' # str | 
    value = 'value_example' # str | 

    try:
        # block
        api_response = await api_instance.block(by, value)
        print("The response of BlockApi->block:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling BlockApi->block: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **by** | **str**|  | 
 **value** | **str**|  | 

### Return type

[**Blocks**](Blocks.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **blocks**
> Blocks blocks(limit, index=index, sort=sort)

blocks

Get blocks

### Example


```python
import lighter
from lighter.models.blocks import Blocks
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.BlockApi(api_client)
    limit = 56 # int | 
    index = 56 # int |  (optional)
    sort = asc # str |  (optional) (default to asc)

    try:
        # blocks
        api_response = await api_instance.blocks(limit, index=index, sort=sort)
        print("The response of BlockApi->blocks:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling BlockApi->blocks: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **limit** | **int**|  | 
 **index** | **int**|  | [optional] 
 **sort** | **str**|  | [optional] [default to asc]

### Return type

[**Blocks**](Blocks.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **current_height**
> CurrentHeight current_height()

currentHeight

Get current height

### Example


```python
import lighter
from lighter.models.current_height import CurrentHeight
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.BlockApi(api_client)

    try:
        # currentHeight
        api_response = await api_instance.current_height()
        print("The response of BlockApi->current_height:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling BlockApi->current_height: %s\n" % e)
```



### Parameters

This endpoint does not need any parameter.

### Return type

[**CurrentHeight**](CurrentHeight.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\Blocks.md
================================================================================

# Blocks


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**total** | **int** |  | 
**blocks** | [**List[Block]**](Block.md) |  | 

## Example

```python
from lighter.models.blocks import Blocks

# TODO update the JSON string below
json = "{}"
# create an instance of Blocks from a JSON string
blocks_instance = Blocks.from_json(json)
# print the JSON string representation of the object
print(Blocks.to_json())

# convert the object into a dict
blocks_dict = blocks_instance.to_dict()
# create an instance of Blocks from a dict
blocks_from_dict = Blocks.from_dict(blocks_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\BridgeApi.md
================================================================================

# lighter.BridgeApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**fastbridge_info**](BridgeApi.md#fastbridge_info) | **GET** /api/v1/fastbridge/info | fastbridge_info


# **fastbridge_info**
> RespGetFastBridgeInfo fastbridge_info()

fastbridge_info

Get fast bridge info

### Example


```python
import lighter
from lighter.models.resp_get_fast_bridge_info import RespGetFastBridgeInfo
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.BridgeApi(api_client)

    try:
        # fastbridge_info
        api_response = await api_instance.fastbridge_info()
        print("The response of BridgeApi->fastbridge_info:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling BridgeApi->fastbridge_info: %s\n" % e)
```



### Parameters

This endpoint does not need any parameter.

### Return type

[**RespGetFastBridgeInfo**](RespGetFastBridgeInfo.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\BridgeSupportedNetwork.md
================================================================================

# BridgeSupportedNetwork


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**name** | **str** |  | 
**chain_id** | **str** |  | 
**explorer** | **str** |  | 

## Example

```python
from lighter.models.bridge_supported_network import BridgeSupportedNetwork

# TODO update the JSON string below
json = "{}"
# create an instance of BridgeSupportedNetwork from a JSON string
bridge_supported_network_instance = BridgeSupportedNetwork.from_json(json)
# print the JSON string representation of the object
print(BridgeSupportedNetwork.to_json())

# convert the object into a dict
bridge_supported_network_dict = bridge_supported_network_instance.to_dict()
# create an instance of BridgeSupportedNetwork from a dict
bridge_supported_network_from_dict = BridgeSupportedNetwork.from_dict(bridge_supported_network_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Candlestick.md
================================================================================

# Candlestick


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**timestamp** | **int** |  | 
**open** | **float** |  | 
**high** | **float** |  | 
**low** | **float** |  | 
**close** | **float** |  | 
**volume0** | **float** |  | 
**volume1** | **float** |  | 
**last_trade_id** | **int** |  | 

## Example

```python
from lighter.models.candlestick import Candlestick

# TODO update the JSON string below
json = "{}"
# create an instance of Candlestick from a JSON string
candlestick_instance = Candlestick.from_json(json)
# print the JSON string representation of the object
print(Candlestick.to_json())

# convert the object into a dict
candlestick_dict = candlestick_instance.to_dict()
# create an instance of Candlestick from a dict
candlestick_from_dict = Candlestick.from_dict(candlestick_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\CandlestickApi.md
================================================================================

# lighter.CandlestickApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**candlesticks**](CandlestickApi.md#candlesticks) | **GET** /api/v1/candlesticks | candlesticks
[**fundings**](CandlestickApi.md#fundings) | **GET** /api/v1/fundings | fundings


# **candlesticks**
> Candlesticks candlesticks(market_id, resolution, start_timestamp, end_timestamp, count_back, set_timestamp_to_end=set_timestamp_to_end)

candlesticks

Get candlesticks

### Example


```python
import lighter
from lighter.models.candlesticks import Candlesticks
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.CandlestickApi(api_client)
    market_id = 56 # int | 
    resolution = 'resolution_example' # str | 
    start_timestamp = 56 # int | 
    end_timestamp = 56 # int | 
    count_back = 56 # int | 
    set_timestamp_to_end = False # bool |  (optional) (default to False)

    try:
        # candlesticks
        api_response = await api_instance.candlesticks(market_id, resolution, start_timestamp, end_timestamp, count_back, set_timestamp_to_end=set_timestamp_to_end)
        print("The response of CandlestickApi->candlesticks:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling CandlestickApi->candlesticks: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **market_id** | **int**|  | 
 **resolution** | **str**|  | 
 **start_timestamp** | **int**|  | 
 **end_timestamp** | **int**|  | 
 **count_back** | **int**|  | 
 **set_timestamp_to_end** | **bool**|  | [optional] [default to False]

### Return type

[**Candlesticks**](Candlesticks.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **fundings**
> Fundings fundings(market_id, resolution, start_timestamp, end_timestamp, count_back)

fundings

Get fundings

### Example


```python
import lighter
from lighter.models.fundings import Fundings
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.CandlestickApi(api_client)
    market_id = 56 # int | 
    resolution = 'resolution_example' # str | 
    start_timestamp = 56 # int | 
    end_timestamp = 56 # int | 
    count_back = 56 # int | 

    try:
        # fundings
        api_response = await api_instance.fundings(market_id, resolution, start_timestamp, end_timestamp, count_back)
        print("The response of CandlestickApi->fundings:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling CandlestickApi->fundings: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **market_id** | **int**|  | 
 **resolution** | **str**|  | 
 **start_timestamp** | **int**|  | 
 **end_timestamp** | **int**|  | 
 **count_back** | **int**|  | 

### Return type

[**Fundings**](Fundings.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\Candlesticks.md
================================================================================

# Candlesticks


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**resolution** | **str** |  | 
**candlesticks** | [**List[Candlestick]**](Candlestick.md) |  | 

## Example

```python
from lighter.models.candlesticks import Candlesticks

# TODO update the JSON string below
json = "{}"
# create an instance of Candlesticks from a JSON string
candlesticks_instance = Candlesticks.from_json(json)
# print the JSON string representation of the object
print(Candlesticks.to_json())

# convert the object into a dict
candlesticks_dict = candlesticks_instance.to_dict()
# create an instance of Candlesticks from a dict
candlesticks_from_dict = Candlesticks.from_dict(candlesticks_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ContractAddress.md
================================================================================

# ContractAddress


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**name** | **str** |  | 
**address** | **str** |  | 

## Example

```python
from lighter.models.contract_address import ContractAddress

# TODO update the JSON string below
json = "{}"
# create an instance of ContractAddress from a JSON string
contract_address_instance = ContractAddress.from_json(json)
# print the JSON string representation of the object
print(ContractAddress.to_json())

# convert the object into a dict
contract_address_dict = contract_address_instance.to_dict()
# create an instance of ContractAddress from a dict
contract_address_from_dict = ContractAddress.from_dict(contract_address_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\CurrentHeight.md
================================================================================

# CurrentHeight


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**height** | **int** |  | 

## Example

```python
from lighter.models.current_height import CurrentHeight

# TODO update the JSON string below
json = "{}"
# create an instance of CurrentHeight from a JSON string
current_height_instance = CurrentHeight.from_json(json)
# print the JSON string representation of the object
print(CurrentHeight.to_json())

# convert the object into a dict
current_height_dict = current_height_instance.to_dict()
# create an instance of CurrentHeight from a dict
current_height_from_dict = CurrentHeight.from_dict(current_height_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Cursor.md
================================================================================

# Cursor


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**next_cursor** | **str** |  | [optional] 

## Example

```python
from lighter.models.cursor import Cursor

# TODO update the JSON string below
json = "{}"
# create an instance of Cursor from a JSON string
cursor_instance = Cursor.from_json(json)
# print the JSON string representation of the object
print(Cursor.to_json())

# convert the object into a dict
cursor_dict = cursor_instance.to_dict()
# create an instance of Cursor from a dict
cursor_from_dict = Cursor.from_dict(cursor_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\DailyReturn.md
================================================================================

# DailyReturn


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**timestamp** | **int** |  | 
**daily_return** | **float** |  | 

## Example

```python
from lighter.models.daily_return import DailyReturn

# TODO update the JSON string below
json = "{}"
# create an instance of DailyReturn from a JSON string
daily_return_instance = DailyReturn.from_json(json)
# print the JSON string representation of the object
print(DailyReturn.to_json())

# convert the object into a dict
daily_return_dict = daily_return_instance.to_dict()
# create an instance of DailyReturn from a dict
daily_return_from_dict = DailyReturn.from_dict(daily_return_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\DepositHistory.md
================================================================================

# DepositHistory


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**deposits** | [**List[DepositHistoryItem]**](DepositHistoryItem.md) |  | 
**cursor** | **str** |  | 

## Example

```python
from lighter.models.deposit_history import DepositHistory

# TODO update the JSON string below
json = "{}"
# create an instance of DepositHistory from a JSON string
deposit_history_instance = DepositHistory.from_json(json)
# print the JSON string representation of the object
print(DepositHistory.to_json())

# convert the object into a dict
deposit_history_dict = deposit_history_instance.to_dict()
# create an instance of DepositHistory from a dict
deposit_history_from_dict = DepositHistory.from_dict(deposit_history_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\DepositHistoryItem.md
================================================================================

# DepositHistoryItem


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**id** | **str** |  | 
**amount** | **str** |  | 
**timestamp** | **int** |  | 
**status** | **str** |  | 
**l1_tx_hash** | **str** |  | 

## Example

```python
from lighter.models.deposit_history_item import DepositHistoryItem

# TODO update the JSON string below
json = "{}"
# create an instance of DepositHistoryItem from a JSON string
deposit_history_item_instance = DepositHistoryItem.from_json(json)
# print the JSON string representation of the object
print(DepositHistoryItem.to_json())

# convert the object into a dict
deposit_history_item_dict = deposit_history_item_instance.to_dict()
# create an instance of DepositHistoryItem from a dict
deposit_history_item_from_dict = DepositHistoryItem.from_dict(deposit_history_item_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\DetailedAccount.md
================================================================================

# DetailedAccount


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**account_type** | **int** |  | 
**index** | **int** |  | 
**l1_address** | **str** |  | 
**cancel_all_time** | **int** |  | 
**total_order_count** | **int** |  | 
**total_isolated_order_count** | **int** |  | 
**pending_order_count** | **int** |  | 
**available_balance** | **str** |  | 
**status** | **int** |  | 
**collateral** | **str** |  | 
**account_index** | **int** |  | 
**name** | **str** |  | 
**description** | **str** |  | 
**can_invite** | **bool** |  Remove After FE uses L1 meta endpoint | 
**referral_points_percentage** | **str** |  Remove After FE uses L1 meta endpoint | 
**positions** | [**List[AccountPosition]**](AccountPosition.md) |  | 
**total_asset_value** | **str** |  | 
**cross_asset_value** | **str** |  | 
**pool_info** | [**PublicPoolInfo**](PublicPoolInfo.md) |  | 
**shares** | [**List[PublicPoolShare]**](PublicPoolShare.md) |  | 

## Example

```python
from lighter.models.detailed_account import DetailedAccount

# TODO update the JSON string below
json = "{}"
# create an instance of DetailedAccount from a JSON string
detailed_account_instance = DetailedAccount.from_json(json)
# print the JSON string representation of the object
print(DetailedAccount.to_json())

# convert the object into a dict
detailed_account_dict = detailed_account_instance.to_dict()
# create an instance of DetailedAccount from a dict
detailed_account_from_dict = DetailedAccount.from_dict(detailed_account_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\DetailedAccounts.md
================================================================================

# DetailedAccounts


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**total** | **int** |  | 
**accounts** | [**List[DetailedAccount]**](DetailedAccount.md) |  | 

## Example

```python
from lighter.models.detailed_accounts import DetailedAccounts

# TODO update the JSON string below
json = "{}"
# create an instance of DetailedAccounts from a JSON string
detailed_accounts_instance = DetailedAccounts.from_json(json)
# print the JSON string representation of the object
print(DetailedAccounts.to_json())

# convert the object into a dict
detailed_accounts_dict = detailed_accounts_instance.to_dict()
# create an instance of DetailedAccounts from a dict
detailed_accounts_from_dict = DetailedAccounts.from_dict(detailed_accounts_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\DetailedCandlestick.md
================================================================================

# DetailedCandlestick


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**timestamp** | **int** |  | 
**open** | **float** |  | 
**high** | **float** |  | 
**low** | **float** |  | 
**close** | **float** |  | 
**volume0** | **float** |  | 
**volume1** | **float** |  | 
**last_trade_id** | **int** |  | 
**trade_count** | **int** |  | 

## Example

```python
from lighter.models.detailed_candlestick import DetailedCandlestick

# TODO update the JSON string below
json = "{}"
# create an instance of DetailedCandlestick from a JSON string
detailed_candlestick_instance = DetailedCandlestick.from_json(json)
# print the JSON string representation of the object
print(DetailedCandlestick.to_json())

# convert the object into a dict
detailed_candlestick_dict = detailed_candlestick_instance.to_dict()
# create an instance of DetailedCandlestick from a dict
detailed_candlestick_from_dict = DetailedCandlestick.from_dict(detailed_candlestick_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\EnrichedTx.md
================================================================================

# EnrichedTx


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**hash** | **str** |  | 
**type** | **int** |  | 
**info** | **str** |  | 
**event_info** | **str** |  | 
**status** | **int** |  | 
**transaction_index** | **int** |  | 
**l1_address** | **str** |  | 
**account_index** | **int** |  | 
**nonce** | **int** |  | 
**expire_at** | **int** |  | 
**block_height** | **int** |  | 
**queued_at** | **int** |  | 
**executed_at** | **int** |  | 
**sequence_index** | **int** |  | 
**parent_hash** | **str** |  | 
**committed_at** | **int** |  | 
**verified_at** | **int** |  | 

## Example

```python
from lighter.models.enriched_tx import EnrichedTx

# TODO update the JSON string below
json = "{}"
# create an instance of EnrichedTx from a JSON string
enriched_tx_instance = EnrichedTx.from_json(json)
# print the JSON string representation of the object
print(EnrichedTx.to_json())

# convert the object into a dict
enriched_tx_dict = enriched_tx_instance.to_dict()
# create an instance of EnrichedTx from a dict
enriched_tx_from_dict = EnrichedTx.from_dict(enriched_tx_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ExchangeStats.md
================================================================================

# ExchangeStats


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**total** | **int** |  | 
**order_book_stats** | [**List[OrderBookStats]**](OrderBookStats.md) |  | 
**daily_usd_volume** | **float** |  | 
**daily_trades_count** | **int** |  | 

## Example

```python
from lighter.models.exchange_stats import ExchangeStats

# TODO update the JSON string below
json = "{}"
# create an instance of ExchangeStats from a JSON string
exchange_stats_instance = ExchangeStats.from_json(json)
# print the JSON string representation of the object
print(ExchangeStats.to_json())

# convert the object into a dict
exchange_stats_dict = exchange_stats_instance.to_dict()
# create an instance of ExchangeStats from a dict
exchange_stats_from_dict = ExchangeStats.from_dict(exchange_stats_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ExportData.md
================================================================================

# ExportData


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**data_url** | **str** |  | 

## Example

```python
from lighter.models.export_data import ExportData

# TODO update the JSON string below
json = "{}"
# create an instance of ExportData from a JSON string
export_data_instance = ExportData.from_json(json)
# print the JSON string representation of the object
print(ExportData.to_json())

# convert the object into a dict
export_data_dict = export_data_instance.to_dict()
# create an instance of ExportData from a dict
export_data_from_dict = ExportData.from_dict(export_data_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Funding.md
================================================================================

# Funding


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**timestamp** | **int** |  | 
**value** | **str** |  | 
**rate** | **str** |  | 
**direction** | **str** |  | 

## Example

```python
from lighter.models.funding import Funding

# TODO update the JSON string below
json = "{}"
# create an instance of Funding from a JSON string
funding_instance = Funding.from_json(json)
# print the JSON string representation of the object
print(Funding.to_json())

# convert the object into a dict
funding_dict = funding_instance.to_dict()
# create an instance of Funding from a dict
funding_from_dict = Funding.from_dict(funding_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\FundingApi.md
================================================================================

# lighter.FundingApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**funding_rates**](FundingApi.md#funding_rates) | **GET** /api/v1/funding-rates | funding-rates


# **funding_rates**
> FundingRates funding_rates()

funding-rates

Get funding rates

### Example


```python
import lighter
from lighter.models.funding_rates import FundingRates
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.FundingApi(api_client)

    try:
        # funding-rates
        api_response = await api_instance.funding_rates()
        print("The response of FundingApi->funding_rates:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling FundingApi->funding_rates: %s\n" % e)
```



### Parameters

This endpoint does not need any parameter.

### Return type

[**FundingRates**](FundingRates.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\FundingRate.md
================================================================================

# FundingRate


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | 
**exchange** | **str** |  | 
**symbol** | **str** |  | 
**rate** | **float** |  | 

## Example

```python
from lighter.models.funding_rate import FundingRate

# TODO update the JSON string below
json = "{}"
# create an instance of FundingRate from a JSON string
funding_rate_instance = FundingRate.from_json(json)
# print the JSON string representation of the object
print(FundingRate.to_json())

# convert the object into a dict
funding_rate_dict = funding_rate_instance.to_dict()
# create an instance of FundingRate from a dict
funding_rate_from_dict = FundingRate.from_dict(funding_rate_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\FundingRates.md
================================================================================

# FundingRates


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**funding_rates** | [**List[FundingRate]**](FundingRate.md) |  | 

## Example

```python
from lighter.models.funding_rates import FundingRates

# TODO update the JSON string below
json = "{}"
# create an instance of FundingRates from a JSON string
funding_rates_instance = FundingRates.from_json(json)
# print the JSON string representation of the object
print(FundingRates.to_json())

# convert the object into a dict
funding_rates_dict = funding_rates_instance.to_dict()
# create an instance of FundingRates from a dict
funding_rates_from_dict = FundingRates.from_dict(funding_rates_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Fundings.md
================================================================================

# Fundings


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**resolution** | **str** |  | 
**fundings** | [**List[Funding]**](Funding.md) |  | 

## Example

```python
from lighter.models.fundings import Fundings

# TODO update the JSON string below
json = "{}"
# create an instance of Fundings from a JSON string
fundings_instance = Fundings.from_json(json)
# print the JSON string representation of the object
print(Fundings.to_json())

# convert the object into a dict
fundings_dict = fundings_instance.to_dict()
# create an instance of Fundings from a dict
fundings_from_dict = Fundings.from_dict(fundings_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\InfoApi.md
================================================================================

# lighter.InfoApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**transfer_fee_info**](InfoApi.md#transfer_fee_info) | **GET** /api/v1/transferFeeInfo | transferFeeInfo
[**withdrawal_delay**](InfoApi.md#withdrawal_delay) | **GET** /api/v1/withdrawalDelay | withdrawalDelay


# **transfer_fee_info**
> TransferFeeInfo transfer_fee_info(account_index, authorization=authorization, auth=auth, to_account_index=to_account_index)

transferFeeInfo

Transfer fee info

### Example


```python
import lighter
from lighter.models.transfer_fee_info import TransferFeeInfo
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.InfoApi(api_client)
    account_index = 56 # int | 
    authorization = 'authorization_example' # str |  (optional)
    auth = 'auth_example' # str |  (optional)
    to_account_index = -1 # int |  (optional) (default to -1)

    try:
        # transferFeeInfo
        api_response = await api_instance.transfer_fee_info(account_index, authorization=authorization, auth=auth, to_account_index=to_account_index)
        print("The response of InfoApi->transfer_fee_info:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling InfoApi->transfer_fee_info: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **authorization** | **str**|  | [optional] 
 **auth** | **str**|  | [optional] 
 **to_account_index** | **int**|  | [optional] [default to -1]

### Return type

[**TransferFeeInfo**](TransferFeeInfo.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **withdrawal_delay**
> RespWithdrawalDelay withdrawal_delay()

withdrawalDelay

Withdrawal delay in seconds

### Example


```python
import lighter
from lighter.models.resp_withdrawal_delay import RespWithdrawalDelay
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.InfoApi(api_client)

    try:
        # withdrawalDelay
        api_response = await api_instance.withdrawal_delay()
        print("The response of InfoApi->withdrawal_delay:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling InfoApi->withdrawal_delay: %s\n" % e)
```



### Parameters

This endpoint does not need any parameter.

### Return type

[**RespWithdrawalDelay**](RespWithdrawalDelay.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\L1Metadata.md
================================================================================

# L1Metadata


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**l1_address** | **str** |  | 
**can_invite** | **bool** |  | 
**referral_points_percentage** | **str** |  | 

## Example

```python
from lighter.models.l1_metadata import L1Metadata

# TODO update the JSON string below
json = "{}"
# create an instance of L1Metadata from a JSON string
l1_metadata_instance = L1Metadata.from_json(json)
# print the JSON string representation of the object
print(L1Metadata.to_json())

# convert the object into a dict
l1_metadata_dict = l1_metadata_instance.to_dict()
# create an instance of L1Metadata from a dict
l1_metadata_from_dict = L1Metadata.from_dict(l1_metadata_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\L1ProviderInfo.md
================================================================================

# L1ProviderInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**chain_id** | **int** |  | 
**network_id** | **int** |  | 
**latest_block_number** | **int** |  | 

## Example

```python
from lighter.models.l1_provider_info import L1ProviderInfo

# TODO update the JSON string below
json = "{}"
# create an instance of L1ProviderInfo from a JSON string
l1_provider_info_instance = L1ProviderInfo.from_json(json)
# print the JSON string representation of the object
print(L1ProviderInfo.to_json())

# convert the object into a dict
l1_provider_info_dict = l1_provider_info_instance.to_dict()
# create an instance of L1ProviderInfo from a dict
l1_provider_info_from_dict = L1ProviderInfo.from_dict(l1_provider_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\LiqTrade.md
================================================================================

# LiqTrade


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**price** | **str** |  | 
**size** | **str** |  | 
**taker_fee** | **str** |  | 
**maker_fee** | **str** |  | 

## Example

```python
from lighter.models.liq_trade import LiqTrade

# TODO update the JSON string below
json = "{}"
# create an instance of LiqTrade from a JSON string
liq_trade_instance = LiqTrade.from_json(json)
# print the JSON string representation of the object
print(LiqTrade.to_json())

# convert the object into a dict
liq_trade_dict = liq_trade_instance.to_dict()
# create an instance of LiqTrade from a dict
liq_trade_from_dict = LiqTrade.from_dict(liq_trade_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Liquidation.md
================================================================================

# Liquidation


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**id** | **int** |  | 
**market_id** | **int** |  | 
**type** | **str** |  | 
**trade** | [**LiqTrade**](LiqTrade.md) |  | 
**info** | [**LiquidationInfo**](LiquidationInfo.md) |  | 
**executed_at** | **int** |  | 

## Example

```python
from lighter.models.liquidation import Liquidation

# TODO update the JSON string below
json = "{}"
# create an instance of Liquidation from a JSON string
liquidation_instance = Liquidation.from_json(json)
# print the JSON string representation of the object
print(Liquidation.to_json())

# convert the object into a dict
liquidation_dict = liquidation_instance.to_dict()
# create an instance of Liquidation from a dict
liquidation_from_dict = Liquidation.from_dict(liquidation_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\LiquidationInfo.md
================================================================================

# LiquidationInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**positions** | [**List[AccountPosition]**](AccountPosition.md) |  | 
**risk_info_before** | [**RiskInfo**](RiskInfo.md) |  | 
**risk_info_after** | [**RiskInfo**](RiskInfo.md) |  | 
**mark_prices** | **Dict[str, float]** |  | 

## Example

```python
from lighter.models.liquidation_info import LiquidationInfo

# TODO update the JSON string below
json = "{}"
# create an instance of LiquidationInfo from a JSON string
liquidation_info_instance = LiquidationInfo.from_json(json)
# print the JSON string representation of the object
print(LiquidationInfo.to_json())

# convert the object into a dict
liquidation_info_dict = liquidation_info_instance.to_dict()
# create an instance of LiquidationInfo from a dict
liquidation_info_from_dict = LiquidationInfo.from_dict(liquidation_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\LiquidationInfos.md
================================================================================

# LiquidationInfos


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**liquidations** | [**List[Liquidation]**](Liquidation.md) |  | 
**next_cursor** | **str** |  | [optional] 

## Example

```python
from lighter.models.liquidation_infos import LiquidationInfos

# TODO update the JSON string below
json = "{}"
# create an instance of LiquidationInfos from a JSON string
liquidation_infos_instance = LiquidationInfos.from_json(json)
# print the JSON string representation of the object
print(LiquidationInfos.to_json())

# convert the object into a dict
liquidation_infos_dict = liquidation_infos_instance.to_dict()
# create an instance of LiquidationInfos from a dict
liquidation_infos_from_dict = LiquidationInfos.from_dict(liquidation_infos_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\MarketInfo.md
================================================================================

# MarketInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | 
**index_price** | **str** |  | 
**mark_price** | **str** |  | 
**open_interest** | **str** |  | 
**last_trade_price** | **str** |  | 
**current_funding_rate** | **str** |  | 
**funding_rate** | **str** |  | 
**funding_timestamp** | **int** |  | 
**daily_base_token_volume** | **float** |  | 
**daily_quote_token_volume** | **float** |  | 
**daily_price_low** | **float** |  | 
**daily_price_high** | **float** |  | 
**daily_price_change** | **float** |  | 

## Example

```python
from lighter.models.market_info import MarketInfo

# TODO update the JSON string below
json = "{}"
# create an instance of MarketInfo from a JSON string
market_info_instance = MarketInfo.from_json(json)
# print the JSON string representation of the object
print(MarketInfo.to_json())

# convert the object into a dict
market_info_dict = market_info_instance.to_dict()
# create an instance of MarketInfo from a dict
market_info_from_dict = MarketInfo.from_dict(market_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\NextNonce.md
================================================================================

# NextNonce


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**nonce** | **int** |  | 

## Example

```python
from lighter.models.next_nonce import NextNonce

# TODO update the JSON string below
json = "{}"
# create an instance of NextNonce from a JSON string
next_nonce_instance = NextNonce.from_json(json)
# print the JSON string representation of the object
print(NextNonce.to_json())

# convert the object into a dict
next_nonce_dict = next_nonce_instance.to_dict()
# create an instance of NextNonce from a dict
next_nonce_from_dict = NextNonce.from_dict(next_nonce_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\NotificationApi.md
================================================================================

# lighter.NotificationApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**notification_ack**](NotificationApi.md#notification_ack) | **POST** /api/v1/notification/ack | notification_ack


# **notification_ack**
> ResultCode notification_ack(notif_id, account_index, authorization=authorization, auth=auth)

notification_ack

Ack notification

### Example


```python
import lighter
from lighter.models.result_code import ResultCode
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.NotificationApi(api_client)
    notif_id = 'notif_id_example' # str | 
    account_index = 56 # int | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)

    try:
        # notification_ack
        api_response = await api_instance.notification_ack(notif_id, account_index, authorization=authorization, auth=auth)
        print("The response of NotificationApi->notification_ack:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling NotificationApi->notification_ack: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **notif_id** | **str**|  | 
 **account_index** | **int**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 

### Return type

[**ResultCode**](ResultCode.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: multipart/form-data
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\Order.md
================================================================================

# Order


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**order_index** | **int** |  | 
**client_order_index** | **int** |  | 
**order_id** | **str** |  | 
**client_order_id** | **str** |  | 
**market_index** | **int** |  | 
**owner_account_index** | **int** |  | 
**initial_base_amount** | **str** |  | 
**price** | **str** |  | 
**nonce** | **int** |  | 
**remaining_base_amount** | **str** |  | 
**is_ask** | **bool** |  | 
**base_size** | **int** |  | 
**base_price** | **int** |  | 
**filled_base_amount** | **str** |  | 
**filled_quote_amount** | **str** |  | 
**side** | **str** |  TODO: remove this | [default to 'buy']
**type** | **str** |  | 
**time_in_force** | **str** |  | [default to 'good-till-time']
**reduce_only** | **bool** |  | 
**trigger_price** | **str** |  | 
**order_expiry** | **int** |  | 
**status** | **str** |  | 
**trigger_status** | **str** |  | 
**trigger_time** | **int** |  | 
**parent_order_index** | **int** |  | 
**parent_order_id** | **str** |  | 
**to_trigger_order_id_0** | **str** |  | 
**to_trigger_order_id_1** | **str** |  | 
**to_cancel_order_id_0** | **str** |  | 
**block_height** | **int** |  | 
**timestamp** | **int** |  | 

## Example

```python
from lighter.models.order import Order

# TODO update the JSON string below
json = "{}"
# create an instance of Order from a JSON string
order_instance = Order.from_json(json)
# print the JSON string representation of the object
print(Order.to_json())

# convert the object into a dict
order_dict = order_instance.to_dict()
# create an instance of Order from a dict
order_from_dict = Order.from_dict(order_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\OrderApi.md
================================================================================

# lighter.OrderApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**account_active_orders**](OrderApi.md#account_active_orders) | **GET** /api/v1/accountActiveOrders | accountActiveOrders
[**account_inactive_orders**](OrderApi.md#account_inactive_orders) | **GET** /api/v1/accountInactiveOrders | accountInactiveOrders
[**exchange_stats**](OrderApi.md#exchange_stats) | **GET** /api/v1/exchangeStats | exchangeStats
[**export**](OrderApi.md#export) | **GET** /api/v1/export | export
[**order_book_details**](OrderApi.md#order_book_details) | **GET** /api/v1/orderBookDetails | orderBookDetails
[**order_book_orders**](OrderApi.md#order_book_orders) | **GET** /api/v1/orderBookOrders | orderBookOrders
[**order_books**](OrderApi.md#order_books) | **GET** /api/v1/orderBooks | orderBooks
[**recent_trades**](OrderApi.md#recent_trades) | **GET** /api/v1/recentTrades | recentTrades
[**trades**](OrderApi.md#trades) | **GET** /api/v1/trades | trades


# **account_active_orders**
> Orders account_active_orders(account_index, market_id, authorization=authorization, auth=auth)

accountActiveOrders

Get account active orders. `auth` can be generated using the SDK.

### Example


```python
import lighter
from lighter.models.orders import Orders
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.OrderApi(api_client)
    account_index = 56 # int | 
    market_id = 56 # int | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)

    try:
        # accountActiveOrders
        api_response = await api_instance.account_active_orders(account_index, market_id, authorization=authorization, auth=auth)
        print("The response of OrderApi->account_active_orders:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling OrderApi->account_active_orders: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **market_id** | **int**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 

### Return type

[**Orders**](Orders.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **account_inactive_orders**
> Orders account_inactive_orders(account_index, limit, authorization=authorization, auth=auth, market_id=market_id, ask_filter=ask_filter, between_timestamps=between_timestamps, cursor=cursor)

accountInactiveOrders

Get account inactive orders

### Example


```python
import lighter
from lighter.models.orders import Orders
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.OrderApi(api_client)
    account_index = 56 # int | 
    limit = 56 # int | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)
    market_id = 255 # int |  (optional) (default to 255)
    ask_filter = -1 # int |  (optional) (default to -1)
    between_timestamps = 'between_timestamps_example' # str |  (optional)
    cursor = 'cursor_example' # str |  (optional)

    try:
        # accountInactiveOrders
        api_response = await api_instance.account_inactive_orders(account_index, limit, authorization=authorization, auth=auth, market_id=market_id, ask_filter=ask_filter, between_timestamps=between_timestamps, cursor=cursor)
        print("The response of OrderApi->account_inactive_orders:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling OrderApi->account_inactive_orders: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **limit** | **int**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 
 **market_id** | **int**|  | [optional] [default to 255]
 **ask_filter** | **int**|  | [optional] [default to -1]
 **between_timestamps** | **str**|  | [optional] 
 **cursor** | **str**|  | [optional] 

### Return type

[**Orders**](Orders.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **exchange_stats**
> ExchangeStats exchange_stats()

exchangeStats

Get exchange stats

### Example


```python
import lighter
from lighter.models.exchange_stats import ExchangeStats
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.OrderApi(api_client)

    try:
        # exchangeStats
        api_response = await api_instance.exchange_stats()
        print("The response of OrderApi->exchange_stats:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling OrderApi->exchange_stats: %s\n" % e)
```



### Parameters

This endpoint does not need any parameter.

### Return type

[**ExchangeStats**](ExchangeStats.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **export**
> ExportData export(type, authorization=authorization, auth=auth, account_index=account_index, market_id=market_id)

export

Export data

### Example


```python
import lighter
from lighter.models.export_data import ExportData
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.OrderApi(api_client)
    type = 'type_example' # str | 
    authorization = 'authorization_example' # str |  (optional)
    auth = 'auth_example' # str |  (optional)
    account_index = -1 # int |  (optional) (default to -1)
    market_id = 255 # int |  (optional) (default to 255)

    try:
        # export
        api_response = await api_instance.export(type, authorization=authorization, auth=auth, account_index=account_index, market_id=market_id)
        print("The response of OrderApi->export:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling OrderApi->export: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **type** | **str**|  | 
 **authorization** | **str**|  | [optional] 
 **auth** | **str**|  | [optional] 
 **account_index** | **int**|  | [optional] [default to -1]
 **market_id** | **int**|  | [optional] [default to 255]

### Return type

[**ExportData**](ExportData.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **order_book_details**
> OrderBookDetails order_book_details(market_id=market_id)

orderBookDetails

Get order books metadata

### Example


```python
import lighter
from lighter.models.order_book_details import OrderBookDetails
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.OrderApi(api_client)
    market_id = 255 # int |  (optional) (default to 255)

    try:
        # orderBookDetails
        api_response = await api_instance.order_book_details(market_id=market_id)
        print("The response of OrderApi->order_book_details:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling OrderApi->order_book_details: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **market_id** | **int**|  | [optional] [default to 255]

### Return type

[**OrderBookDetails**](OrderBookDetails.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **order_book_orders**
> OrderBookOrders order_book_orders(market_id, limit)

orderBookOrders

Get order book orders

### Example


```python
import lighter
from lighter.models.order_book_orders import OrderBookOrders
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.OrderApi(api_client)
    market_id = 56 # int | 
    limit = 56 # int | 

    try:
        # orderBookOrders
        api_response = await api_instance.order_book_orders(market_id, limit)
        print("The response of OrderApi->order_book_orders:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling OrderApi->order_book_orders: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **market_id** | **int**|  | 
 **limit** | **int**|  | 

### Return type

[**OrderBookOrders**](OrderBookOrders.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **order_books**
> OrderBooks order_books(market_id=market_id)

orderBooks

Get order books metadata.<hr>**Response Description:**<br><br>1) **Taker and maker fees** are in percentage.<br>2) **Min base amount:** The amount of base token that can be traded in a single order.<br>3) **Min quote amount:** The amount of quote token that can be traded in a single order.<br>4) **Supported size decimals:** The number of decimal places that can be used for the size of the order.<br>5) **Supported price decimals:** The number of decimal places that can be used for the price of the order.<br>6) **Supported quote decimals:** Size Decimals + Quote Decimals.

### Example


```python
import lighter
from lighter.models.order_books import OrderBooks
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.OrderApi(api_client)
    market_id = 255 # int |  (optional) (default to 255)

    try:
        # orderBooks
        api_response = await api_instance.order_books(market_id=market_id)
        print("The response of OrderApi->order_books:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling OrderApi->order_books: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **market_id** | **int**|  | [optional] [default to 255]

### Return type

[**OrderBooks**](OrderBooks.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **recent_trades**
> Trades recent_trades(market_id, limit)

recentTrades

Get recent trades

### Example


```python
import lighter
from lighter.models.trades import Trades
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.OrderApi(api_client)
    market_id = 56 # int | 
    limit = 56 # int | 

    try:
        # recentTrades
        api_response = await api_instance.recent_trades(market_id, limit)
        print("The response of OrderApi->recent_trades:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling OrderApi->recent_trades: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **market_id** | **int**|  | 
 **limit** | **int**|  | 

### Return type

[**Trades**](Trades.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **trades**
> Trades trades(sort_by, limit, authorization=authorization, auth=auth, market_id=market_id, account_index=account_index, order_index=order_index, sort_dir=sort_dir, cursor=cursor, var_from=var_from, ask_filter=ask_filter)

trades

Get trades

### Example


```python
import lighter
from lighter.models.trades import Trades
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.OrderApi(api_client)
    sort_by = 'sort_by_example' # str | 
    limit = 56 # int | 
    authorization = 'authorization_example' # str |  (optional)
    auth = 'auth_example' # str |  (optional)
    market_id = 255 # int |  (optional) (default to 255)
    account_index = -1 # int |  (optional) (default to -1)
    order_index = 56 # int |  (optional)
    sort_dir = desc # str |  (optional) (default to desc)
    cursor = 'cursor_example' # str |  (optional)
    var_from = -1 # int |  (optional) (default to -1)
    ask_filter = -1 # int |  (optional) (default to -1)

    try:
        # trades
        api_response = await api_instance.trades(sort_by, limit, authorization=authorization, auth=auth, market_id=market_id, account_index=account_index, order_index=order_index, sort_dir=sort_dir, cursor=cursor, var_from=var_from, ask_filter=ask_filter)
        print("The response of OrderApi->trades:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling OrderApi->trades: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **sort_by** | **str**|  | 
 **limit** | **int**|  | 
 **authorization** | **str**|  | [optional] 
 **auth** | **str**|  | [optional] 
 **market_id** | **int**|  | [optional] [default to 255]
 **account_index** | **int**|  | [optional] [default to -1]
 **order_index** | **int**|  | [optional] 
 **sort_dir** | **str**|  | [optional] [default to desc]
 **cursor** | **str**|  | [optional] 
 **var_from** | **int**|  | [optional] [default to -1]
 **ask_filter** | **int**|  | [optional] [default to -1]

### Return type

[**Trades**](Trades.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\OrderBook.md
================================================================================

# OrderBook


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**symbol** | **str** |  | 
**market_id** | **int** |  | 
**status** | **str** |  | 
**taker_fee** | **str** |  | 
**maker_fee** | **str** |  | 
**liquidation_fee** | **str** |  | 
**min_base_amount** | **str** |  | 
**min_quote_amount** | **str** |  | 
**supported_size_decimals** | **int** |  | 
**supported_price_decimals** | **int** |  | 
**supported_quote_decimals** | **int** |  | 

## Example

```python
from lighter.models.order_book import OrderBook

# TODO update the JSON string below
json = "{}"
# create an instance of OrderBook from a JSON string
order_book_instance = OrderBook.from_json(json)
# print the JSON string representation of the object
print(OrderBook.to_json())

# convert the object into a dict
order_book_dict = order_book_instance.to_dict()
# create an instance of OrderBook from a dict
order_book_from_dict = OrderBook.from_dict(order_book_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\OrderBookDepth.md
================================================================================

# OrderBookDepth


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**asks** | [**List[PriceLevel]**](PriceLevel.md) |  | 
**bids** | [**List[PriceLevel]**](PriceLevel.md) |  | 
**offset** | **int** |  | 

## Example

```python
from lighter.models.order_book_depth import OrderBookDepth

# TODO update the JSON string below
json = "{}"
# create an instance of OrderBookDepth from a JSON string
order_book_depth_instance = OrderBookDepth.from_json(json)
# print the JSON string representation of the object
print(OrderBookDepth.to_json())

# convert the object into a dict
order_book_depth_dict = order_book_depth_instance.to_dict()
# create an instance of OrderBookDepth from a dict
order_book_depth_from_dict = OrderBookDepth.from_dict(order_book_depth_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\OrderBookDetail.md
================================================================================

# OrderBookDetail


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**symbol** | **str** |  | 
**market_id** | **int** |  | 
**status** | **str** |  | 
**taker_fee** | **str** |  | 
**maker_fee** | **str** |  | 
**liquidation_fee** | **str** |  | 
**min_base_amount** | **str** |  | 
**min_quote_amount** | **str** |  | 
**supported_size_decimals** | **int** |  | 
**supported_price_decimals** | **int** |  | 
**supported_quote_decimals** | **int** |  | 
**size_decimals** | **int** |  | 
**price_decimals** | **int** |  | 
**quote_multiplier** | **int** |  | 
**default_initial_margin_fraction** | **int** |  | 
**min_initial_margin_fraction** | **int** |  | 
**maintenance_margin_fraction** | **int** |  | 
**closeout_margin_fraction** | **int** |  | 
**last_trade_price** | **float** |  | 
**daily_trades_count** | **int** |  | 
**daily_base_token_volume** | **float** |  | 
**daily_quote_token_volume** | **float** |  | 
**daily_price_low** | **float** |  | 
**daily_price_high** | **float** |  | 
**daily_price_change** | **float** |  | 
**open_interest** | **float** |  | 
**daily_chart** | **Dict[str, float]** |  | 

## Example

```python
from lighter.models.order_book_detail import OrderBookDetail

# TODO update the JSON string below
json = "{}"
# create an instance of OrderBookDetail from a JSON string
order_book_detail_instance = OrderBookDetail.from_json(json)
# print the JSON string representation of the object
print(OrderBookDetail.to_json())

# convert the object into a dict
order_book_detail_dict = order_book_detail_instance.to_dict()
# create an instance of OrderBookDetail from a dict
order_book_detail_from_dict = OrderBookDetail.from_dict(order_book_detail_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\OrderBookDetails.md
================================================================================

# OrderBookDetails


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**order_book_details** | [**List[OrderBookDetail]**](OrderBookDetail.md) |  | 

## Example

```python
from lighter.models.order_book_details import OrderBookDetails

# TODO update the JSON string below
json = "{}"
# create an instance of OrderBookDetails from a JSON string
order_book_details_instance = OrderBookDetails.from_json(json)
# print the JSON string representation of the object
print(OrderBookDetails.to_json())

# convert the object into a dict
order_book_details_dict = order_book_details_instance.to_dict()
# create an instance of OrderBookDetails from a dict
order_book_details_from_dict = OrderBookDetails.from_dict(order_book_details_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\OrderBookOrders.md
================================================================================

# OrderBookOrders


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**total_asks** | **int** |  | 
**asks** | [**List[SimpleOrder]**](SimpleOrder.md) |  | 
**total_bids** | **int** |  | 
**bids** | [**List[SimpleOrder]**](SimpleOrder.md) |  | 

## Example

```python
from lighter.models.order_book_orders import OrderBookOrders

# TODO update the JSON string below
json = "{}"
# create an instance of OrderBookOrders from a JSON string
order_book_orders_instance = OrderBookOrders.from_json(json)
# print the JSON string representation of the object
print(OrderBookOrders.to_json())

# convert the object into a dict
order_book_orders_dict = order_book_orders_instance.to_dict()
# create an instance of OrderBookOrders from a dict
order_book_orders_from_dict = OrderBookOrders.from_dict(order_book_orders_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\OrderBooks.md
================================================================================

# OrderBooks


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**order_books** | [**List[OrderBook]**](OrderBook.md) |  | 

## Example

```python
from lighter.models.order_books import OrderBooks

# TODO update the JSON string below
json = "{}"
# create an instance of OrderBooks from a JSON string
order_books_instance = OrderBooks.from_json(json)
# print the JSON string representation of the object
print(OrderBooks.to_json())

# convert the object into a dict
order_books_dict = order_books_instance.to_dict()
# create an instance of OrderBooks from a dict
order_books_from_dict = OrderBooks.from_dict(order_books_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\OrderBookStats.md
================================================================================

# OrderBookStats


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**symbol** | **str** |  | 
**last_trade_price** | **float** |  | 
**daily_trades_count** | **int** |  | 
**daily_base_token_volume** | **float** |  | 
**daily_quote_token_volume** | **float** |  | 
**daily_price_change** | **float** |  | 

## Example

```python
from lighter.models.order_book_stats import OrderBookStats

# TODO update the JSON string below
json = "{}"
# create an instance of OrderBookStats from a JSON string
order_book_stats_instance = OrderBookStats.from_json(json)
# print the JSON string representation of the object
print(OrderBookStats.to_json())

# convert the object into a dict
order_book_stats_dict = order_book_stats_instance.to_dict()
# create an instance of OrderBookStats from a dict
order_book_stats_from_dict = OrderBookStats.from_dict(order_book_stats_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Orders.md
================================================================================

# Orders


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**next_cursor** | **str** |  | [optional] 
**orders** | [**List[Order]**](Order.md) |  | 

## Example

```python
from lighter.models.orders import Orders

# TODO update the JSON string below
json = "{}"
# create an instance of Orders from a JSON string
orders_instance = Orders.from_json(json)
# print the JSON string representation of the object
print(Orders.to_json())

# convert the object into a dict
orders_dict = orders_instance.to_dict()
# create an instance of Orders from a dict
orders_from_dict = Orders.from_dict(orders_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\PnLEntry.md
================================================================================

# PnLEntry


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**timestamp** | **int** |  | 
**trade_pnl** | **float** |  | 
**inflow** | **float** |  | 
**outflow** | **float** |  | 
**pool_pnl** | **float** |  | 
**pool_inflow** | **float** |  | 
**pool_outflow** | **float** |  | 
**pool_total_shares** | **float** |  | 

## Example

```python
from lighter.models.pn_l_entry import PnLEntry

# TODO update the JSON string below
json = "{}"
# create an instance of PnLEntry from a JSON string
pn_l_entry_instance = PnLEntry.from_json(json)
# print the JSON string representation of the object
print(PnLEntry.to_json())

# convert the object into a dict
pn_l_entry_dict = pn_l_entry_instance.to_dict()
# create an instance of PnLEntry from a dict
pn_l_entry_from_dict = PnLEntry.from_dict(pn_l_entry_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\PositionFunding.md
================================================================================

# PositionFunding


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**timestamp** | **int** |  | 
**market_id** | **int** |  | 
**funding_id** | **int** |  | 
**change** | **str** |  | 
**rate** | **str** |  | 
**position_size** | **str** |  | 
**position_side** | **str** |  | 

## Example

```python
from lighter.models.position_funding import PositionFunding

# TODO update the JSON string below
json = "{}"
# create an instance of PositionFunding from a JSON string
position_funding_instance = PositionFunding.from_json(json)
# print the JSON string representation of the object
print(PositionFunding.to_json())

# convert the object into a dict
position_funding_dict = position_funding_instance.to_dict()
# create an instance of PositionFunding from a dict
position_funding_from_dict = PositionFunding.from_dict(position_funding_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\PositionFundings.md
================================================================================

# PositionFundings


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**position_fundings** | [**List[PositionFunding]**](PositionFunding.md) |  | 
**next_cursor** | **str** |  | [optional] 

## Example

```python
from lighter.models.position_fundings import PositionFundings

# TODO update the JSON string below
json = "{}"
# create an instance of PositionFundings from a JSON string
position_fundings_instance = PositionFundings.from_json(json)
# print the JSON string representation of the object
print(PositionFundings.to_json())

# convert the object into a dict
position_fundings_dict = position_fundings_instance.to_dict()
# create an instance of PositionFundings from a dict
position_fundings_from_dict = PositionFundings.from_dict(position_fundings_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\PriceLevel.md
================================================================================

# PriceLevel


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**price** | **str** |  | 
**size** | **str** |  | 

## Example

```python
from lighter.models.price_level import PriceLevel

# TODO update the JSON string below
json = "{}"
# create an instance of PriceLevel from a JSON string
price_level_instance = PriceLevel.from_json(json)
# print the JSON string representation of the object
print(PriceLevel.to_json())

# convert the object into a dict
price_level_dict = price_level_instance.to_dict()
# create an instance of PriceLevel from a dict
price_level_from_dict = PriceLevel.from_dict(price_level_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\PublicPool.md
================================================================================

# PublicPool


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**account_type** | **int** |  | 
**index** | **int** |  | 
**l1_address** | **str** |  | 
**cancel_all_time** | **int** |  | 
**total_order_count** | **int** |  | 
**total_isolated_order_count** | **int** |  | 
**pending_order_count** | **int** |  | 
**available_balance** | **str** |  | 
**status** | **int** |  | 
**collateral** | **str** |  | 
**account_index** | **int** |  | 
**name** | **str** |  | 
**description** | **str** |  | 
**can_invite** | **bool** |  Remove After FE uses L1 meta endpoint | 
**referral_points_percentage** | **str** |  Remove After FE uses L1 meta endpoint | 
**total_asset_value** | **str** |  | 
**cross_asset_value** | **str** |  | 
**pool_info** | [**PublicPoolInfo**](PublicPoolInfo.md) |  | 
**account_share** | [**PublicPoolShare**](PublicPoolShare.md) |  | [optional] 

## Example

```python
from lighter.models.public_pool import PublicPool

# TODO update the JSON string below
json = "{}"
# create an instance of PublicPool from a JSON string
public_pool_instance = PublicPool.from_json(json)
# print the JSON string representation of the object
print(PublicPool.to_json())

# convert the object into a dict
public_pool_dict = public_pool_instance.to_dict()
# create an instance of PublicPool from a dict
public_pool_from_dict = PublicPool.from_dict(public_pool_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\PublicPoolInfo.md
================================================================================

# PublicPoolInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**status** | **int** |  | 
**operator_fee** | **str** |  | 
**min_operator_share_rate** | **str** |  | 
**total_shares** | **int** |  | 
**operator_shares** | **int** |  | 
**annual_percentage_yield** | **float** |  | 
**daily_returns** | [**List[DailyReturn]**](DailyReturn.md) |  | 
**share_prices** | [**List[SharePrice]**](SharePrice.md) |  | 

## Example

```python
from lighter.models.public_pool_info import PublicPoolInfo

# TODO update the JSON string below
json = "{}"
# create an instance of PublicPoolInfo from a JSON string
public_pool_info_instance = PublicPoolInfo.from_json(json)
# print the JSON string representation of the object
print(PublicPoolInfo.to_json())

# convert the object into a dict
public_pool_info_dict = public_pool_info_instance.to_dict()
# create an instance of PublicPoolInfo from a dict
public_pool_info_from_dict = PublicPoolInfo.from_dict(public_pool_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\PublicPoolMetadata.md
================================================================================

# PublicPoolMetadata


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**account_index** | **int** |  | 
**account_type** | **int** |  | 
**name** | **str** |  | 
**l1_address** | **str** |  | 
**annual_percentage_yield** | **float** |  | 
**status** | **int** |  | 
**operator_fee** | **str** |  | 
**total_asset_value** | **str** |  | 
**total_shares** | **int** |  | 
**account_share** | [**PublicPoolShare**](PublicPoolShare.md) |  | [optional] 

## Example

```python
from lighter.models.public_pool_metadata import PublicPoolMetadata

# TODO update the JSON string below
json = "{}"
# create an instance of PublicPoolMetadata from a JSON string
public_pool_metadata_instance = PublicPoolMetadata.from_json(json)
# print the JSON string representation of the object
print(PublicPoolMetadata.to_json())

# convert the object into a dict
public_pool_metadata_dict = public_pool_metadata_instance.to_dict()
# create an instance of PublicPoolMetadata from a dict
public_pool_metadata_from_dict = PublicPoolMetadata.from_dict(public_pool_metadata_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\PublicPools.md
================================================================================

# PublicPools


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**total** | **int** |  | 
**public_pools** | [**List[PublicPool]**](PublicPool.md) |  | 

## Example

```python
from lighter.models.public_pools import PublicPools

# TODO update the JSON string below
json = "{}"
# create an instance of PublicPools from a JSON string
public_pools_instance = PublicPools.from_json(json)
# print the JSON string representation of the object
print(PublicPools.to_json())

# convert the object into a dict
public_pools_dict = public_pools_instance.to_dict()
# create an instance of PublicPools from a dict
public_pools_from_dict = PublicPools.from_dict(public_pools_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\PublicPoolShare.md
================================================================================

# PublicPoolShare


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**public_pool_index** | **int** |  | 
**shares_amount** | **int** |  | 
**entry_usdc** | **str** |  | 

## Example

```python
from lighter.models.public_pool_share import PublicPoolShare

# TODO update the JSON string below
json = "{}"
# create an instance of PublicPoolShare from a JSON string
public_pool_share_instance = PublicPoolShare.from_json(json)
# print the JSON string representation of the object
print(PublicPoolShare.to_json())

# convert the object into a dict
public_pool_share_dict = public_pool_share_instance.to_dict()
# create an instance of PublicPoolShare from a dict
public_pool_share_from_dict = PublicPoolShare.from_dict(public_pool_share_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReferralApi.md
================================================================================

# lighter.ReferralApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**referral_points**](ReferralApi.md#referral_points) | **GET** /api/v1/referral/points | referral_points


# **referral_points**
> ReferralPoints referral_points(account_index, authorization=authorization, auth=auth)

referral_points

Get referral points

### Example


```python
import lighter
from lighter.models.referral_points import ReferralPoints
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.ReferralApi(api_client)
    account_index = 56 # int | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)

    try:
        # referral_points
        api_response = await api_instance.referral_points(account_index, authorization=authorization, auth=auth)
        print("The response of ReferralApi->referral_points:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling ReferralApi->referral_points: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 

### Return type

[**ReferralPoints**](ReferralPoints.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\ReferralPointEntry.md
================================================================================

# ReferralPointEntry


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**l1_address** | **str** |  | 
**total_points** | **int** |  | 
**week_points** | **int** |  | 
**total_reward_points** | **int** |  | 
**week_reward_points** | **int** |  | 
**reward_point_multiplier** | **str** |  | 

## Example

```python
from lighter.models.referral_point_entry import ReferralPointEntry

# TODO update the JSON string below
json = "{}"
# create an instance of ReferralPointEntry from a JSON string
referral_point_entry_instance = ReferralPointEntry.from_json(json)
# print the JSON string representation of the object
print(ReferralPointEntry.to_json())

# convert the object into a dict
referral_point_entry_dict = referral_point_entry_instance.to_dict()
# create an instance of ReferralPointEntry from a dict
referral_point_entry_from_dict = ReferralPointEntry.from_dict(referral_point_entry_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReferralPoints.md
================================================================================

# ReferralPoints


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**referrals** | [**List[ReferralPointEntry]**](ReferralPointEntry.md) |  | 
**user_total_points** | **int** |  | 
**user_last_week_points** | **int** |  | 
**user_total_referral_reward_points** | **int** |  | 
**user_last_week_referral_reward_points** | **int** |  | 
**reward_point_multiplier** | **str** |  | 

## Example

```python
from lighter.models.referral_points import ReferralPoints

# TODO update the JSON string below
json = "{}"
# create an instance of ReferralPoints from a JSON string
referral_points_instance = ReferralPoints.from_json(json)
# print the JSON string representation of the object
print(ReferralPoints.to_json())

# convert the object into a dict
referral_points_dict = referral_points_instance.to_dict()
# create an instance of ReferralPoints from a dict
referral_points_from_dict = ReferralPoints.from_dict(referral_points_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqExportData.md
================================================================================

# ReqExportData


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  | [optional] 
**account_index** | **int** |  | [optional] [default to -1]
**market_id** | **int** |  | [optional] 
**type** | **str** |  | 

## Example

```python
from lighter.models.req_export_data import ReqExportData

# TODO update the JSON string below
json = "{}"
# create an instance of ReqExportData from a JSON string
req_export_data_instance = ReqExportData.from_json(json)
# print the JSON string representation of the object
print(ReqExportData.to_json())

# convert the object into a dict
req_export_data_dict = req_export_data_instance.to_dict()
# create an instance of ReqExportData from a dict
req_export_data_from_dict = ReqExportData.from_dict(req_export_data_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetAccount.md
================================================================================

# ReqGetAccount


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**by** | **str** |  | 
**value** | **str** |  | 

## Example

```python
from lighter.models.req_get_account import ReqGetAccount

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetAccount from a JSON string
req_get_account_instance = ReqGetAccount.from_json(json)
# print the JSON string representation of the object
print(ReqGetAccount.to_json())

# convert the object into a dict
req_get_account_dict = req_get_account_instance.to_dict()
# create an instance of ReqGetAccount from a dict
req_get_account_from_dict = ReqGetAccount.from_dict(req_get_account_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetAccountActiveOrders.md
================================================================================

# ReqGetAccountActiveOrders


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**market_id** | **int** |  | 
**auth** | **str** |  made optional to support header auth clients | [optional] 

## Example

```python
from lighter.models.req_get_account_active_orders import ReqGetAccountActiveOrders

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetAccountActiveOrders from a JSON string
req_get_account_active_orders_instance = ReqGetAccountActiveOrders.from_json(json)
# print the JSON string representation of the object
print(ReqGetAccountActiveOrders.to_json())

# convert the object into a dict
req_get_account_active_orders_dict = req_get_account_active_orders_instance.to_dict()
# create an instance of ReqGetAccountActiveOrders from a dict
req_get_account_active_orders_from_dict = ReqGetAccountActiveOrders.from_dict(req_get_account_active_orders_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetAccountApiKeys.md
================================================================================

# ReqGetAccountApiKeys


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**api_key_index** | **int** |  | [optional] 

## Example

```python
from lighter.models.req_get_account_api_keys import ReqGetAccountApiKeys

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetAccountApiKeys from a JSON string
req_get_account_api_keys_instance = ReqGetAccountApiKeys.from_json(json)
# print the JSON string representation of the object
print(ReqGetAccountApiKeys.to_json())

# convert the object into a dict
req_get_account_api_keys_dict = req_get_account_api_keys_instance.to_dict()
# create an instance of ReqGetAccountApiKeys from a dict
req_get_account_api_keys_from_dict = ReqGetAccountApiKeys.from_dict(req_get_account_api_keys_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetAccountByL1Address.md
================================================================================

# ReqGetAccountByL1Address


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**l1_address** | **str** |  | 

## Example

```python
from lighter.models.req_get_account_by_l1_address import ReqGetAccountByL1Address

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetAccountByL1Address from a JSON string
req_get_account_by_l1_address_instance = ReqGetAccountByL1Address.from_json(json)
# print the JSON string representation of the object
print(ReqGetAccountByL1Address.to_json())

# convert the object into a dict
req_get_account_by_l1_address_dict = req_get_account_by_l1_address_instance.to_dict()
# create an instance of ReqGetAccountByL1Address from a dict
req_get_account_by_l1_address_from_dict = ReqGetAccountByL1Address.from_dict(req_get_account_by_l1_address_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetAccountInactiveOrders.md
================================================================================

# ReqGetAccountInactiveOrders


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  made optional to support header auth clients | [optional] 
**account_index** | **int** |  | 
**market_id** | **int** |  | [optional] 
**ask_filter** | **int** |  | [optional] 
**between_timestamps** | **str** |  | [optional] 
**cursor** | **str** |  | [optional] 
**limit** | **int** |  | 

## Example

```python
from lighter.models.req_get_account_inactive_orders import ReqGetAccountInactiveOrders

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetAccountInactiveOrders from a JSON string
req_get_account_inactive_orders_instance = ReqGetAccountInactiveOrders.from_json(json)
# print the JSON string representation of the object
print(ReqGetAccountInactiveOrders.to_json())

# convert the object into a dict
req_get_account_inactive_orders_dict = req_get_account_inactive_orders_instance.to_dict()
# create an instance of ReqGetAccountInactiveOrders from a dict
req_get_account_inactive_orders_from_dict = ReqGetAccountInactiveOrders.from_dict(req_get_account_inactive_orders_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetAccountLimits.md
================================================================================

# ReqGetAccountLimits


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**auth** | **str** |  made optional to support header auth clients | [optional] 

## Example

```python
from lighter.models.req_get_account_limits import ReqGetAccountLimits

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetAccountLimits from a JSON string
req_get_account_limits_instance = ReqGetAccountLimits.from_json(json)
# print the JSON string representation of the object
print(ReqGetAccountLimits.to_json())

# convert the object into a dict
req_get_account_limits_dict = req_get_account_limits_instance.to_dict()
# create an instance of ReqGetAccountLimits from a dict
req_get_account_limits_from_dict = ReqGetAccountLimits.from_dict(req_get_account_limits_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetAccountMetadata.md
================================================================================

# ReqGetAccountMetadata


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**by** | **str** |  | 
**value** | **str** |  | 
**auth** | **str** |  | [optional] 

## Example

```python
from lighter.models.req_get_account_metadata import ReqGetAccountMetadata

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetAccountMetadata from a JSON string
req_get_account_metadata_instance = ReqGetAccountMetadata.from_json(json)
# print the JSON string representation of the object
print(ReqGetAccountMetadata.to_json())

# convert the object into a dict
req_get_account_metadata_dict = req_get_account_metadata_instance.to_dict()
# create an instance of ReqGetAccountMetadata from a dict
req_get_account_metadata_from_dict = ReqGetAccountMetadata.from_dict(req_get_account_metadata_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetAccountPnL.md
================================================================================

# ReqGetAccountPnL


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  | [optional] 
**by** | **str** |  | 
**value** | **str** |  | 
**resolution** | **str** |  | 
**start_timestamp** | **int** |  | 
**end_timestamp** | **int** |  | 
**count_back** | **int** |  | 
**ignore_transfers** | **bool** |  | [optional] [default to False]

## Example

```python
from lighter.models.req_get_account_pn_l import ReqGetAccountPnL

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetAccountPnL from a JSON string
req_get_account_pn_l_instance = ReqGetAccountPnL.from_json(json)
# print the JSON string representation of the object
print(ReqGetAccountPnL.to_json())

# convert the object into a dict
req_get_account_pn_l_dict = req_get_account_pn_l_instance.to_dict()
# create an instance of ReqGetAccountPnL from a dict
req_get_account_pn_l_from_dict = ReqGetAccountPnL.from_dict(req_get_account_pn_l_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetAccountTxs.md
================================================================================

# ReqGetAccountTxs


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**index** | **int** |  | [optional] 
**limit** | **int** |  | [optional] 
**by** | **str** |  | [optional] 
**value** | **str** |  | [optional] 
**types** | **List[int]** |  | [optional] 
**auth** | **str** |  | [optional] 

## Example

```python
from lighter.models.req_get_account_txs import ReqGetAccountTxs

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetAccountTxs from a JSON string
req_get_account_txs_instance = ReqGetAccountTxs.from_json(json)
# print the JSON string representation of the object
print(ReqGetAccountTxs.to_json())

# convert the object into a dict
req_get_account_txs_dict = req_get_account_txs_instance.to_dict()
# create an instance of ReqGetAccountTxs from a dict
req_get_account_txs_from_dict = ReqGetAccountTxs.from_dict(req_get_account_txs_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetBlock.md
================================================================================

# ReqGetBlock


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**by** | **str** |  | 
**value** | **str** |  | 

## Example

```python
from lighter.models.req_get_block import ReqGetBlock

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetBlock from a JSON string
req_get_block_instance = ReqGetBlock.from_json(json)
# print the JSON string representation of the object
print(ReqGetBlock.to_json())

# convert the object into a dict
req_get_block_dict = req_get_block_instance.to_dict()
# create an instance of ReqGetBlock from a dict
req_get_block_from_dict = ReqGetBlock.from_dict(req_get_block_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetBlockTxs.md
================================================================================

# ReqGetBlockTxs


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**by** | **str** |  | 
**value** | **str** |  | 

## Example

```python
from lighter.models.req_get_block_txs import ReqGetBlockTxs

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetBlockTxs from a JSON string
req_get_block_txs_instance = ReqGetBlockTxs.from_json(json)
# print the JSON string representation of the object
print(ReqGetBlockTxs.to_json())

# convert the object into a dict
req_get_block_txs_dict = req_get_block_txs_instance.to_dict()
# create an instance of ReqGetBlockTxs from a dict
req_get_block_txs_from_dict = ReqGetBlockTxs.from_dict(req_get_block_txs_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetByAccount.md
================================================================================

# ReqGetByAccount


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**by** | **str** |  | 
**value** | **str** |  | 

## Example

```python
from lighter.models.req_get_by_account import ReqGetByAccount

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetByAccount from a JSON string
req_get_by_account_instance = ReqGetByAccount.from_json(json)
# print the JSON string representation of the object
print(ReqGetByAccount.to_json())

# convert the object into a dict
req_get_by_account_dict = req_get_by_account_instance.to_dict()
# create an instance of ReqGetByAccount from a dict
req_get_by_account_from_dict = ReqGetByAccount.from_dict(req_get_by_account_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetCandlesticks.md
================================================================================

# ReqGetCandlesticks


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | 
**resolution** | **str** |  | 
**start_timestamp** | **int** |  | 
**end_timestamp** | **int** |  | 
**count_back** | **int** |  | 
**set_timestamp_to_end** | **bool** |  | [optional] [default to False]

## Example

```python
from lighter.models.req_get_candlesticks import ReqGetCandlesticks

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetCandlesticks from a JSON string
req_get_candlesticks_instance = ReqGetCandlesticks.from_json(json)
# print the JSON string representation of the object
print(ReqGetCandlesticks.to_json())

# convert the object into a dict
req_get_candlesticks_dict = req_get_candlesticks_instance.to_dict()
# create an instance of ReqGetCandlesticks from a dict
req_get_candlesticks_from_dict = ReqGetCandlesticks.from_dict(req_get_candlesticks_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetDepositHistory.md
================================================================================

# ReqGetDepositHistory


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**auth** | **str** |  made optional to support header auth clients | [optional] 
**l1_address** | **str** |  | 
**cursor** | **str** |  | [optional] 
**filter** | **str** |  | [optional] 

## Example

```python
from lighter.models.req_get_deposit_history import ReqGetDepositHistory

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetDepositHistory from a JSON string
req_get_deposit_history_instance = ReqGetDepositHistory.from_json(json)
# print the JSON string representation of the object
print(ReqGetDepositHistory.to_json())

# convert the object into a dict
req_get_deposit_history_dict = req_get_deposit_history_instance.to_dict()
# create an instance of ReqGetDepositHistory from a dict
req_get_deposit_history_from_dict = ReqGetDepositHistory.from_dict(req_get_deposit_history_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetFastWithdrawInfo.md
================================================================================

# ReqGetFastWithdrawInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**auth** | **str** |  made optional to support header auth clients | [optional] 

## Example

```python
from lighter.models.req_get_fast_withdraw_info import ReqGetFastWithdrawInfo

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetFastWithdrawInfo from a JSON string
req_get_fast_withdraw_info_instance = ReqGetFastWithdrawInfo.from_json(json)
# print the JSON string representation of the object
print(ReqGetFastWithdrawInfo.to_json())

# convert the object into a dict
req_get_fast_withdraw_info_dict = req_get_fast_withdraw_info_instance.to_dict()
# create an instance of ReqGetFastWithdrawInfo from a dict
req_get_fast_withdraw_info_from_dict = ReqGetFastWithdrawInfo.from_dict(req_get_fast_withdraw_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetFundings.md
================================================================================

# ReqGetFundings


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | 
**resolution** | **str** |  | 
**start_timestamp** | **int** |  | 
**end_timestamp** | **int** |  | 
**count_back** | **int** |  | 

## Example

```python
from lighter.models.req_get_fundings import ReqGetFundings

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetFundings from a JSON string
req_get_fundings_instance = ReqGetFundings.from_json(json)
# print the JSON string representation of the object
print(ReqGetFundings.to_json())

# convert the object into a dict
req_get_fundings_dict = req_get_fundings_instance.to_dict()
# create an instance of ReqGetFundings from a dict
req_get_fundings_from_dict = ReqGetFundings.from_dict(req_get_fundings_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetL1Metadata.md
================================================================================

# ReqGetL1Metadata


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  made optional to support header auth clients | [optional] 
**l1_address** | **str** |  | 

## Example

```python
from lighter.models.req_get_l1_metadata import ReqGetL1Metadata

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetL1Metadata from a JSON string
req_get_l1_metadata_instance = ReqGetL1Metadata.from_json(json)
# print the JSON string representation of the object
print(ReqGetL1Metadata.to_json())

# convert the object into a dict
req_get_l1_metadata_dict = req_get_l1_metadata_instance.to_dict()
# create an instance of ReqGetL1Metadata from a dict
req_get_l1_metadata_from_dict = ReqGetL1Metadata.from_dict(req_get_l1_metadata_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetL1Tx.md
================================================================================

# ReqGetL1Tx


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**hash** | **str** |  | 

## Example

```python
from lighter.models.req_get_l1_tx import ReqGetL1Tx

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetL1Tx from a JSON string
req_get_l1_tx_instance = ReqGetL1Tx.from_json(json)
# print the JSON string representation of the object
print(ReqGetL1Tx.to_json())

# convert the object into a dict
req_get_l1_tx_dict = req_get_l1_tx_instance.to_dict()
# create an instance of ReqGetL1Tx from a dict
req_get_l1_tx_from_dict = ReqGetL1Tx.from_dict(req_get_l1_tx_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetLatestDeposit.md
================================================================================

# ReqGetLatestDeposit


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**l1_address** | **str** |  | 

## Example

```python
from lighter.models.req_get_latest_deposit import ReqGetLatestDeposit

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetLatestDeposit from a JSON string
req_get_latest_deposit_instance = ReqGetLatestDeposit.from_json(json)
# print the JSON string representation of the object
print(ReqGetLatestDeposit.to_json())

# convert the object into a dict
req_get_latest_deposit_dict = req_get_latest_deposit_instance.to_dict()
# create an instance of ReqGetLatestDeposit from a dict
req_get_latest_deposit_from_dict = ReqGetLatestDeposit.from_dict(req_get_latest_deposit_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetLiquidationInfos.md
================================================================================

# ReqGetLiquidationInfos


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  made optional to support header auth clients | [optional] 
**account_index** | **int** |  | 
**market_id** | **int** |  | [optional] 
**cursor** | **str** |  | [optional] 
**limit** | **int** |  | 

## Example

```python
from lighter.models.req_get_liquidation_infos import ReqGetLiquidationInfos

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetLiquidationInfos from a JSON string
req_get_liquidation_infos_instance = ReqGetLiquidationInfos.from_json(json)
# print the JSON string representation of the object
print(ReqGetLiquidationInfos.to_json())

# convert the object into a dict
req_get_liquidation_infos_dict = req_get_liquidation_infos_instance.to_dict()
# create an instance of ReqGetLiquidationInfos from a dict
req_get_liquidation_infos_from_dict = ReqGetLiquidationInfos.from_dict(req_get_liquidation_infos_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetNextNonce.md
================================================================================

# ReqGetNextNonce


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**api_key_index** | **int** |  | 

## Example

```python
from lighter.models.req_get_next_nonce import ReqGetNextNonce

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetNextNonce from a JSON string
req_get_next_nonce_instance = ReqGetNextNonce.from_json(json)
# print the JSON string representation of the object
print(ReqGetNextNonce.to_json())

# convert the object into a dict
req_get_next_nonce_dict = req_get_next_nonce_instance.to_dict()
# create an instance of ReqGetNextNonce from a dict
req_get_next_nonce_from_dict = ReqGetNextNonce.from_dict(req_get_next_nonce_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetOrderBookDetails.md
================================================================================

# ReqGetOrderBookDetails


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | [optional] 

## Example

```python
from lighter.models.req_get_order_book_details import ReqGetOrderBookDetails

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetOrderBookDetails from a JSON string
req_get_order_book_details_instance = ReqGetOrderBookDetails.from_json(json)
# print the JSON string representation of the object
print(ReqGetOrderBookDetails.to_json())

# convert the object into a dict
req_get_order_book_details_dict = req_get_order_book_details_instance.to_dict()
# create an instance of ReqGetOrderBookDetails from a dict
req_get_order_book_details_from_dict = ReqGetOrderBookDetails.from_dict(req_get_order_book_details_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetOrderBookOrders.md
================================================================================

# ReqGetOrderBookOrders


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | 
**limit** | **int** |  | 

## Example

```python
from lighter.models.req_get_order_book_orders import ReqGetOrderBookOrders

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetOrderBookOrders from a JSON string
req_get_order_book_orders_instance = ReqGetOrderBookOrders.from_json(json)
# print the JSON string representation of the object
print(ReqGetOrderBookOrders.to_json())

# convert the object into a dict
req_get_order_book_orders_dict = req_get_order_book_orders_instance.to_dict()
# create an instance of ReqGetOrderBookOrders from a dict
req_get_order_book_orders_from_dict = ReqGetOrderBookOrders.from_dict(req_get_order_book_orders_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetOrderBooks.md
================================================================================

# ReqGetOrderBooks


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | [optional] 

## Example

```python
from lighter.models.req_get_order_books import ReqGetOrderBooks

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetOrderBooks from a JSON string
req_get_order_books_instance = ReqGetOrderBooks.from_json(json)
# print the JSON string representation of the object
print(ReqGetOrderBooks.to_json())

# convert the object into a dict
req_get_order_books_dict = req_get_order_books_instance.to_dict()
# create an instance of ReqGetOrderBooks from a dict
req_get_order_books_from_dict = ReqGetOrderBooks.from_dict(req_get_order_books_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetPositionFunding.md
================================================================================

# ReqGetPositionFunding


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  | [optional] 
**account_index** | **int** |  | 
**market_id** | **int** |  | [optional] 
**cursor** | **str** |  | [optional] 
**limit** | **int** |  | 
**side** | **str** |  | [optional] [default to 'all']

## Example

```python
from lighter.models.req_get_position_funding import ReqGetPositionFunding

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetPositionFunding from a JSON string
req_get_position_funding_instance = ReqGetPositionFunding.from_json(json)
# print the JSON string representation of the object
print(ReqGetPositionFunding.to_json())

# convert the object into a dict
req_get_position_funding_dict = req_get_position_funding_instance.to_dict()
# create an instance of ReqGetPositionFunding from a dict
req_get_position_funding_from_dict = ReqGetPositionFunding.from_dict(req_get_position_funding_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetPublicPools.md
================================================================================

# ReqGetPublicPools


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  | [optional] 
**filter** | **str** |  | [optional] 
**index** | **int** |  | 
**limit** | **int** |  | 
**account_index** | **int** |  | [optional] 

## Example

```python
from lighter.models.req_get_public_pools import ReqGetPublicPools

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetPublicPools from a JSON string
req_get_public_pools_instance = ReqGetPublicPools.from_json(json)
# print the JSON string representation of the object
print(ReqGetPublicPools.to_json())

# convert the object into a dict
req_get_public_pools_dict = req_get_public_pools_instance.to_dict()
# create an instance of ReqGetPublicPools from a dict
req_get_public_pools_from_dict = ReqGetPublicPools.from_dict(req_get_public_pools_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetPublicPoolsMetadata.md
================================================================================

# ReqGetPublicPoolsMetadata


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  | [optional] 
**filter** | **str** |  | [optional] 
**index** | **int** |  | 
**limit** | **int** |  | 
**account_index** | **int** |  | [optional] 

## Example

```python
from lighter.models.req_get_public_pools_metadata import ReqGetPublicPoolsMetadata

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetPublicPoolsMetadata from a JSON string
req_get_public_pools_metadata_instance = ReqGetPublicPoolsMetadata.from_json(json)
# print the JSON string representation of the object
print(ReqGetPublicPoolsMetadata.to_json())

# convert the object into a dict
req_get_public_pools_metadata_dict = req_get_public_pools_metadata_instance.to_dict()
# create an instance of ReqGetPublicPoolsMetadata from a dict
req_get_public_pools_metadata_from_dict = ReqGetPublicPoolsMetadata.from_dict(req_get_public_pools_metadata_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetRangeWithCursor.md
================================================================================

# ReqGetRangeWithCursor


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**cursor** | **str** |  | [optional] 
**limit** | **int** |  | 

## Example

```python
from lighter.models.req_get_range_with_cursor import ReqGetRangeWithCursor

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetRangeWithCursor from a JSON string
req_get_range_with_cursor_instance = ReqGetRangeWithCursor.from_json(json)
# print the JSON string representation of the object
print(ReqGetRangeWithCursor.to_json())

# convert the object into a dict
req_get_range_with_cursor_dict = req_get_range_with_cursor_instance.to_dict()
# create an instance of ReqGetRangeWithCursor from a dict
req_get_range_with_cursor_from_dict = ReqGetRangeWithCursor.from_dict(req_get_range_with_cursor_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetRangeWithIndex.md
================================================================================

# ReqGetRangeWithIndex


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**index** | **int** |  | [optional] 
**limit** | **int** |  | 

## Example

```python
from lighter.models.req_get_range_with_index import ReqGetRangeWithIndex

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetRangeWithIndex from a JSON string
req_get_range_with_index_instance = ReqGetRangeWithIndex.from_json(json)
# print the JSON string representation of the object
print(ReqGetRangeWithIndex.to_json())

# convert the object into a dict
req_get_range_with_index_dict = req_get_range_with_index_instance.to_dict()
# create an instance of ReqGetRangeWithIndex from a dict
req_get_range_with_index_from_dict = ReqGetRangeWithIndex.from_dict(req_get_range_with_index_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetRangeWithIndexSortable.md
================================================================================

# ReqGetRangeWithIndexSortable


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**index** | **int** |  | [optional] 
**limit** | **int** |  | [optional] 
**sort** | **str** |  | [optional] [default to 'asc']

## Example

```python
from lighter.models.req_get_range_with_index_sortable import ReqGetRangeWithIndexSortable

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetRangeWithIndexSortable from a JSON string
req_get_range_with_index_sortable_instance = ReqGetRangeWithIndexSortable.from_json(json)
# print the JSON string representation of the object
print(ReqGetRangeWithIndexSortable.to_json())

# convert the object into a dict
req_get_range_with_index_sortable_dict = req_get_range_with_index_sortable_instance.to_dict()
# create an instance of ReqGetRangeWithIndexSortable from a dict
req_get_range_with_index_sortable_from_dict = ReqGetRangeWithIndexSortable.from_dict(req_get_range_with_index_sortable_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetRecentTrades.md
================================================================================

# ReqGetRecentTrades


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | 
**limit** | **int** |  | 

## Example

```python
from lighter.models.req_get_recent_trades import ReqGetRecentTrades

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetRecentTrades from a JSON string
req_get_recent_trades_instance = ReqGetRecentTrades.from_json(json)
# print the JSON string representation of the object
print(ReqGetRecentTrades.to_json())

# convert the object into a dict
req_get_recent_trades_dict = req_get_recent_trades_instance.to_dict()
# create an instance of ReqGetRecentTrades from a dict
req_get_recent_trades_from_dict = ReqGetRecentTrades.from_dict(req_get_recent_trades_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetReferralPoints.md
================================================================================

# ReqGetReferralPoints


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  made optional to support header auth clients | [optional] 
**account_index** | **int** |  | 

## Example

```python
from lighter.models.req_get_referral_points import ReqGetReferralPoints

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetReferralPoints from a JSON string
req_get_referral_points_instance = ReqGetReferralPoints.from_json(json)
# print the JSON string representation of the object
print(ReqGetReferralPoints.to_json())

# convert the object into a dict
req_get_referral_points_dict = req_get_referral_points_instance.to_dict()
# create an instance of ReqGetReferralPoints from a dict
req_get_referral_points_from_dict = ReqGetReferralPoints.from_dict(req_get_referral_points_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetTrades.md
================================================================================

# ReqGetTrades


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  | [optional] 
**market_id** | **int** |  | [optional] 
**account_index** | **int** |  | [optional] [default to -1]
**order_index** | **int** |  | [optional] 
**sort_by** | **str** |  | 
**sort_dir** | **str** |  | [optional] [default to 'desc']
**cursor** | **str** |  | [optional] 
**var_from** | **int** |  | [optional] [default to -1]
**ask_filter** | **int** |  | [optional] 
**limit** | **int** |  | 

## Example

```python
from lighter.models.req_get_trades import ReqGetTrades

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetTrades from a JSON string
req_get_trades_instance = ReqGetTrades.from_json(json)
# print the JSON string representation of the object
print(ReqGetTrades.to_json())

# convert the object into a dict
req_get_trades_dict = req_get_trades_instance.to_dict()
# create an instance of ReqGetTrades from a dict
req_get_trades_from_dict = ReqGetTrades.from_dict(req_get_trades_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetTransferFeeInfo.md
================================================================================

# ReqGetTransferFeeInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**auth** | **str** |  | [optional] 
**account_index** | **int** |  | 
**to_account_index** | **int** |  | [optional] [default to -1]

## Example

```python
from lighter.models.req_get_transfer_fee_info import ReqGetTransferFeeInfo

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetTransferFeeInfo from a JSON string
req_get_transfer_fee_info_instance = ReqGetTransferFeeInfo.from_json(json)
# print the JSON string representation of the object
print(ReqGetTransferFeeInfo.to_json())

# convert the object into a dict
req_get_transfer_fee_info_dict = req_get_transfer_fee_info_instance.to_dict()
# create an instance of ReqGetTransferFeeInfo from a dict
req_get_transfer_fee_info_from_dict = ReqGetTransferFeeInfo.from_dict(req_get_transfer_fee_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetTransferHistory.md
================================================================================

# ReqGetTransferHistory


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**auth** | **str** |  made optional to support header auth clients | [optional] 
**cursor** | **str** |  | [optional] 

## Example

```python
from lighter.models.req_get_transfer_history import ReqGetTransferHistory

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetTransferHistory from a JSON string
req_get_transfer_history_instance = ReqGetTransferHistory.from_json(json)
# print the JSON string representation of the object
print(ReqGetTransferHistory.to_json())

# convert the object into a dict
req_get_transfer_history_dict = req_get_transfer_history_instance.to_dict()
# create an instance of ReqGetTransferHistory from a dict
req_get_transfer_history_from_dict = ReqGetTransferHistory.from_dict(req_get_transfer_history_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetTx.md
================================================================================

# ReqGetTx


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**by** | **str** |  | 
**value** | **str** |  | 

## Example

```python
from lighter.models.req_get_tx import ReqGetTx

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetTx from a JSON string
req_get_tx_instance = ReqGetTx.from_json(json)
# print the JSON string representation of the object
print(ReqGetTx.to_json())

# convert the object into a dict
req_get_tx_dict = req_get_tx_instance.to_dict()
# create an instance of ReqGetTx from a dict
req_get_tx_from_dict = ReqGetTx.from_dict(req_get_tx_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ReqGetWithdrawHistory.md
================================================================================

# ReqGetWithdrawHistory


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**account_index** | **int** |  | 
**auth** | **str** |  made optional to support header auth clients | [optional] 
**cursor** | **str** |  | [optional] 
**filter** | **str** |  | [optional] 

## Example

```python
from lighter.models.req_get_withdraw_history import ReqGetWithdrawHistory

# TODO update the JSON string below
json = "{}"
# create an instance of ReqGetWithdrawHistory from a JSON string
req_get_withdraw_history_instance = ReqGetWithdrawHistory.from_json(json)
# print the JSON string representation of the object
print(ReqGetWithdrawHistory.to_json())

# convert the object into a dict
req_get_withdraw_history_dict = req_get_withdraw_history_instance.to_dict()
# create an instance of ReqGetWithdrawHistory from a dict
req_get_withdraw_history_from_dict = ReqGetWithdrawHistory.from_dict(req_get_withdraw_history_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\RespChangeAccountTier.md
================================================================================

# RespChangeAccountTier


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 

## Example

```python
from lighter.models.resp_change_account_tier import RespChangeAccountTier

# TODO update the JSON string below
json = "{}"
# create an instance of RespChangeAccountTier from a JSON string
resp_change_account_tier_instance = RespChangeAccountTier.from_json(json)
# print the JSON string representation of the object
print(RespChangeAccountTier.to_json())

# convert the object into a dict
resp_change_account_tier_dict = resp_change_account_tier_instance.to_dict()
# create an instance of RespChangeAccountTier from a dict
resp_change_account_tier_from_dict = RespChangeAccountTier.from_dict(resp_change_account_tier_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\RespGetFastBridgeInfo.md
================================================================================

# RespGetFastBridgeInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**fast_bridge_limit** | **str** |  | 

## Example

```python
from lighter.models.resp_get_fast_bridge_info import RespGetFastBridgeInfo

# TODO update the JSON string below
json = "{}"
# create an instance of RespGetFastBridgeInfo from a JSON string
resp_get_fast_bridge_info_instance = RespGetFastBridgeInfo.from_json(json)
# print the JSON string representation of the object
print(RespGetFastBridgeInfo.to_json())

# convert the object into a dict
resp_get_fast_bridge_info_dict = resp_get_fast_bridge_info_instance.to_dict()
# create an instance of RespGetFastBridgeInfo from a dict
resp_get_fast_bridge_info_from_dict = RespGetFastBridgeInfo.from_dict(resp_get_fast_bridge_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\RespPublicPoolsMetadata.md
================================================================================

# RespPublicPoolsMetadata


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**public_pools** | [**List[PublicPoolMetadata]**](PublicPoolMetadata.md) |  | 

## Example

```python
from lighter.models.resp_public_pools_metadata import RespPublicPoolsMetadata

# TODO update the JSON string below
json = "{}"
# create an instance of RespPublicPoolsMetadata from a JSON string
resp_public_pools_metadata_instance = RespPublicPoolsMetadata.from_json(json)
# print the JSON string representation of the object
print(RespPublicPoolsMetadata.to_json())

# convert the object into a dict
resp_public_pools_metadata_dict = resp_public_pools_metadata_instance.to_dict()
# create an instance of RespPublicPoolsMetadata from a dict
resp_public_pools_metadata_from_dict = RespPublicPoolsMetadata.from_dict(resp_public_pools_metadata_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\RespSendTx.md
================================================================================

# RespSendTx


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**tx_hash** | **str** |  | 
**predicted_execution_time_ms** | **int** |  | 

## Example

```python
from lighter.models.resp_send_tx import RespSendTx

# TODO update the JSON string below
json = "{}"
# create an instance of RespSendTx from a JSON string
resp_send_tx_instance = RespSendTx.from_json(json)
# print the JSON string representation of the object
print(RespSendTx.to_json())

# convert the object into a dict
resp_send_tx_dict = resp_send_tx_instance.to_dict()
# create an instance of RespSendTx from a dict
resp_send_tx_from_dict = RespSendTx.from_dict(resp_send_tx_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\RespSendTxBatch.md
================================================================================

# RespSendTxBatch


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**tx_hash** | **List[str]** |  | 
**predicted_execution_time_ms** | **int** |  | 

## Example

```python
from lighter.models.resp_send_tx_batch import RespSendTxBatch

# TODO update the JSON string below
json = "{}"
# create an instance of RespSendTxBatch from a JSON string
resp_send_tx_batch_instance = RespSendTxBatch.from_json(json)
# print the JSON string representation of the object
print(RespSendTxBatch.to_json())

# convert the object into a dict
resp_send_tx_batch_dict = resp_send_tx_batch_instance.to_dict()
# create an instance of RespSendTxBatch from a dict
resp_send_tx_batch_from_dict = RespSendTxBatch.from_dict(resp_send_tx_batch_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\RespWithdrawalDelay.md
================================================================================

# RespWithdrawalDelay


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**seconds** | **int** |  | 

## Example

```python
from lighter.models.resp_withdrawal_delay import RespWithdrawalDelay

# TODO update the JSON string below
json = "{}"
# create an instance of RespWithdrawalDelay from a JSON string
resp_withdrawal_delay_instance = RespWithdrawalDelay.from_json(json)
# print the JSON string representation of the object
print(RespWithdrawalDelay.to_json())

# convert the object into a dict
resp_withdrawal_delay_dict = resp_withdrawal_delay_instance.to_dict()
# create an instance of RespWithdrawalDelay from a dict
resp_withdrawal_delay_from_dict = RespWithdrawalDelay.from_dict(resp_withdrawal_delay_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ResultCode.md
================================================================================

# ResultCode


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 

## Example

```python
from lighter.models.result_code import ResultCode

# TODO update the JSON string below
json = "{}"
# create an instance of ResultCode from a JSON string
result_code_instance = ResultCode.from_json(json)
# print the JSON string representation of the object
print(ResultCode.to_json())

# convert the object into a dict
result_code_dict = result_code_instance.to_dict()
# create an instance of ResultCode from a dict
result_code_from_dict = ResultCode.from_dict(result_code_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\RiskInfo.md
================================================================================

# RiskInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**cross_risk_parameters** | [**RiskParameters**](RiskParameters.md) |  | 
**isolated_risk_parameters** | [**List[RiskParameters]**](RiskParameters.md) |  | 

## Example

```python
from lighter.models.risk_info import RiskInfo

# TODO update the JSON string below
json = "{}"
# create an instance of RiskInfo from a JSON string
risk_info_instance = RiskInfo.from_json(json)
# print the JSON string representation of the object
print(RiskInfo.to_json())

# convert the object into a dict
risk_info_dict = risk_info_instance.to_dict()
# create an instance of RiskInfo from a dict
risk_info_from_dict = RiskInfo.from_dict(risk_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\RiskParameters.md
================================================================================

# RiskParameters


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**market_id** | **int** |  | 
**collateral** | **str** |  | 
**total_account_value** | **str** |  | 
**initial_margin_req** | **str** |  | 
**maintenance_margin_req** | **str** |  | 
**close_out_margin_req** | **str** |  | 

## Example

```python
from lighter.models.risk_parameters import RiskParameters

# TODO update the JSON string below
json = "{}"
# create an instance of RiskParameters from a JSON string
risk_parameters_instance = RiskParameters.from_json(json)
# print the JSON string representation of the object
print(RiskParameters.to_json())

# convert the object into a dict
risk_parameters_dict = risk_parameters_instance.to_dict()
# create an instance of RiskParameters from a dict
risk_parameters_from_dict = RiskParameters.from_dict(risk_parameters_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\RootApi.md
================================================================================

# lighter.RootApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**info**](RootApi.md#info) | **GET** /info | info
[**status**](RootApi.md#status) | **GET** / | status


# **info**
> ZkLighterInfo info()

info

Get info of zklighter

### Example


```python
import lighter
from lighter.models.zk_lighter_info import ZkLighterInfo
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.RootApi(api_client)

    try:
        # info
        api_response = await api_instance.info()
        print("The response of RootApi->info:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling RootApi->info: %s\n" % e)
```



### Parameters

This endpoint does not need any parameter.

### Return type

[**ZkLighterInfo**](ZkLighterInfo.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **status**
> Status status()

status

Get status of zklighter

### Example


```python
import lighter
from lighter.models.status import Status
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.RootApi(api_client)

    try:
        # status
        api_response = await api_instance.status()
        print("The response of RootApi->status:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling RootApi->status: %s\n" % e)
```



### Parameters

This endpoint does not need any parameter.

### Return type

[**Status**](Status.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\SharePrice.md
================================================================================

# SharePrice


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**timestamp** | **int** |  | 
**share_price** | **float** |  | 

## Example

```python
from lighter.models.share_price import SharePrice

# TODO update the JSON string below
json = "{}"
# create an instance of SharePrice from a JSON string
share_price_instance = SharePrice.from_json(json)
# print the JSON string representation of the object
print(SharePrice.to_json())

# convert the object into a dict
share_price_dict = share_price_instance.to_dict()
# create an instance of SharePrice from a dict
share_price_from_dict = SharePrice.from_dict(share_price_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\SimpleOrder.md
================================================================================

# SimpleOrder


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**order_index** | **int** |  | 
**order_id** | **str** |  | 
**owner_account_index** | **int** |  | 
**initial_base_amount** | **str** |  | 
**remaining_base_amount** | **str** |  | 
**price** | **str** |  | 
**order_expiry** | **int** |  | 

## Example

```python
from lighter.models.simple_order import SimpleOrder

# TODO update the JSON string below
json = "{}"
# create an instance of SimpleOrder from a JSON string
simple_order_instance = SimpleOrder.from_json(json)
# print the JSON string representation of the object
print(SimpleOrder.to_json())

# convert the object into a dict
simple_order_dict = simple_order_instance.to_dict()
# create an instance of SimpleOrder from a dict
simple_order_from_dict = SimpleOrder.from_dict(simple_order_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Status.md
================================================================================

# Status


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**status** | **int** |  | 
**network_id** | **int** |  | 
**timestamp** | **int** |  | 

## Example

```python
from lighter.models.status import Status

# TODO update the JSON string below
json = "{}"
# create an instance of Status from a JSON string
status_instance = Status.from_json(json)
# print the JSON string representation of the object
print(Status.to_json())

# convert the object into a dict
status_dict = status_instance.to_dict()
# create an instance of Status from a dict
status_from_dict = Status.from_dict(status_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\SubAccounts.md
================================================================================

# SubAccounts


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**l1_address** | **str** |  | 
**sub_accounts** | [**List[Account]**](Account.md) |  | 

## Example

```python
from lighter.models.sub_accounts import SubAccounts

# TODO update the JSON string below
json = "{}"
# create an instance of SubAccounts from a JSON string
sub_accounts_instance = SubAccounts.from_json(json)
# print the JSON string representation of the object
print(SubAccounts.to_json())

# convert the object into a dict
sub_accounts_dict = sub_accounts_instance.to_dict()
# create an instance of SubAccounts from a dict
sub_accounts_from_dict = SubAccounts.from_dict(sub_accounts_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Ticker.md
================================================================================

# Ticker


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**s** | **str** |  | 
**a** | [**PriceLevel**](PriceLevel.md) |  | 
**b** | [**PriceLevel**](PriceLevel.md) |  | 

## Example

```python
from lighter.models.ticker import Ticker

# TODO update the JSON string below
json = "{}"
# create an instance of Ticker from a JSON string
ticker_instance = Ticker.from_json(json)
# print the JSON string representation of the object
print(Ticker.to_json())

# convert the object into a dict
ticker_dict = ticker_instance.to_dict()
# create an instance of Ticker from a dict
ticker_from_dict = Ticker.from_dict(ticker_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Trade.md
================================================================================

# Trade


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**trade_id** | **int** |  | 
**tx_hash** | **str** |  | 
**type** | **str** |  | 
**market_id** | **int** |  | 
**size** | **str** |  | 
**price** | **str** |  | 
**usd_amount** | **str** |  | 
**ask_id** | **int** |  | 
**bid_id** | **int** |  | 
**ask_account_id** | **int** |  | 
**bid_account_id** | **int** |  | 
**is_maker_ask** | **bool** |  | 
**block_height** | **int** |  | 
**timestamp** | **int** |  | 
**taker_fee** | **int** |  | 
**taker_position_size_before** | **str** |  | 
**taker_entry_quote_before** | **str** |  | 
**taker_initial_margin_fraction_before** | **int** |  | 
**taker_position_sign_changed** | **bool** |  | 
**maker_fee** | **int** |  | 
**maker_position_size_before** | **str** |  | 
**maker_entry_quote_before** | **str** |  | 
**maker_initial_margin_fraction_before** | **int** |  | 
**maker_position_sign_changed** | **bool** |  | 

## Example

```python
from lighter.models.trade import Trade

# TODO update the JSON string below
json = "{}"
# create an instance of Trade from a JSON string
trade_instance = Trade.from_json(json)
# print the JSON string representation of the object
print(Trade.to_json())

# convert the object into a dict
trade_dict = trade_instance.to_dict()
# create an instance of Trade from a dict
trade_from_dict = Trade.from_dict(trade_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Trades.md
================================================================================

# Trades


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**next_cursor** | **str** |  | [optional] 
**trades** | [**List[Trade]**](Trade.md) |  | 

## Example

```python
from lighter.models.trades import Trades

# TODO update the JSON string below
json = "{}"
# create an instance of Trades from a JSON string
trades_instance = Trades.from_json(json)
# print the JSON string representation of the object
print(Trades.to_json())

# convert the object into a dict
trades_dict = trades_instance.to_dict()
# create an instance of Trades from a dict
trades_from_dict = Trades.from_dict(trades_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\TransactionApi.md
================================================================================

# lighter.TransactionApi

All URIs are relative to *https://mainnet.zklighter.elliot.ai*

Method | HTTP request | Description
------------- | ------------- | -------------
[**account_txs**](TransactionApi.md#account_txs) | **GET** /api/v1/accountTxs | accountTxs
[**block_txs**](TransactionApi.md#block_txs) | **GET** /api/v1/blockTxs | blockTxs
[**deposit_history**](TransactionApi.md#deposit_history) | **GET** /api/v1/deposit/history | deposit_history
[**next_nonce**](TransactionApi.md#next_nonce) | **GET** /api/v1/nextNonce | nextNonce
[**send_tx**](TransactionApi.md#send_tx) | **POST** /api/v1/sendTx | sendTx
[**send_tx_batch**](TransactionApi.md#send_tx_batch) | **POST** /api/v1/sendTxBatch | sendTxBatch
[**transfer_history**](TransactionApi.md#transfer_history) | **GET** /api/v1/transfer/history | transfer_history
[**tx**](TransactionApi.md#tx) | **GET** /api/v1/tx | tx
[**tx_from_l1_tx_hash**](TransactionApi.md#tx_from_l1_tx_hash) | **GET** /api/v1/txFromL1TxHash | txFromL1TxHash
[**txs**](TransactionApi.md#txs) | **GET** /api/v1/txs | txs
[**withdraw_history**](TransactionApi.md#withdraw_history) | **GET** /api/v1/withdraw/history | withdraw_history


# **account_txs**
> Txs account_txs(limit, by, value, authorization=authorization, index=index, types=types, auth=auth)

accountTxs

Get transactions of a specific account

### Example


```python
import lighter
from lighter.models.txs import Txs
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    limit = 56 # int | 
    by = 'by_example' # str | 
    value = 'value_example' # str | 
    authorization = 'authorization_example' # str |  (optional)
    index = 56 # int |  (optional)
    types = [56] # List[int] |  (optional)
    auth = 'auth_example' # str |  (optional)

    try:
        # accountTxs
        api_response = await api_instance.account_txs(limit, by, value, authorization=authorization, index=index, types=types, auth=auth)
        print("The response of TransactionApi->account_txs:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->account_txs: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **limit** | **int**|  | 
 **by** | **str**|  | 
 **value** | **str**|  | 
 **authorization** | **str**|  | [optional] 
 **index** | **int**|  | [optional] 
 **types** | [**List[int]**](int.md)|  | [optional] 
 **auth** | **str**|  | [optional] 

### Return type

[**Txs**](Txs.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **block_txs**
> Txs block_txs(by, value)

blockTxs

Get transactions in a block

### Example


```python
import lighter
from lighter.models.txs import Txs
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    by = 'by_example' # str | 
    value = 'value_example' # str | 

    try:
        # blockTxs
        api_response = await api_instance.block_txs(by, value)
        print("The response of TransactionApi->block_txs:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->block_txs: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **by** | **str**|  | 
 **value** | **str**|  | 

### Return type

[**Txs**](Txs.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **deposit_history**
> DepositHistory deposit_history(account_index, l1_address, authorization=authorization, auth=auth, cursor=cursor, filter=filter)

deposit_history

Get deposit history

### Example


```python
import lighter
from lighter.models.deposit_history import DepositHistory
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    account_index = 56 # int | 
    l1_address = 'l1_address_example' # str | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)
    cursor = 'cursor_example' # str |  (optional)
    filter = 'filter_example' # str |  (optional)

    try:
        # deposit_history
        api_response = await api_instance.deposit_history(account_index, l1_address, authorization=authorization, auth=auth, cursor=cursor, filter=filter)
        print("The response of TransactionApi->deposit_history:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->deposit_history: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **l1_address** | **str**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 
 **cursor** | **str**|  | [optional] 
 **filter** | **str**|  | [optional] 

### Return type

[**DepositHistory**](DepositHistory.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **next_nonce**
> NextNonce next_nonce(account_index, api_key_index)

nextNonce

Get next nonce for a specific account and api key

### Example


```python
import lighter
from lighter.models.next_nonce import NextNonce
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    account_index = 56 # int | 
    api_key_index = 56 # int | 

    try:
        # nextNonce
        api_response = await api_instance.next_nonce(account_index, api_key_index)
        print("The response of TransactionApi->next_nonce:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->next_nonce: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **api_key_index** | **int**|  | 

### Return type

[**NextNonce**](NextNonce.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **send_tx**
> RespSendTx send_tx(tx_type, tx_info, price_protection=price_protection)

sendTx

You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)

### Example


```python
import lighter
from lighter.models.resp_send_tx import RespSendTx
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    tx_type = 56 # int | 
    tx_info = 'tx_info_example' # str | 
    price_protection = True # bool |  (optional) (default to True)

    try:
        # sendTx
        api_response = await api_instance.send_tx(tx_type, tx_info, price_protection=price_protection)
        print("The response of TransactionApi->send_tx:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->send_tx: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **tx_type** | **int**|  | 
 **tx_info** | **str**|  | 
 **price_protection** | **bool**|  | [optional] [default to True]

### Return type

[**RespSendTx**](RespSendTx.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: multipart/form-data
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **send_tx_batch**
> RespSendTxBatch send_tx_batch(tx_types, tx_infos)

sendTxBatch

You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)

### Example


```python
import lighter
from lighter.models.resp_send_tx_batch import RespSendTxBatch
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    tx_types = 'tx_types_example' # str | 
    tx_infos = 'tx_infos_example' # str | 

    try:
        # sendTxBatch
        api_response = await api_instance.send_tx_batch(tx_types, tx_infos)
        print("The response of TransactionApi->send_tx_batch:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->send_tx_batch: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **tx_types** | **str**|  | 
 **tx_infos** | **str**|  | 

### Return type

[**RespSendTxBatch**](RespSendTxBatch.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: multipart/form-data
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **transfer_history**
> TransferHistory transfer_history(account_index, authorization=authorization, auth=auth, cursor=cursor)

transfer_history

Get transfer history

### Example


```python
import lighter
from lighter.models.transfer_history import TransferHistory
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    account_index = 56 # int | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)
    cursor = 'cursor_example' # str |  (optional)

    try:
        # transfer_history
        api_response = await api_instance.transfer_history(account_index, authorization=authorization, auth=auth, cursor=cursor)
        print("The response of TransactionApi->transfer_history:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->transfer_history: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 
 **cursor** | **str**|  | [optional] 

### Return type

[**TransferHistory**](TransferHistory.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **tx**
> EnrichedTx tx(by, value)

tx

Get transaction by hash or sequence index

### Example


```python
import lighter
from lighter.models.enriched_tx import EnrichedTx
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    by = 'by_example' # str | 
    value = 'value_example' # str | 

    try:
        # tx
        api_response = await api_instance.tx(by, value)
        print("The response of TransactionApi->tx:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->tx: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **by** | **str**|  | 
 **value** | **str**|  | 

### Return type

[**EnrichedTx**](EnrichedTx.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **tx_from_l1_tx_hash**
> EnrichedTx tx_from_l1_tx_hash(hash)

txFromL1TxHash

Get L1 transaction by L1 transaction hash

### Example


```python
import lighter
from lighter.models.enriched_tx import EnrichedTx
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    hash = 'hash_example' # str | 

    try:
        # txFromL1TxHash
        api_response = await api_instance.tx_from_l1_tx_hash(hash)
        print("The response of TransactionApi->tx_from_l1_tx_hash:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->tx_from_l1_tx_hash: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **hash** | **str**|  | 

### Return type

[**EnrichedTx**](EnrichedTx.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **txs**
> Txs txs(limit, index=index)

txs

Get transactions which are already packed into blocks

### Example


```python
import lighter
from lighter.models.txs import Txs
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    limit = 56 # int | 
    index = 56 # int |  (optional)

    try:
        # txs
        api_response = await api_instance.txs(limit, index=index)
        print("The response of TransactionApi->txs:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->txs: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **limit** | **int**|  | 
 **index** | **int**|  | [optional] 

### Return type

[**Txs**](Txs.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)

# **withdraw_history**
> WithdrawHistory withdraw_history(account_index, authorization=authorization, auth=auth, cursor=cursor, filter=filter)

withdraw_history

Get withdraw history

### Example


```python
import lighter
from lighter.models.withdraw_history import WithdrawHistory
from lighter.rest import ApiException
from pprint import pprint

# Defining the host is optional and defaults to https://mainnet.zklighter.elliot.ai
# See configuration.py for a list of all supported configuration parameters.
configuration = lighter.Configuration(
    host = "https://mainnet.zklighter.elliot.ai"
)


# Enter a context with an instance of the API client
async with lighter.ApiClient(configuration) as api_client:
    # Create an instance of the API class
    api_instance = lighter.TransactionApi(api_client)
    account_index = 56 # int | 
    authorization = 'authorization_example' # str |  make required after integ is done (optional)
    auth = 'auth_example' # str |  made optional to support header auth clients (optional)
    cursor = 'cursor_example' # str |  (optional)
    filter = 'filter_example' # str |  (optional)

    try:
        # withdraw_history
        api_response = await api_instance.withdraw_history(account_index, authorization=authorization, auth=auth, cursor=cursor, filter=filter)
        print("The response of TransactionApi->withdraw_history:\n")
        pprint(api_response)
    except Exception as e:
        print("Exception when calling TransactionApi->withdraw_history: %s\n" % e)
```



### Parameters


Name | Type | Description  | Notes
------------- | ------------- | ------------- | -------------
 **account_index** | **int**|  | 
 **authorization** | **str**|  make required after integ is done | [optional] 
 **auth** | **str**|  made optional to support header auth clients | [optional] 
 **cursor** | **str**|  | [optional] 
 **filter** | **str**|  | [optional] 

### Return type

[**WithdrawHistory**](WithdrawHistory.md)

### Authorization

No authorization required

### HTTP request headers

 - **Content-Type**: Not defined
 - **Accept**: application/json

### HTTP response details

| Status code | Description | Response headers |
|-------------|-------------|------------------|
**200** | A successful response. |  -  |
**400** | Bad request |  -  |

[[Back to top]](#) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to Model list]](../README.md#documentation-for-models) [[Back to README]](../README.md)




================================================================================
File: .\docs\TransferFeeInfo.md
================================================================================

# TransferFeeInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**transfer_fee_usdc** | **int** |  | 

## Example

```python
from lighter.models.transfer_fee_info import TransferFeeInfo

# TODO update the JSON string below
json = "{}"
# create an instance of TransferFeeInfo from a JSON string
transfer_fee_info_instance = TransferFeeInfo.from_json(json)
# print the JSON string representation of the object
print(TransferFeeInfo.to_json())

# convert the object into a dict
transfer_fee_info_dict = transfer_fee_info_instance.to_dict()
# create an instance of TransferFeeInfo from a dict
transfer_fee_info_from_dict = TransferFeeInfo.from_dict(transfer_fee_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\TransferHistory.md
================================================================================

# TransferHistory


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**transfers** | [**List[TransferHistoryItem]**](TransferHistoryItem.md) |  | 
**cursor** | **str** |  | 

## Example

```python
from lighter.models.transfer_history import TransferHistory

# TODO update the JSON string below
json = "{}"
# create an instance of TransferHistory from a JSON string
transfer_history_instance = TransferHistory.from_json(json)
# print the JSON string representation of the object
print(TransferHistory.to_json())

# convert the object into a dict
transfer_history_dict = transfer_history_instance.to_dict()
# create an instance of TransferHistory from a dict
transfer_history_from_dict = TransferHistory.from_dict(transfer_history_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\TransferHistoryItem.md
================================================================================

# TransferHistoryItem


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**id** | **str** |  | 
**amount** | **str** |  | 
**timestamp** | **int** |  | 
**type** | **str** |  | 
**from_l1_address** | **str** |  | 
**to_l1_address** | **str** |  | 
**from_account_index** | **int** |  | 
**to_account_index** | **int** |  | 
**tx_hash** | **str** |  | 

## Example

```python
from lighter.models.transfer_history_item import TransferHistoryItem

# TODO update the JSON string below
json = "{}"
# create an instance of TransferHistoryItem from a JSON string
transfer_history_item_instance = TransferHistoryItem.from_json(json)
# print the JSON string representation of the object
print(TransferHistoryItem.to_json())

# convert the object into a dict
transfer_history_item_dict = transfer_history_item_instance.to_dict()
# create an instance of TransferHistoryItem from a dict
transfer_history_item_from_dict = TransferHistoryItem.from_dict(transfer_history_item_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Tx.md
================================================================================

# Tx


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**hash** | **str** |  | 
**type** | **int** |  | 
**info** | **str** |  | 
**event_info** | **str** |  | 
**status** | **int** |  | 
**transaction_index** | **int** |  | 
**l1_address** | **str** |  | 
**account_index** | **int** |  | 
**nonce** | **int** |  | 
**expire_at** | **int** |  | 
**block_height** | **int** |  | 
**queued_at** | **int** |  | 
**executed_at** | **int** |  | 
**sequence_index** | **int** |  | 
**parent_hash** | **str** |  | 

## Example

```python
from lighter.models.tx import Tx

# TODO update the JSON string below
json = "{}"
# create an instance of Tx from a JSON string
tx_instance = Tx.from_json(json)
# print the JSON string representation of the object
print(Tx.to_json())

# convert the object into a dict
tx_dict = tx_instance.to_dict()
# create an instance of Tx from a dict
tx_from_dict = Tx.from_dict(tx_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\TxHash.md
================================================================================

# TxHash


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**tx_hash** | **str** |  | 

## Example

```python
from lighter.models.tx_hash import TxHash

# TODO update the JSON string below
json = "{}"
# create an instance of TxHash from a JSON string
tx_hash_instance = TxHash.from_json(json)
# print the JSON string representation of the object
print(TxHash.to_json())

# convert the object into a dict
tx_hash_dict = tx_hash_instance.to_dict()
# create an instance of TxHash from a dict
tx_hash_from_dict = TxHash.from_dict(tx_hash_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\TxHashes.md
================================================================================

# TxHashes


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**tx_hash** | **List[str]** |  | 

## Example

```python
from lighter.models.tx_hashes import TxHashes

# TODO update the JSON string below
json = "{}"
# create an instance of TxHashes from a JSON string
tx_hashes_instance = TxHashes.from_json(json)
# print the JSON string representation of the object
print(TxHashes.to_json())

# convert the object into a dict
tx_hashes_dict = tx_hashes_instance.to_dict()
# create an instance of TxHashes from a dict
tx_hashes_from_dict = TxHashes.from_dict(tx_hashes_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\Txs.md
================================================================================

# Txs


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**txs** | [**List[Tx]**](Tx.md) |  | 

## Example

```python
from lighter.models.txs import Txs

# TODO update the JSON string below
json = "{}"
# create an instance of Txs from a JSON string
txs_instance = Txs.from_json(json)
# print the JSON string representation of the object
print(Txs.to_json())

# convert the object into a dict
txs_dict = txs_instance.to_dict()
# create an instance of Txs from a dict
txs_from_dict = Txs.from_dict(txs_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ValidatorInfo.md
================================================================================

# ValidatorInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**address** | **str** |  | 
**is_active** | **bool** |  | 

## Example

```python
from lighter.models.validator_info import ValidatorInfo

# TODO update the JSON string below
json = "{}"
# create an instance of ValidatorInfo from a JSON string
validator_info_instance = ValidatorInfo.from_json(json)
# print the JSON string representation of the object
print(ValidatorInfo.to_json())

# convert the object into a dict
validator_info_dict = validator_info_instance.to_dict()
# create an instance of ValidatorInfo from a dict
validator_info_from_dict = ValidatorInfo.from_dict(validator_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\WithdrawHistory.md
================================================================================

# WithdrawHistory


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**code** | **int** |  | 
**message** | **str** |  | [optional] 
**withdraws** | [**List[WithdrawHistoryItem]**](WithdrawHistoryItem.md) |  | 
**cursor** | **str** |  | 

## Example

```python
from lighter.models.withdraw_history import WithdrawHistory

# TODO update the JSON string below
json = "{}"
# create an instance of WithdrawHistory from a JSON string
withdraw_history_instance = WithdrawHistory.from_json(json)
# print the JSON string representation of the object
print(WithdrawHistory.to_json())

# convert the object into a dict
withdraw_history_dict = withdraw_history_instance.to_dict()
# create an instance of WithdrawHistory from a dict
withdraw_history_from_dict = WithdrawHistory.from_dict(withdraw_history_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\WithdrawHistoryItem.md
================================================================================

# WithdrawHistoryItem


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**id** | **str** |  | 
**amount** | **str** |  | 
**timestamp** | **int** |  | 
**status** | **str** |  | 
**type** | **str** |  | 
**l1_tx_hash** | **str** |  | 

## Example

```python
from lighter.models.withdraw_history_item import WithdrawHistoryItem

# TODO update the JSON string below
json = "{}"
# create an instance of WithdrawHistoryItem from a JSON string
withdraw_history_item_instance = WithdrawHistoryItem.from_json(json)
# print the JSON string representation of the object
print(WithdrawHistoryItem.to_json())

# convert the object into a dict
withdraw_history_item_dict = withdraw_history_item_instance.to_dict()
# create an instance of WithdrawHistoryItem from a dict
withdraw_history_item_from_dict = WithdrawHistoryItem.from_dict(withdraw_history_item_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\docs\ZkLighterInfo.md
================================================================================

# ZkLighterInfo


## Properties

Name | Type | Description | Notes
------------ | ------------- | ------------- | -------------
**contract_address** | **str** |  | 

## Example

```python
from lighter.models.zk_lighter_info import ZkLighterInfo

# TODO update the JSON string below
json = "{}"
# create an instance of ZkLighterInfo from a JSON string
zk_lighter_info_instance = ZkLighterInfo.from_json(json)
# print the JSON string representation of the object
print(ZkLighterInfo.to_json())

# convert the object into a dict
zk_lighter_info_dict = zk_lighter_info_instance.to_dict()
# create an instance of ZkLighterInfo from a dict
zk_lighter_info_from_dict = ZkLighterInfo.from_dict(zk_lighter_info_dict)
```
[[Back to Model list]](../README.md#documentation-for-models) [[Back to API list]](../README.md#documentation-for-api-endpoints) [[Back to README]](../README.md)





================================================================================
File: .\examples\create_cancel_order.py
================================================================================

import asyncio
import logging
import lighter

logging.basicConfig(level=logging.DEBUG)

# The API_KEY_PRIVATE_KEY provided belongs to a dummy account registered on Testnet.
# It was generated using the setup_system.py script, and servers as an example.
# Alternatively, you can go to https://app.lighter.xyz/apikeys for mainnet api keys
BASE_URL = "https://testnet.zklighter.elliot.ai"
API_KEY_PRIVATE_KEY = "0xed636277f3753b6c0275f7a28c2678a7f3a95655e09deaebec15179b50c5da7f903152e50f594f7b"
ACCOUNT_INDEX = 65
API_KEY_INDEX = 1


def trim_exception(e: Exception) -> str:
    return str(e).strip().split("\n")[-1]


async def main():
    api_client = lighter.ApiClient(configuration=lighter.Configuration(host=BASE_URL))

    client = lighter.SignerClient(
        url=BASE_URL,
        private_key=API_KEY_PRIVATE_KEY,
        account_index=ACCOUNT_INDEX,
        api_key_index=API_KEY_INDEX,
    )

    err = client.check_client()
    if err is not None:
        print(f"CheckClient error: {trim_exception(err)}")
        return

    # create order
    tx, tx_hash, err = await client.create_order(
        market_index=0,
        client_order_index=123,
        base_amount=100000,
        price=405000,
        is_ask=True,
        order_type=lighter.SignerClient.ORDER_TYPE_LIMIT,
        time_in_force=lighter.SignerClient.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
        reduce_only=0,
        trigger_price=0,
    )
    print(f"Create Order {tx=} {tx_hash=} {err=}")
    if err is not None:
        raise Exception(err)

    auth, err = client.create_auth_token_with_expiry(lighter.SignerClient.DEFAULT_10_MIN_AUTH_EXPIRY)
    print(f"{auth=}")
    if err is not None:
        raise Exception(err)

    # cancel order
    tx, tx_hash, err = await client.cancel_order(
        market_index=0,
        order_index=123,
    )
    print(f"Cancel Order {tx=} {tx_hash=} {err=}")
    if err is not None:
        raise Exception(err)

    await client.close()
    await api_client.close()


if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: .\examples\create_market_order.py
================================================================================

import asyncio
import logging
import lighter

logging.basicConfig(level=logging.DEBUG)

# The API_KEY_PRIVATE_KEY provided belongs to a dummy account registered on Testnet.
# It was generated using the setup_system.py script, and serves as an example.
BASE_URL = "https://testnet.zklighter.elliot.ai"
API_KEY_PRIVATE_KEY = "0xed636277f3753b6c0275f7a28c2678a7f3a95655e09deaebec15179b50c5da7f903152e50f594f7b"
ACCOUNT_INDEX = 65
API_KEY_INDEX = 3


def trim_exception(e: Exception) -> str:
    return str(e).strip().split("\n")[-1]


async def main():
    client = lighter.SignerClient(
        url=BASE_URL,
        private_key=API_KEY_PRIVATE_KEY,
        account_index=ACCOUNT_INDEX,
        api_key_index=API_KEY_INDEX,
    )

    tx = await client.create_market_order(
        market_index=0,
        client_order_index=0,
        base_amount=1000,  # 0.1 ETH
        avg_execution_price=170000,  # $1700 -- worst acceptable price for the order
        is_ask=True,
    )
    print("Create Order Tx:", tx)
    await client.close()


if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: .\examples\create_market_order_max_slippage.py
================================================================================

import asyncio
import logging
import lighter

logging.basicConfig(level=logging.DEBUG)

# The API_KEY_PRIVATE_KEY provided belongs to a dummy account registered on Testnet.
# It was generated using the setup_system.py script, and serves as an example.
BASE_URL = "https://testnet.zklighter.elliot.ai"
API_KEY_PRIVATE_KEY = "0xe0fa55e11d6b5575d54c0500bd2f3b240221ae90241e3b573f2307e27de20c04ea628de3f1936e56"
ACCOUNT_INDEX = 22
API_KEY_INDEX = 3


def trim_exception(e: Exception) -> str:
    return str(e).strip().split("\n")[-1]


async def main():
    client = lighter.SignerClient(
        url=BASE_URL,
        private_key=API_KEY_PRIVATE_KEY,
        account_index=ACCOUNT_INDEX,
        api_key_index=API_KEY_INDEX,
    )

    # tx = await client.create_market_order_limited_slippage(market_index=0, client_order_index=0, base_amount=30000000,
    #                                                        max_slippage=0.001, is_ask=True)
    tx = await client.create_market_order_if_slippage(market_index=0, client_order_index=0, base_amount=30000000,
                                                           max_slippage=0.01, is_ask=True, ideal_price=300000)
    print("Create Order Tx:", tx)
    await client.close()


if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: .\examples\create_sl_tp.py
================================================================================

import asyncio
import logging
import lighter

logging.basicConfig(level=logging.DEBUG)

# The API_KEY_PRIVATE_KEY provided belongs to a dummy account registered on Testnet.
# It was generated using the setup_system.py script, and servers as an example.
BASE_URL = "https://testnet.zklighter.elliot.ai"
API_KEY_PRIVATE_KEY = "0xe0fa55e11d6b5575d54c0500bd2f3b240221ae90241e3b573f2307e27de20c04ea628de3f1936e56"
ACCOUNT_INDEX = 22
API_KEY_INDEX = 3


def trim_exception(e: Exception) -> str:
    return str(e).strip().split("\n")[-1]


async def main():
    client = lighter.SignerClient(
        url=BASE_URL,
        private_key=API_KEY_PRIVATE_KEY,
        account_index=ACCOUNT_INDEX,
        api_key_index=API_KEY_INDEX,
    )

    tx = await client.create_tp_order(
        market_index=0,
        client_order_index=0,
        base_amount=1000,  # 0.1 ETH
        trigger_price=500000,
        price=500000,
        is_ask=False
    )
    print("Create Order Tx:", tx)


    tx = await client.create_sl_order(
        market_index=0,
        client_order_index=0,
        base_amount=1000,  # 0.1 ETH
        trigger_price=500000,
        price=500000,
        is_ask=False
    )
    print("Create Order Tx:", tx)

    tx = await client.create_tp_limit_order(
        market_index=0,
        client_order_index=0,
        base_amount=1000,  # 0.1 ETH
        trigger_price=500000,
        price=500000,
        is_ask=False
    )

    tx = await client.create_sl_limit_order(
        market_index=0,
        client_order_index=0,
        base_amount=1000,  # 0.1 ETH
        trigger_price=500000,
        price=500000,
        is_ask=False
    )
    print("Create Order Tx:", tx)
    await client.close()


if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: .\examples\create_with_multiple_keys.py
================================================================================

import asyncio
import lighter


BASE_URL = "https://testnet.zklighter.elliot.ai"
# use examples/system_setup.py or the apikeys page (for mainnet) to generate new api keys
KEYS = {
    5: "API_PRIVATE_KEY_5",
    6: "API_PRIVATE_KEY_6",
    7: "API_PRIVATE_KEY_7",
}
ACCOUNT_INDEX = 100  # replace with your account_index


async def main():
    client = lighter.SignerClient(
        url=BASE_URL,
        private_key=KEYS[5],
        account_index=ACCOUNT_INDEX,
        api_key_index=5,
        max_api_key_index=7,
        private_keys=KEYS,
    )

    err = client.check_client()
    if err is not None:
        print(f"CheckClient error: {err}")
        return

    for i in range(20):
        res_tuple = await client.create_order(
            market_index=0,
            client_order_index=123 + i,
            base_amount=100000 + i,
            price=385000 + i,
            is_ask=True,
            order_type=lighter.SignerClient.ORDER_TYPE_LIMIT,
            time_in_force=lighter.SignerClient.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
            reduce_only=0,
            trigger_price=0,
        )
        print(res_tuple)

    await client.cancel_all_orders(time_in_force=client.CANCEL_ALL_TIF_IMMEDIATE, time=0)


if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: .\examples\get_info.py
================================================================================

import asyncio
import datetime
import lighter
import logging

logging.basicConfig(level=logging.INFO)


# The address provided belongs to a dummy account registered on Testnet.
L1_ADDRESS = "0x8D7f03FdE1A626223364E592740a233b72395235"
ACCOUNT_INDEX = 65


async def print_api(method, *args, **kwargs):
    logging.info(f"{method.__name__}: {await method(*args, **kwargs)}")


async def account_apis(client: lighter.ApiClient):
    logging.info("ACCOUNT APIS")
    account_instance = lighter.AccountApi(client)
    await print_api(account_instance.account, by="l1_address", value=L1_ADDRESS)
    await print_api(account_instance.account, by="index", value=str(ACCOUNT_INDEX))
    await print_api(account_instance.accounts_by_l1_address, l1_address=L1_ADDRESS)
    await print_api(account_instance.apikeys, account_index=ACCOUNT_INDEX, api_key_index=1)
    await print_api(account_instance.public_pools, filter="all", limit=1, index=0)


async def block_apis(client: lighter.ApiClient):
    logging.info("BLOCK APIS")
    block_instance = lighter.BlockApi(client)
    await print_api(block_instance.block, by="height", value="1")
    await print_api(block_instance.blocks, index=0, limit=2, sort="asc")
    await print_api(block_instance.current_height)


async def candlestick_apis(client: lighter.ApiClient):
    logging.info("CANDLESTICK APIS")
    candlestick_instance = lighter.CandlestickApi(client)
    await print_api(
        candlestick_instance.candlesticks,
        market_id=0,
        resolution="1h",
        start_timestamp=int(datetime.datetime.now().timestamp() - 60 * 60 * 24),
        end_timestamp=int(datetime.datetime.now().timestamp()),
        count_back=2,
    )
    await print_api(
        candlestick_instance.fundings,
        market_id=0,
        resolution="1h",
        start_timestamp=int(datetime.datetime.now().timestamp() - 60 * 60 * 24),
        end_timestamp=int(datetime.datetime.now().timestamp()),
        count_back=2,
    )


async def order_apis(client: lighter.ApiClient):
    logging.info("ORDER APIS")
    order_instance = lighter.OrderApi(client)
    await print_api(order_instance.exchange_stats)
    await print_api(order_instance.order_book_details, market_id=0)
    await print_api(order_instance.order_books)
    await print_api(order_instance.recent_trades, market_id=0, limit=2)


async def transaction_apis(client: lighter.ApiClient):
    logging.info("TRANSACTION APIS")
    transaction_instance = lighter.TransactionApi(client)
    await print_api(transaction_instance.block_txs, by="block_height", value="1")
    await print_api(
        transaction_instance.next_nonce,
        account_index=int(ACCOUNT_INDEX),
        api_key_index=0,
    )
    # use with a valid sequence index
    # await print_api(transaction_instance.tx, by="sequence_index", value="5")
    await print_api(transaction_instance.txs, index=0, limit=2)


async def main():
    client = lighter.ApiClient(configuration=lighter.Configuration(host="https://testnet.zklighter.elliot.ai"))
    await account_apis(client)
    await block_apis(client)
    await candlestick_apis(client)
    await order_apis(client)
    await transaction_apis(client)
    await client.close()


if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: .\examples\README.md
================================================================================

## Setup steps for testnet
- Go to https://testnet.app.lighter.xyz/ and connect a wallet to receive $500
- run `system_setup.py` with the correct ETH Private key configured
  - set an API key index which is not 0, so you won't override the one used by [app.lighter.xyz](https://app.lighter.xyz/)
  - this will require you to enter your Ethereum private key
  - the eth private key will only be used in the Py SDK to sign a message
  - the eth private key is not required in order to trade on the platform
  - the eth private key is not passed to the binary
  - copy the output of the script and post it into `create_cancel_order.py`
  - the output should look like
```
BASE_URL = 'https://testnet.zklighter.elliot.ai'
API_KEY_PRIVATE_KEY = '0xea5d2eca5be67eca056752eaf27b173518b8a5550117c09d2b58c7ea7d306cc4426f913ccf27ab19'
ACCOUNT_INDEX = 595
API_KEY_INDEX = 1
```
- start trading using
  - `create_cancel_order.py` has an example which created an order on testnet & cancels it
  - you'll need to set up both your account index, api key index & API Key private key

## Setup steps for mainnet
- deposit money on Lighter to create an account first
- change the URL to `mainnet.zklighter.elliot.ai`
- repeat setup step


================================================================================
File: .\examples\send_tx_batch.py
================================================================================

import asyncio
import logging
import lighter
import json

logging.basicConfig(level=logging.DEBUG)

# The API_KEY_PRIVATE_KEY provided belongs to a dummy account registered on Testnet.
# It was generated using the setup_system.py script, and servers as an example.
BASE_URL = "https://testnet.zklighter.elliot.ai"
API_KEY_PRIVATE_KEY = "0xed636277f3753b6c0275f7a28c2678a7f3a95655e09deaebec15179b50c5da7f903152e50f594f7b"
ACCOUNT_INDEX = 65
API_KEY_INDEX = 1

def trim_exception(e: Exception) -> str:
    return str(e).strip().split("\n")[-1]


async def main():
    # Initialize configuration and clients
    configuration = lighter.Configuration(BASE_URL)
    api_client = lighter.ApiClient(configuration)
    transaction_api = lighter.TransactionApi(api_client)

    # Initialize signer client
    client = lighter.SignerClient(
        url=BASE_URL,
        private_key=API_KEY_PRIVATE_KEY,
        account_index=ACCOUNT_INDEX,
        api_key_index=API_KEY_INDEX
    )

    # Check client connection
    err = client.check_client()
    if err is not None:
        print(f"CheckClient error: {trim_exception(err)}")
        return

    # use next nonce for getting nonces
    next_nonce = await transaction_api.next_nonce(account_index=ACCOUNT_INDEX, api_key_index=API_KEY_INDEX)
    nonce_value = next_nonce.nonce

    ask_tx_info, error = client.sign_create_order(
        market_index=0,
        client_order_index=1001,  # Unique identifier for this order
        base_amount=100000,
        price=280000,
        is_ask=True,
        order_type=client.ORDER_TYPE_LIMIT,
        time_in_force=client.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
        reduce_only=False,
        trigger_price=0,
        nonce=nonce_value
    )
    nonce_value += 1

    if error is not None:
        print(f"Error signing first order (first batch): {trim_exception(error)}")
        return

    # Sign second order
    bid_tx_info, error = client.sign_create_order(
        market_index=0,
        client_order_index=1002,  # Different unique identifier
        base_amount=200000,
        price=200000,
        is_ask=False,
        order_type=client.ORDER_TYPE_LIMIT,
        time_in_force=client.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
        reduce_only=False,
        trigger_price=0,
        nonce=nonce_value
    )
    nonce_value += 1

    if error is not None:
        print(f"Error signing second order (first batch): {trim_exception(error)}")
        return

    tx_types = json.dumps([client.TX_TYPE_CREATE_ORDER, client.TX_TYPE_CREATE_ORDER])
    tx_infos = json.dumps([ask_tx_info, bid_tx_info])

    try:
        tx_hashes = await transaction_api.send_tx_batch(tx_types=tx_types, tx_infos=tx_infos)
        print(f"Batch transaction successful: {tx_hashes}")
    except Exception as e:
        print(f"Error sending batch transaction: {trim_exception(e)}")

    # In case we want to see the changes in the UI, sleep a bit
    import time
    time.sleep(5)

    cancel_tx_info, error = client.sign_cancel_order(
        market_index=0,
        order_index=1001, # the index of the order we want cancelled
        nonce=nonce_value
    )
    nonce_value += 1

    if error is not None:
        print(f"Error signing first order (second batch): {trim_exception(error)}")
        return

    # Sign second order
    new_ask_tx_info, error = client.sign_create_order(
        market_index=0,
        client_order_index=1003,  # Different unique identifier
        base_amount=300000,
        price=310000,
        is_ask=True,
        order_type=client.ORDER_TYPE_LIMIT,
        time_in_force=client.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
        reduce_only=False,
        trigger_price=0,
        nonce=nonce_value
    )
    nonce_value += 1

    if error is not None:
        print(f"Error signing second order (second batch): {trim_exception(error)}")
        return

    tx_types = json.dumps([client.TX_TYPE_CANCEL_ORDER, client.TX_TYPE_CREATE_ORDER])
    tx_infos = json.dumps([cancel_tx_info, new_ask_tx_info])

    try:
        tx_hashes = await transaction_api.send_tx_batch(tx_types=tx_types, tx_infos=tx_infos)
        print(f"Batch 2 transaction successful: {tx_hashes}")
    except Exception as e:
        print(f"Error sending batch transaction 2: {trim_exception(e)}")

    # Clean up
    await client.close()
    await api_client.close()

# Run the async main function
if __name__ == "__main__":
    asyncio.run(main())


================================================================================
File: .\examples\system_setup.py
================================================================================

import asyncio
import logging
import time
import eth_account
import lighter

logging.basicConfig(level=logging.DEBUG)

# this is a dummy private key which is registered on Testnet.
# It serves as a good example
BASE_URL = "https://testnet.zklighter.elliot.ai"
ETH_PRIVATE_KEY = "1234567812345678123456781234567812345678123456781234567812345678"
API_KEY_INDEX = 3


async def main():
    # verify that the account exists & fetch account index
    api_client = lighter.ApiClient(configuration=lighter.Configuration(host=BASE_URL))
    eth_acc = eth_account.Account.from_key(ETH_PRIVATE_KEY)
    eth_address = eth_acc.address

    try:
        response = await lighter.AccountApi(api_client).accounts_by_l1_address(
            l1_address=eth_address
        )
    except lighter.ApiException as e:
        if e.data.message == "account not found":
            print(f"error: account not found for {eth_address}")
            return
        else:
            raise e

    if len(response.sub_accounts) > 1:
        for sub_account in response.sub_accounts:
            print(f"found accountIndex: {sub_account.index}")

        print("multiple accounts found, using the first one")
        account_index = response.sub_accounts[0].index
    else:
        account_index = response.sub_accounts[0].index

    # create a private/public key pair for the new API key
    # pass any string to be used as seed for create_api_key like
    # create_api_key("Hello world random seed to make things more secure")
    private_key, public_key, err = lighter.create_api_key()
    if err is not None:
        raise Exception(err)

    tx_client = lighter.SignerClient(
        url=BASE_URL,
        private_key=private_key,
        account_index=account_index,
        api_key_index=API_KEY_INDEX,
    )

    # change the API key
    response, err = await tx_client.change_api_key(
        eth_private_key=ETH_PRIVATE_KEY,
        new_pubkey=public_key,
    )
    if err is not None:
        raise Exception(err)

    # wait some time so that we receive the new API key in the response
    time.sleep(10)

    # check that the API key changed on the server
    err = tx_client.check_client()
    if err is not None:
        raise Exception(err)

    print(
        f"""
BASE_URL = '{BASE_URL}'
API_KEY_PRIVATE_KEY = '{private_key}'
ACCOUNT_INDEX = {account_index}
API_KEY_INDEX = {API_KEY_INDEX}
    """
    )

    await tx_client.close()
    await api_client.close()


if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: .\examples\transfer_update_leverage.py
================================================================================

import asyncio
import lighter


from examples.secrets import BASE_URL, API_KEY_PRIVATE_KEY, ETH_PRIVATE_KEY

API_KEY_INDEX = 10
TO_ACCOUNT_INDEX = 9
ACCOUNT_INDEX = 10  # replace with your account_index


async def main():
    client = lighter.SignerClient(
        url=BASE_URL,
        private_key=API_KEY_PRIVATE_KEY,
        account_index=ACCOUNT_INDEX,
        api_key_index=API_KEY_INDEX,
    )
    api_client = lighter.ApiClient(configuration=lighter.Configuration(host=BASE_URL))
    info_api = lighter.InfoApi(api_client)
    order_api = lighter.OrderApi(api_client)

    auth_token, _ = client.create_auth_token_with_expiry()
    fee_info = await info_api.transfer_fee_info(ACCOUNT_INDEX, authorization=auth_token, auth=auth_token, to_account_index=TO_ACCOUNT_INDEX) 
    print(fee_info)

    err = client.check_client()
    if err is not None:
        print(f"CheckClient error: {err}")
        return
    memo = "a"*32  # memo is a user message and it has to be exactly 32 bytes long
    transfer_tx, response, err = await client.transfer(
        ETH_PRIVATE_KEY,
        usdc_amount=100,  # decimals are added by sdk
        to_account_index=TO_ACCOUNT_INDEX,
        fee=fee_info.transfer_fee_usdc,
        memo=memo,
    )
    if err != None:
       raise Exception(f"error transferring {err}")
    print(transfer_tx, response)

    lev_tx, response, err = await client.update_leverage(4, client.CROSS_MARGIN_MODE, 3)
    print(lev_tx, response, err)

if __name__ == "__main__":
    asyncio.run(main())


================================================================================
File: .\examples\ws.py
================================================================================

import json
import logging
import lighter

logging.basicConfig(level=logging.INFO)


def on_order_book_update(market_id, order_book):
    logging.info(f"Order book {market_id}:\n{json.dumps(order_book, indent=2)}")


def on_account_update(account_id, account):
    logging.info(f"Account {account_id}:\n{json.dumps(account, indent=2)}")


client = lighter.WsClient(
    order_book_ids=[0, 1],
    account_ids=[1, 2],
    on_order_book_update=on_order_book_update,
    on_account_update=on_account_update,
)

client.run()



================================================================================
File: .\examples\ws_async.py
================================================================================

import json
import logging
import asyncio
import lighter

logging.basicConfig(level=logging.INFO)


def on_order_book_update(market_id, order_book):
    logging.info(f"Order book {market_id}:\n{json.dumps(order_book, indent=2)}")


def on_account_update(account_id, account):
    logging.info(f"Account {account_id}:\n{json.dumps(account, indent=2)}")


client = lighter.WsClient(
    order_book_ids=[0, 1],
    account_ids=[1, 2],
    on_order_book_update=on_order_book_update,
    on_account_update=on_account_update,
)

asyncio.run(client.run_async())



================================================================================
File: .\examples\ws_send_batch_tx.py
================================================================================

import lighter
import json
import websockets
import asyncio

# The API_KEY_PRIVATE_KEY provided belongs to a dummy account registered on Testnet.
# It was generated using the setup_system.py script, and servers as an example.
# Alternatively, you can go to https://app.lighter.xyz/apikeys for mainnet api keys
BASE_URL = "https://testnet.zklighter.elliot.ai"
API_KEY_PRIVATE_KEY = (
    "0xed636277f3753b6c0275f7a28c2678a7f3a95655e09deaebec15179b50c5da7f903152e50f594f7b"
)
ACCOUNT_INDEX = 65
API_KEY_INDEX = 1


async def ws_flow(tx_types, tx_infos):
    async with websockets.connect(f"{BASE_URL.replace('https', 'wss')}/stream") as ws:
        msg = await ws.recv()
        print("Received:", msg)

        await ws.send(
            json.dumps(
                {
                    "type": "jsonapi/sendtxbatch",
                    "data": {
                        "id": f"my_random_batch_id_{12345678}", # optional, helps id the response
                        "tx_types": json.dumps(tx_types),
                        "tx_infos": json.dumps(tx_infos),
                    },
                }
            )
        )

        print("Response:", await ws.recv())


async def main():
    client = lighter.SignerClient(
        url=BASE_URL,
        private_key=API_KEY_PRIVATE_KEY,
        account_index=ACCOUNT_INDEX,
        api_key_index=API_KEY_INDEX,
    )
    configuration = lighter.Configuration(BASE_URL)
    api_client = lighter.ApiClient(configuration)
    transaction_api = lighter.TransactionApi(api_client)

    # use next nonce for getting nonces
    next_nonce = await transaction_api.next_nonce(
        account_index=ACCOUNT_INDEX, api_key_index=API_KEY_INDEX
    )
    nonce_value = next_nonce.nonce

    ask_tx_info, error = client.sign_create_order(
        market_index=0,
        client_order_index=1001,  # Unique identifier for this order
        base_amount=100000,
        price=280000,
        is_ask=True,
        order_type=client.ORDER_TYPE_LIMIT,
        time_in_force=client.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
        reduce_only=False,
        trigger_price=0,
        nonce=nonce_value,
    )
    nonce_value += 1

    if error is not None:
        print(f"Error signing first order (first batch): {error}")
        return

    # Sign second order
    bid_tx_info, error = client.sign_create_order(
        market_index=0,
        client_order_index=1002,  # Different unique identifier
        base_amount=200000,
        price=200000,
        is_ask=False,
        order_type=client.ORDER_TYPE_LIMIT,
        time_in_force=client.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
        reduce_only=False,
        trigger_price=0,
        nonce=nonce_value,
    )

    if error is not None:
        print(f"Error signing second order (first batch): {error}")
        return

    tx_types = [
        lighter.SignerClient.TX_TYPE_CREATE_ORDER,
        lighter.SignerClient.TX_TYPE_CREATE_ORDER,
    ]
    tx_infos = [ask_tx_info, bid_tx_info]

    await ws_flow(tx_types, tx_infos)


if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: .\examples\ws_send_tx.py
================================================================================

import lighter
import json
import websockets
import asyncio

# The API_KEY_PRIVATE_KEY provided belongs to a dummy account registered on Testnet.
# It was generated using the setup_system.py script, and servers as an example.
# Alternatively, you can go to https://app.lighter.xyz/apikeys for mainnet api keys
BASE_URL = "https://testnet.zklighter.elliot.ai"
API_KEY_PRIVATE_KEY = (
    "0xed636277f3753b6c0275f7a28c2678a7f3a95655e09deaebec15179b50c5da7f903152e50f594f7b"
)
ACCOUNT_INDEX = 65
API_KEY_INDEX = 3


async def ws_flow(tx_type, tx_info):
    async with websockets.connect(f"{BASE_URL.replace('https', 'wss')}/stream") as ws:
        msg = await ws.recv()
        print("Received:", msg)

        await ws.send(
            json.dumps(
                {
                    "type": "jsonapi/sendtx",
                    "data": {
                        "id": f"my_random_id_{12345678}", # optional, helps id the response
                        "tx_type": tx_type,
                        "tx_info": json.loads(tx_info),
                    },
                }
            )
        )

        print("Response:", await ws.recv())


async def main():
    client = lighter.SignerClient(
        url=BASE_URL,
        private_key=API_KEY_PRIVATE_KEY,
        account_index=ACCOUNT_INDEX,
        api_key_index=API_KEY_INDEX,
    )
    configuration = lighter.Configuration(BASE_URL)
    api_client = lighter.ApiClient(configuration)
    transaction_api = lighter.TransactionApi(api_client)

    next_nonce = await transaction_api.next_nonce(
        account_index=ACCOUNT_INDEX, api_key_index=API_KEY_INDEX
    )
    nonce_value = next_nonce.nonce

    tx_info, error = client.sign_create_order(
        market_index=0,
        client_order_index=1002,  # Different unique identifier
        base_amount=200000,
        price=200000,
        is_ask=False,
        order_type=client.ORDER_TYPE_LIMIT,
        time_in_force=client.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
        reduce_only=False,
        trigger_price=0,
        nonce=nonce_value,
    )
    if error is not None:
        print(f"Error signing order: {error}")
        return

    await ws_flow(lighter.SignerClient.TX_TYPE_CREATE_ORDER, tx_info)


if __name__ == "__main__":
    asyncio.run(main())



================================================================================
File: .\lighter\api_client.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import datetime
from dateutil.parser import parse
from enum import Enum
import json
import mimetypes
import os
import re
import tempfile

from urllib.parse import quote
from typing import Tuple, Optional, List, Dict, Union
from pydantic import SecretStr

from lighter.configuration import Configuration
from lighter.api_response import ApiResponse, T as ApiResponseT
import lighter.models
from lighter import rest
from lighter.exceptions import (
    ApiValueError,
    ApiException,
    BadRequestException,
    UnauthorizedException,
    ForbiddenException,
    NotFoundException,
    ServiceException
)

RequestSerialized = Tuple[str, str, Dict[str, str], Optional[str], List[str]]

class ApiClient:
    """Generic API client for OpenAPI client library builds.

    OpenAPI generic API client. This client handles the client-
    server communication, and is invariant across implementations. Specifics of
    the methods and models for each application are generated from the OpenAPI
    templates.

    :param configuration: .Configuration object for this client
    :param header_name: a header to pass when making calls to the API.
    :param header_value: a header value to pass when making calls to
        the API.
    :param cookie: a cookie to include in the header when making calls
        to the API
    """

    PRIMITIVE_TYPES = (float, bool, bytes, str, int)
    NATIVE_TYPES_MAPPING = {
        'int': int,
        'long': int, # TODO remove as only py3 is supported?
        'float': float,
        'str': str,
        'bool': bool,
        'date': datetime.date,
        'datetime': datetime.datetime,
        'object': object,
    }
    _pool = None

    def __init__(
        self,
        configuration=None,
        header_name=None,
        header_value=None,
        cookie=None
    ) -> None:
        # use default configuration if none is provided
        if configuration is None:
            configuration = Configuration.get_default()
        self.configuration = configuration

        self.rest_client = rest.RESTClientObject(configuration)
        self.default_headers = {}
        if header_name is not None:
            self.default_headers[header_name] = header_value
        self.cookie = cookie
        # Set default User-Agent.
        self.user_agent = 'OpenAPI-Generator/1.0.0/python'
        self.client_side_validation = configuration.client_side_validation

    async def __aenter__(self):
        return self

    async def __aexit__(self, exc_type, exc_value, traceback):
        await self.close()

    async def close(self):
        await self.rest_client.close()

    @property
    def user_agent(self):
        """User agent for this API client"""
        return self.default_headers['User-Agent']

    @user_agent.setter
    def user_agent(self, value):
        self.default_headers['User-Agent'] = value

    def set_default_header(self, header_name, header_value):
        self.default_headers[header_name] = header_value


    _default = None

    @classmethod
    def get_default(cls):
        """Return new instance of ApiClient.

        This method returns newly created, based on default constructor,
        object of ApiClient class or returns a copy of default
        ApiClient.

        :return: The ApiClient object.
        """
        if cls._default is None:
            cls._default = ApiClient()
        return cls._default

    @classmethod
    def set_default(cls, default):
        """Set default instance of ApiClient.

        It stores default ApiClient.

        :param default: object of ApiClient.
        """
        cls._default = default

    def param_serialize(
        self,
        method,
        resource_path,
        path_params=None,
        query_params=None,
        header_params=None,
        body=None,
        post_params=None,
        files=None, auth_settings=None,
        collection_formats=None,
        _host=None,
        _request_auth=None
    ) -> RequestSerialized:

        """Builds the HTTP request params needed by the request.
        :param method: Method to call.
        :param resource_path: Path to method endpoint.
        :param path_params: Path parameters in the url.
        :param query_params: Query parameters in the url.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for `application/x-www-form-urlencoded`, `multipart/form-data`.
        :param auth_settings list: Auth Settings names for the request.
        :param files dict: key -> filename, value -> filepath,
            for `multipart/form-data`.
        :param collection_formats: dict of collection formats for path, query,
            header, and post parameters.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :return: tuple of form (path, http_method, query_params, header_params,
            body, post_params, files)
        """

        config = self.configuration

        # header parameters
        header_params = header_params or {}
        header_params.update(self.default_headers)
        if self.cookie:
            header_params['Cookie'] = self.cookie
        if header_params:
            header_params = self.sanitize_for_serialization(header_params)
            header_params = dict(
                self.parameters_to_tuples(header_params,collection_formats)
            )

        # path parameters
        if path_params:
            path_params = self.sanitize_for_serialization(path_params)
            path_params = self.parameters_to_tuples(
                path_params,
                collection_formats
            )
            for k, v in path_params:
                # specified safe chars, encode everything
                resource_path = resource_path.replace(
                    '{%s}' % k,
                    quote(str(v), safe=config.safe_chars_for_path_param)
                )

        # post parameters
        if post_params or files:
            post_params = post_params if post_params else []
            post_params = self.sanitize_for_serialization(post_params)
            post_params = self.parameters_to_tuples(
                post_params,
                collection_formats
            )
            if files:
                post_params.extend(self.files_parameters(files))

        # auth setting
        self.update_params_for_auth(
            header_params,
            query_params,
            auth_settings,
            resource_path,
            method,
            body,
            request_auth=_request_auth
        )

        # body
        if body:
            body = self.sanitize_for_serialization(body)

        # request url
        if _host is None or self.configuration.ignore_operation_servers:
            url = self.configuration.host + resource_path
        else:
            # use server/host defined in path or operation instead
            url = _host + resource_path

        # query parameters
        if query_params:
            query_params = self.sanitize_for_serialization(query_params)
            url_query = self.parameters_to_url_query(
                query_params,
                collection_formats
            )
            url += "?" + url_query

        return method, url, header_params, body, post_params


    async def call_api(
        self,
        method,
        url,
        header_params=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ) -> rest.RESTResponse:
        """Makes the HTTP request (synchronous)
        :param method: Method to call.
        :param url: Path to method endpoint.
        :param header_params: Header parameters to be
            placed in the request header.
        :param body: Request body.
        :param post_params dict: Request post form parameters,
            for `application/x-www-form-urlencoded`, `multipart/form-data`.
        :param _request_timeout: timeout setting for this request.
        :return: RESTResponse
        """

        try:
            # perform request and return response
            response_data = await self.rest_client.request(
                method, url,
                headers=header_params,
                body=body, post_params=post_params,
                _request_timeout=_request_timeout
            )

        except ApiException as e:
            raise e

        return response_data

    def response_deserialize(
        self,
        response_data: rest.RESTResponse,
        response_types_map: Optional[Dict[str, ApiResponseT]]=None
    ) -> ApiResponse[ApiResponseT]:
        """Deserializes response into an object.
        :param response_data: RESTResponse object to be deserialized.
        :param response_types_map: dict of response types.
        :return: ApiResponse
        """

        msg = "RESTResponse.read() must be called before passing it to response_deserialize()"
        assert response_data.data is not None, msg

        response_type = response_types_map.get(str(response_data.status), None)
        if not response_type and isinstance(response_data.status, int) and 100 <= response_data.status <= 599:
            # if not found, look for '1XX', '2XX', etc.
            response_type = response_types_map.get(str(response_data.status)[0] + "XX", None)

        # deserialize response data
        response_text = None
        return_data = None
        try:
            if response_type == "bytearray":
                return_data = response_data.data
            elif response_type == "file":
                return_data = self.__deserialize_file(response_data)
            elif response_type is not None:
                match = None
                content_type = response_data.getheader('content-type')
                if content_type is not None:
                    match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
                encoding = match.group(1) if match else "utf-8"
                response_text = response_data.data.decode(encoding)
                return_data = self.deserialize(response_text, response_type, content_type)
        finally:
            if not 200 <= response_data.status <= 299:
                raise ApiException.from_response(
                    http_resp=response_data,
                    body=response_text,
                    data=return_data,
                )

        return ApiResponse(
            status_code = response_data.status,
            data = return_data,
            headers = response_data.getheaders(),
            raw_data = response_data.data
        )

    def sanitize_for_serialization(self, obj):
        """Builds a JSON POST object.

        If obj is None, return None.
        If obj is SecretStr, return obj.get_secret_value()
        If obj is str, int, long, float, bool, return directly.
        If obj is datetime.datetime, datetime.date
            convert to string in iso8601 format.
        If obj is list, sanitize each element in the list.
        If obj is dict, return the dict.
        If obj is OpenAPI model, return the properties dict.

        :param obj: The data to serialize.
        :return: The serialized form of data.
        """
        if obj is None:
            return None
        elif isinstance(obj, Enum):
            return obj.value
        elif isinstance(obj, SecretStr):
            return obj.get_secret_value()
        elif isinstance(obj, self.PRIMITIVE_TYPES):
            return obj
        elif isinstance(obj, list):
            return [
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            ]
        elif isinstance(obj, tuple):
            return tuple(
                self.sanitize_for_serialization(sub_obj) for sub_obj in obj
            )
        elif isinstance(obj, (datetime.datetime, datetime.date)):
            return obj.isoformat()

        elif isinstance(obj, dict):
            obj_dict = obj
        else:
            # Convert model obj to dict except
            # attributes `openapi_types`, `attribute_map`
            # and attributes which value is not None.
            # Convert attribute name to json key in
            # model definition for request.
            if hasattr(obj, 'to_dict') and callable(getattr(obj, 'to_dict')):
                obj_dict = obj.to_dict()
            else:
                obj_dict = obj.__dict__

        return {
            key: self.sanitize_for_serialization(val)
            for key, val in obj_dict.items()
        }

    def deserialize(self, response_text: str, response_type: str, content_type: Optional[str]):
        """Deserializes response into an object.

        :param response: RESTResponse object to be deserialized.
        :param response_type: class literal for
            deserialized object, or string of class name.
        :param content_type: content type of response.

        :return: deserialized object.
        """

        # fetch data from response object
        if content_type is None:
            try:
                data = json.loads(response_text)
            except ValueError:
                data = response_text
        elif content_type.startswith("application/json"):
            if response_text == "":
                data = ""
            else:
                data = json.loads(response_text)
        elif content_type.startswith("text/plain"):
            data = response_text
        else:
            raise ApiException(
                status=0,
                reason="Unsupported content type: {0}".format(content_type)
            )

        return self.__deserialize(data, response_type)

    def __deserialize(self, data, klass):
        """Deserializes dict, list, str into an object.

        :param data: dict, list or str.
        :param klass: class literal, or string of class name.

        :return: object.
        """
        if data is None:
            return None

        if isinstance(klass, str):
            if klass.startswith('List['):
                m = re.match(r'List\[(.*)]', klass)
                assert m is not None, "Malformed List type definition"
                sub_kls = m.group(1)
                return [self.__deserialize(sub_data, sub_kls)
                        for sub_data in data]

            if klass.startswith('Dict['):
                m = re.match(r'Dict\[([^,]*), (.*)]', klass)
                assert m is not None, "Malformed Dict type definition"
                sub_kls = m.group(2)
                return {k: self.__deserialize(v, sub_kls)
                        for k, v in data.items()}

            # convert str to class
            if klass in self.NATIVE_TYPES_MAPPING:
                klass = self.NATIVE_TYPES_MAPPING[klass]
            else:
                klass = getattr(lighter.models, klass)

        if klass in self.PRIMITIVE_TYPES:
            return self.__deserialize_primitive(data, klass)
        elif klass == object:
            return self.__deserialize_object(data)
        elif klass == datetime.date:
            return self.__deserialize_date(data)
        elif klass == datetime.datetime:
            return self.__deserialize_datetime(data)
        elif issubclass(klass, Enum):
            return self.__deserialize_enum(data, klass)
        else:
            return self.__deserialize_model(data, klass)

    def parameters_to_tuples(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: Parameters as list of tuples, collections formatted
        """
        new_params: List[Tuple[str, str]] = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, value) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(str(value) for value in v)))
            else:
                new_params.append((k, v))
        return new_params

    def parameters_to_url_query(self, params, collection_formats):
        """Get parameters as list of tuples, formatting collections.

        :param params: Parameters as dict or list of two-tuples
        :param dict collection_formats: Parameter collection formats
        :return: URL query string (e.g. a=Hello%20World&b=123)
        """
        new_params: List[Tuple[str, str]] = []
        if collection_formats is None:
            collection_formats = {}
        for k, v in params.items() if isinstance(params, dict) else params:
            if isinstance(v, bool):
                v = str(v).lower()
            if isinstance(v, (int, float)):
                v = str(v)
            if isinstance(v, dict):
                v = json.dumps(v)

            if k in collection_formats:
                collection_format = collection_formats[k]
                if collection_format == 'multi':
                    new_params.extend((k, str(value)) for value in v)
                else:
                    if collection_format == 'ssv':
                        delimiter = ' '
                    elif collection_format == 'tsv':
                        delimiter = '\t'
                    elif collection_format == 'pipes':
                        delimiter = '|'
                    else:  # csv is the default
                        delimiter = ','
                    new_params.append(
                        (k, delimiter.join(quote(str(value)) for value in v))
                    )
            else:
                new_params.append((k, quote(str(v))))

        return "&".join(["=".join(map(str, item)) for item in new_params])

    def files_parameters(self, files: Dict[str, Union[str, bytes]]):
        """Builds form parameters.

        :param files: File parameters.
        :return: Form parameters with files.
        """
        params = []
        for k, v in files.items():
            if isinstance(v, str):
                with open(v, 'rb') as f:
                    filename = os.path.basename(f.name)
                    filedata = f.read()
            elif isinstance(v, bytes):
                filename = k
                filedata = v
            else:
                raise ValueError("Unsupported file value")
            mimetype = (
                mimetypes.guess_type(filename)[0]
                or 'application/octet-stream'
            )
            params.append(
                tuple([k, tuple([filename, filedata, mimetype])])
            )
        return params

    def select_header_accept(self, accepts: List[str]) -> Optional[str]:
        """Returns `Accept` based on an array of accepts provided.

        :param accepts: List of headers.
        :return: Accept (e.g. application/json).
        """
        if not accepts:
            return None

        for accept in accepts:
            if re.search('json', accept, re.IGNORECASE):
                return accept

        return accepts[0]

    def select_header_content_type(self, content_types):
        """Returns `Content-Type` based on an array of content_types provided.

        :param content_types: List of content-types.
        :return: Content-Type (e.g. application/json).
        """
        if not content_types:
            return None

        for content_type in content_types:
            if re.search('json', content_type, re.IGNORECASE):
                return content_type

        return content_types[0]

    def update_params_for_auth(
        self,
        headers,
        queries,
        auth_settings,
        resource_path,
        method,
        body,
        request_auth=None
    ) -> None:
        """Updates header and query params based on authentication setting.

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :param auth_settings: Authentication setting identifiers list.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param request_auth: if set, the provided settings will
                             override the token in the configuration.
        """
        if not auth_settings:
            return

        if request_auth:
            self._apply_auth_params(
                headers,
                queries,
                resource_path,
                method,
                body,
                request_auth
            )
        else:
            for auth in auth_settings:
                auth_setting = self.configuration.auth_settings().get(auth)
                if auth_setting:
                    self._apply_auth_params(
                        headers,
                        queries,
                        resource_path,
                        method,
                        body,
                        auth_setting
                    )

    def _apply_auth_params(
        self,
        headers,
        queries,
        resource_path,
        method,
        body,
        auth_setting
    ) -> None:
        """Updates the request parameters based on a single auth_setting

        :param headers: Header parameters dict to be updated.
        :param queries: Query parameters tuple list to be updated.
        :resource_path: A string representation of the HTTP request resource path.
        :method: A string representation of the HTTP request method.
        :body: A object representing the body of the HTTP request.
        The object type is the return value of sanitize_for_serialization().
        :param auth_setting: auth settings for the endpoint
        """
        if auth_setting['in'] == 'cookie':
            headers['Cookie'] = auth_setting['value']
        elif auth_setting['in'] == 'header':
            if auth_setting['type'] != 'http-signature':
                headers[auth_setting['key']] = auth_setting['value']
        elif auth_setting['in'] == 'query':
            queries.append((auth_setting['key'], auth_setting['value']))
        else:
            raise ApiValueError(
                'Authentication token must be in `query` or `header`'
            )

    def __deserialize_file(self, response):
        """Deserializes body to file

        Saves response body into a file in a temporary folder,
        using the filename from the `Content-Disposition` header if provided.

        handle file downloading
        save response body into a tmp file and return the instance

        :param response:  RESTResponse.
        :return: file path.
        """
        fd, path = tempfile.mkstemp(dir=self.configuration.temp_folder_path)
        os.close(fd)
        os.remove(path)

        content_disposition = response.getheader("Content-Disposition")
        if content_disposition:
            m = re.search(
                r'filename=[\'"]?([^\'"\s]+)[\'"]?',
                content_disposition
            )
            assert m is not None, "Unexpected 'content-disposition' header value"
            filename = m.group(1)
            path = os.path.join(os.path.dirname(path), filename)

        with open(path, "wb") as f:
            f.write(response.data)

        return path

    def __deserialize_primitive(self, data, klass):
        """Deserializes string to primitive type.

        :param data: str.
        :param klass: class literal.

        :return: int, long, float, str, bool.
        """
        try:
            return klass(data)
        except UnicodeEncodeError:
            return str(data)
        except TypeError:
            return data

    def __deserialize_object(self, value):
        """Return an original value.

        :return: object.
        """
        return value

    def __deserialize_date(self, string):
        """Deserializes string to date.

        :param string: str.
        :return: date.
        """
        try:
            return parse(string).date()
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason="Failed to parse `{0}` as date object".format(string)
            )

    def __deserialize_datetime(self, string):
        """Deserializes string to datetime.

        The string should be in iso8601 datetime format.

        :param string: str.
        :return: datetime.
        """
        try:
            return parse(string)
        except ImportError:
            return string
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse `{0}` as datetime object"
                    .format(string)
                )
            )

    def __deserialize_enum(self, data, klass):
        """Deserializes primitive type to enum.

        :param data: primitive type.
        :param klass: class literal.
        :return: enum value.
        """
        try:
            return klass(data)
        except ValueError:
            raise rest.ApiException(
                status=0,
                reason=(
                    "Failed to parse `{0}` as `{1}`"
                    .format(data, klass)
                )
            )

    def __deserialize_model(self, data, klass):
        """Deserializes list or dict to model.

        :param data: dict, list.
        :param klass: class literal.
        :return: model object.
        """

        return klass.from_dict(data)



================================================================================
File: .\lighter\api_response.py
================================================================================

"""API response object."""

from __future__ import annotations
from typing import Optional, Generic, Mapping, TypeVar
from pydantic import Field, StrictInt, StrictBytes, BaseModel

T = TypeVar("T")

class ApiResponse(BaseModel, Generic[T]):
    """
    API response object
    """

    status_code: StrictInt = Field(description="HTTP status code")
    headers: Optional[Mapping[str, str]] = Field(None, description="HTTP headers")
    data: T = Field(description="Deserialized data given the data type")
    raw_data: StrictBytes = Field(description="Raw data (HTTP response body)")

    model_config = {
        "arbitrary_types_allowed": True
    }



================================================================================
File: .\lighter\configuration.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import copy
import logging
from logging import FileHandler
import sys
from typing import Optional
import urllib3

import http.client as httplib

JSON_SCHEMA_VALIDATION_KEYWORDS = {
    'multipleOf', 'maximum', 'exclusiveMaximum',
    'minimum', 'exclusiveMinimum', 'maxLength',
    'minLength', 'pattern', 'maxItems', 'minItems'
}

class Configuration:
    """This class contains various settings of the API client.

    :param host: Base url.
    :param ignore_operation_servers
      Boolean to ignore operation servers for the API client.
      Config will use `host` as the base url regardless of the operation servers.
    :param api_key: Dict to store API key(s).
      Each entry in the dict specifies an API key.
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is the API key secret.
    :param api_key_prefix: Dict to store API prefix (e.g. Bearer).
      The dict key is the name of the security scheme in the OAS specification.
      The dict value is an API key prefix when generating the auth data.
    :param username: Username for HTTP basic authentication.
    :param password: Password for HTTP basic authentication.
    :param access_token: Access token.
    :param server_index: Index to servers configuration.
    :param server_variables: Mapping with string values to replace variables in
      templated server configuration. The validation of enums is performed for
      variables with defined enum values before.
    :param server_operation_index: Mapping from operation ID to an index to server
      configuration.
    :param server_operation_variables: Mapping from operation ID to a mapping with
      string values to replace variables in templated server configuration.
      The validation of enums is performed for variables with defined enum
      values before.
    :param ssl_ca_cert: str - the path to a file of concatenated CA certificates
      in PEM format.
    :param retries: Number of retries for API requests.

    :Example:

    API Key Authentication Example.
    Given the following security scheme in the OpenAPI specification:
      components:
        securitySchemes:
          cookieAuth:         # name for the security scheme
            type: apiKey
            in: cookie
            name: JSESSIONID  # cookie name

    You can programmatically set the cookie:

conf = lighter.Configuration(
    api_key={'cookieAuth': 'abc123'}
    api_key_prefix={'cookieAuth': 'JSESSIONID'}
)

    The following cookie will be added to the HTTP request:
       Cookie: JSESSIONID abc123
    """

    _default = None

    def __init__(self, host=None,
                 api_key=None, api_key_prefix=None,
                 username=None, password=None,
                 access_token=None,
                 server_index=None, server_variables=None,
                 server_operation_index=None, server_operation_variables=None,
                 ignore_operation_servers=False,
                 ssl_ca_cert=None,
                 retries=None,
                 *,
                 debug: Optional[bool] = None
                 ) -> None:
        """Constructor
        """
        self._base_path = "https://mainnet.zklighter.elliot.ai" if host is None else host
        """Default Base url
        """
        self.server_index = 0 if server_index is None and host is None else server_index
        self.server_operation_index = server_operation_index or {}
        """Default server index
        """
        self.server_variables = server_variables or {}
        self.server_operation_variables = server_operation_variables or {}
        """Default server variables
        """
        self.ignore_operation_servers = ignore_operation_servers
        """Ignore operation servers
        """
        self.temp_folder_path = None
        """Temp file folder for downloading files
        """
        # Authentication Settings
        self.api_key = {}
        if api_key:
            self.api_key = api_key
        """dict to store API key(s)
        """
        self.api_key_prefix = {}
        if api_key_prefix:
            self.api_key_prefix = api_key_prefix
        """dict to store API prefix (e.g. Bearer)
        """
        self.refresh_api_key_hook = None
        """function hook to refresh API key if expired
        """
        self.username = username
        """Username for HTTP basic authentication
        """
        self.password = password
        """Password for HTTP basic authentication
        """
        self.access_token = access_token
        """Access token
        """
        self.logger = {}
        """Logging Settings
        """
        self.logger["package_logger"] = logging.getLogger("lighter")
        self.logger["urllib3_logger"] = logging.getLogger("urllib3")
        self.logger_format = '%(asctime)s %(levelname)s %(message)s'
        """Log format
        """
        self.logger_stream_handler = None
        """Log stream handler
        """
        self.logger_file_handler: Optional[FileHandler] = None
        """Log file handler
        """
        self.logger_file = None
        """Debug file location
        """
        if debug is not None:
            self.debug = debug
        else:
            self.__debug = False
        """Debug switch
        """

        self.verify_ssl = True
        """SSL/TLS verification
           Set this to false to skip verifying SSL certificate when calling API
           from https server.
        """
        self.ssl_ca_cert = ssl_ca_cert
        """Set this to customize the certificate file to verify the peer.
        """
        self.cert_file = None
        """client certificate file
        """
        self.key_file = None
        """client key file
        """
        self.assert_hostname = None
        """Set this to True/False to enable/disable SSL hostname verification.
        """
        self.tls_server_name = None
        """SSL/TLS Server Name Indication (SNI)
           Set this to the SNI value expected by the server.
        """

        self.connection_pool_maxsize = 100
        """This value is passed to the aiohttp to limit simultaneous connections.
           Default values is 100, None means no-limit.
        """

        self.proxy: Optional[str] = None
        """Proxy URL
        """
        self.proxy_headers = None
        """Proxy headers
        """
        self.safe_chars_for_path_param = ''
        """Safe chars for path_param
        """
        self.retries = retries
        """Adding retries to override urllib3 default value 3
        """
        # Enable client side validation
        self.client_side_validation = True

        self.socket_options = None
        """Options to pass down to the underlying urllib3 socket
        """

        self.datetime_format = "%Y-%m-%dT%H:%M:%S.%f%z"
        """datetime format
        """

        self.date_format = "%Y-%m-%d"
        """date format
        """

    def __deepcopy__(self, memo):
        cls = self.__class__
        result = cls.__new__(cls)
        memo[id(self)] = result
        for k, v in self.__dict__.items():
            if k not in ('logger', 'logger_file_handler'):
                setattr(result, k, copy.deepcopy(v, memo))
        # shallow copy of loggers
        result.logger = copy.copy(self.logger)
        # use setters to configure loggers
        result.logger_file = self.logger_file
        result.debug = self.debug
        return result

    def __setattr__(self, name, value):
        object.__setattr__(self, name, value)

    @classmethod
    def set_default(cls, default):
        """Set default instance of configuration.

        It stores default configuration, which can be
        returned by get_default_copy method.

        :param default: object of Configuration
        """
        cls._default = default

    @classmethod
    def get_default_copy(cls):
        """Deprecated. Please use `get_default` instead.

        Deprecated. Please use `get_default` instead.

        :return: The configuration object.
        """
        return cls.get_default()

    @classmethod
    def get_default(cls):
        """Return the default configuration.

        This method returns newly created, based on default constructor,
        object of Configuration class or returns a copy of default
        configuration.

        :return: The configuration object.
        """
        if cls._default is None:
            cls._default = Configuration()
        return cls._default

    @property
    def logger_file(self):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        return self.__logger_file

    @logger_file.setter
    def logger_file(self, value):
        """The logger file.

        If the logger_file is None, then add stream handler and remove file
        handler. Otherwise, add file handler and remove stream handler.

        :param value: The logger_file path.
        :type: str
        """
        self.__logger_file = value
        if self.__logger_file:
            # If set logging file,
            # then add file handler and remove stream handler.
            self.logger_file_handler = logging.FileHandler(self.__logger_file)
            self.logger_file_handler.setFormatter(self.logger_formatter)
            for _, logger in self.logger.items():
                logger.addHandler(self.logger_file_handler)

    @property
    def debug(self):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        return self.__debug

    @debug.setter
    def debug(self, value):
        """Debug status

        :param value: The debug status, True or False.
        :type: bool
        """
        self.__debug = value
        if self.__debug:
            # if debug status is True, turn on debug logging
            for _, logger in self.logger.items():
                logger.setLevel(logging.DEBUG)
            # turn on httplib debug
            httplib.HTTPConnection.debuglevel = 1
        else:
            # if debug status is False, turn off debug logging,
            # setting log level to default `logging.WARNING`
            for _, logger in self.logger.items():
                logger.setLevel(logging.WARNING)
            # turn off httplib debug
            httplib.HTTPConnection.debuglevel = 0

    @property
    def logger_format(self):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        return self.__logger_format

    @logger_format.setter
    def logger_format(self, value):
        """The logger format.

        The logger_formatter will be updated when sets logger_format.

        :param value: The format string.
        :type: str
        """
        self.__logger_format = value
        self.logger_formatter = logging.Formatter(self.__logger_format)

    def get_api_key_with_prefix(self, identifier, alias=None):
        """Gets API key (with prefix if set).

        :param identifier: The identifier of apiKey.
        :param alias: The alternative identifier of apiKey.
        :return: The token for api key authentication.
        """
        if self.refresh_api_key_hook is not None:
            self.refresh_api_key_hook(self)
        key = self.api_key.get(identifier, self.api_key.get(alias) if alias is not None else None)
        if key:
            prefix = self.api_key_prefix.get(identifier)
            if prefix:
                return "%s %s" % (prefix, key)
            else:
                return key

    def get_basic_auth_token(self):
        """Gets HTTP basic authentication header (string).

        :return: The token for basic HTTP authentication.
        """
        username = ""
        if self.username is not None:
            username = self.username
        password = ""
        if self.password is not None:
            password = self.password
        return urllib3.util.make_headers(
            basic_auth=username + ':' + password
        ).get('authorization')

    def auth_settings(self):
        """Gets Auth Settings dict for api client.

        :return: The Auth Settings information dict.
        """
        auth = {}
        if 'apiKey' in self.api_key:
            auth['apiKey'] = {
                'type': 'api_key',
                'in': 'header',
                'key': 'Authorization',
                'value': self.get_api_key_with_prefix(
                    'apiKey',
                ),
            }
        return auth

    def to_debug_report(self):
        """Gets the essential information for debugging.

        :return: The report for debugging.
        """
        return "Python SDK Debug Report:\n"\
               "OS: {env}\n"\
               "Python Version: {pyversion}\n"\
               "Version of the API: \n"\
               "SDK Package Version: 1.0.0".\
               format(env=sys.platform, pyversion=sys.version)

    def get_host_settings(self):
        """Gets an array of host settings

        :return: An array of host settings
        """
        return [
            {
                'url': "https://mainnet.zklighter.elliot.ai",
                'description': "No description provided",
            }
        ]

    def get_host_from_settings(self, index, variables=None, servers=None):
        """Gets host URL based on the index and variables
        :param index: array index of the host settings
        :param variables: hash of variable and the corresponding value
        :param servers: an array of host settings or None
        :return: URL based on host settings
        """
        if index is None:
            return self._base_path

        variables = {} if variables is None else variables
        servers = self.get_host_settings() if servers is None else servers

        try:
            server = servers[index]
        except IndexError:
            raise ValueError(
                "Invalid index {0} when selecting the host settings. "
                "Must be less than {1}".format(index, len(servers)))

        url = server['url']

        # go through variables and replace placeholders
        for variable_name, variable in server.get('variables', {}).items():
            used_value = variables.get(
                variable_name, variable['default_value'])

            if 'enum_values' in variable \
                    and used_value not in variable['enum_values']:
                raise ValueError(
                    "The variable `{0}` in the host URL has invalid value "
                    "{1}. Must be {2}.".format(
                        variable_name, variables[variable_name],
                        variable['enum_values']))

            url = url.replace("{" + variable_name + "}", used_value)

        return url

    @property
    def host(self):
        """Return generated host."""
        return self.get_host_from_settings(self.server_index, variables=self.server_variables)

    @host.setter
    def host(self, value):
        """Fix base path."""
        self._base_path = value
        self.server_index = None



================================================================================
File: .\lighter\errors.py
================================================================================

class ValidationError(ValueError):
    pass



================================================================================
File: .\lighter\exceptions.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from typing import Any, Optional
from typing_extensions import Self

class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class ApiTypeError(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None,
                 key_type=None) -> None:
        """ Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiTypeError, self).__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiValueError, self).__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiAttributeError, self).__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None) -> None:
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = "{0} at {1}".format(msg, render_path(path_to_item))
        super(ApiKeyError, self).__init__(full_msg)


class ApiException(OpenApiException):

    def __init__(
        self, 
        status=None, 
        reason=None, 
        http_resp=None,
        *,
        body: Optional[str] = None,
        data: Optional[Any] = None,
    ) -> None:
        self.status = status
        self.reason = reason
        self.body = body
        self.data = data
        self.headers = None

        if http_resp:
            if self.status is None:
                self.status = http_resp.status
            if self.reason is None:
                self.reason = http_resp.reason
            if self.body is None:
                try:
                    self.body = http_resp.data.decode('utf-8')
                except Exception:
                    pass
            self.headers = http_resp.getheaders()

    @classmethod
    def from_response(
        cls, 
        *, 
        http_resp, 
        body: Optional[str], 
        data: Optional[Any],
    ) -> Self:
        if http_resp.status == 400:
            raise BadRequestException(http_resp=http_resp, body=body, data=data)

        if http_resp.status == 401:
            raise UnauthorizedException(http_resp=http_resp, body=body, data=data)

        if http_resp.status == 403:
            raise ForbiddenException(http_resp=http_resp, body=body, data=data)

        if http_resp.status == 404:
            raise NotFoundException(http_resp=http_resp, body=body, data=data)

        if 500 <= http_resp.status <= 599:
            raise ServiceException(http_resp=http_resp, body=body, data=data)
        raise ApiException(http_resp=http_resp, body=body, data=data)

    def __str__(self):
        """Custom error messages for exception"""
        error_message = "({0})\n"\
                        "Reason: {1}\n".format(self.status, self.reason)
        if self.headers:
            error_message += "HTTP response headers: {0}\n".format(
                self.headers)

        if self.data or self.body:
            error_message += "HTTP response body: {0}\n".format(self.data or self.body)

        return error_message


class BadRequestException(ApiException):
    pass


class NotFoundException(ApiException):
    pass


class UnauthorizedException(ApiException):
    pass


class ForbiddenException(ApiException):
    pass


class ServiceException(ApiException):
    pass


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += "[{0}]".format(pth)
        else:
            result += "['{0}']".format(pth)
    return result



================================================================================
File: .\lighter\nonce_manager.py
================================================================================

import abc
import enum
from typing import Optional, Tuple

import requests

from lighter import api_client
from lighter.api import transaction_api
from lighter.errors import ValidationError


def get_nonce_from_api(client: api_client.ApiClient, account_index: int, api_key_index: int) -> int:
    #  uses request to avoid async initialization
    req = requests.get(
        client.configuration.host + "/api/v1/nextNonce",
        params={"account_index": account_index, "api_key_index": api_key_index},
    )
    if req.status_code != 200:
        raise Exception(f"couldn't get nonce {req.content}")
    return req.json()["nonce"]


class NonceManager(abc.ABC):
    def __init__(
        self,
        account_index: int,
        api_client: api_client.ApiClient,
        start_api_key: int,
        end_api_key: Optional[int] = None,
    ):
        if end_api_key is None:
            end_api_key = start_api_key
        if start_api_key > end_api_key or start_api_key >= 255 or end_api_key >= 255:
            raise ValidationError(f"invalid range {start_api_key=} {end_api_key=}")
        self.start_api_key = start_api_key
        self.end_api_key = end_api_key
        self.current_api_key = end_api_key  # start will be used for the first tx
        self.account_index = account_index
        self.api_client = api_client
        self.nonce = {
            api_key_index: get_nonce_from_api(api_client, account_index, api_key_index) - 1
            for api_key_index in range(start_api_key, end_api_key + 1)
        }

    def hard_refresh_nonce(self, api_key: int):
        self.nonce[api_key] = get_nonce_from_api(self.api_client, self.account_index, api_key) - 1

    @abc.abstractmethod
    def next_nonce(self) -> Tuple[int, int]:
        pass

    def acknowledge_failure(self, api_key_index: int) -> None:
        pass


def increment_circular(idx: int, start_idx: int, end_idx: int) -> int:
    idx += 1
    if idx > end_idx:
        return start_idx
    return idx


class OptimisticNonceManager(NonceManager):
    def __init__(
        self,
        account_index: int,
        api_client: api_client.ApiClient,
        start_api_key: int,
        end_api_key: Optional[int] = None,
    ) -> None:
        super().__init__(account_index, api_client, start_api_key, end_api_key)

    def next_nonce(self) -> Tuple[int, int]:
        self.current_api_key = increment_circular(self.current_api_key, self.start_api_key, self.end_api_key)
        self.nonce[self.current_api_key] += 1
        return (self.current_api_key, self.nonce[self.current_api_key])

    def acknowledge_failure(self, api_key_index: int) -> None:
        self.nonce[api_key_index] -= 1


class ApiNonceManager(NonceManager):
    def __init__(
        self,
        account_index: int,
        api_client: api_client.ApiClient,
        start_api_key: int,
        end_api_key: Optional[int] = None,
    ) -> None:
        super().__init__(account_index, api_client, start_api_key, end_api_key)

    def next_nonce(self) -> Tuple[int, int]:
        """
        It is recommended to wait at least 350ms before using the same api key.
        Please be mindful of your transaction frequency when using this nonce manager.
        predicted_execution_time_ms from the response could give you a tighter bound.
        """
        self.current_api_key = increment_circular(self.current_api_key, self.start_api_key, self.end_api_key)
        self.nonce[self.current_api_key] = get_nonce_from_api(self.api_client, self.account_index, self.current_api_key)
        return (self.current_api_key, self.nonce[self.current_api_key])

    def refresh_nonce(self, api_key_index: int) -> int:
        self.nonce[api_key_index] = get_nonce_from_api(self.api_client, self.start_api_key, self.end_api_key)


class NonceManagerType(enum.Enum):
    OPTIMISTIC = 1
    API = 2


def nonce_manager_factory(
    nonce_manager_type: NonceManagerType,
    account_index: int,
    api_client: api_client.ApiClient,
    start_api_key: int,
    end_api_key: Optional[int] = None,
) -> NonceManager:
    if nonce_manager_type == NonceManagerType.OPTIMISTIC:
        return OptimisticNonceManager(
            account_index=account_index,
            api_client=api_client,
            start_api_key=start_api_key,
            end_api_key=end_api_key,
        )
    elif nonce_manager_type == NonceManagerType.API:
        return ApiNonceManager(
            account_index=account_index,
            api_client=api_client,
            start_api_key=start_api_key,
            end_api_key=end_api_key,
        )
    raise ValidationError("invalid nonce manager type")



================================================================================
File: .\lighter\rest.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import io
import json
import re
import ssl
from typing import Optional, Union

import aiohttp
import aiohttp_retry

from lighter.exceptions import ApiException, ApiValueError

RESTResponseType = aiohttp.ClientResponse

ALLOW_RETRY_METHODS = frozenset({'DELETE', 'GET', 'HEAD', 'OPTIONS', 'PUT', 'TRACE'})

class RESTResponse(io.IOBase):

    def __init__(self, resp) -> None:
        self.response = resp
        self.status = resp.status
        self.reason = resp.reason
        self.data = None

    async def read(self):
        if self.data is None:
            self.data = await self.response.read()
        return self.data

    def getheaders(self):
        """Returns a CIMultiDictProxy of the response headers."""
        return self.response.headers

    def getheader(self, name, default=None):
        """Returns a given response header."""
        return self.response.headers.get(name, default)


class RESTClientObject:

    def __init__(self, configuration) -> None:

        # maxsize is number of requests to host that are allowed in parallel
        maxsize = configuration.connection_pool_maxsize

        ssl_context = ssl.create_default_context(
            cafile=configuration.ssl_ca_cert
        )
        if configuration.cert_file:
            ssl_context.load_cert_chain(
                configuration.cert_file, keyfile=configuration.key_file
            )

        if not configuration.verify_ssl:
            ssl_context.check_hostname = False
            ssl_context.verify_mode = ssl.CERT_NONE

        connector = aiohttp.TCPConnector(
            limit=maxsize,
            ssl=ssl_context
        )

        self.proxy = configuration.proxy
        self.proxy_headers = configuration.proxy_headers

        # https pool manager
        self.pool_manager = aiohttp.ClientSession(
            connector=connector,
            trust_env=True
        )

        retries = configuration.retries
        self.retry_client: Optional[aiohttp_retry.RetryClient]
        if retries is not None:
            self.retry_client = aiohttp_retry.RetryClient(
                client_session=self.pool_manager,
                retry_options=aiohttp_retry.ExponentialRetry(
                    attempts=retries,
                    factor=0.0,
                    start_timeout=0.0,
                    max_timeout=120.0
                )
            )
        else:
            self.retry_client = None

    async def close(self):
        await self.pool_manager.close()
        if self.retry_client is not None:
            await self.retry_client.close()

    async def request(
        self,
        method,
        url,
        headers=None,
        body=None,
        post_params=None,
        _request_timeout=None
    ):
        """Execute request

        :param method: http request method
        :param url: http request url
        :param headers: http request headers
        :param body: request json body, for `application/json`
        :param post_params: request post parameters,
                            `application/x-www-form-urlencoded`
                            and `multipart/form-data`
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        """
        method = method.upper()
        assert method in [
            'GET',
            'HEAD',
            'DELETE',
            'POST',
            'PUT',
            'PATCH',
            'OPTIONS'
        ]

        if post_params and body:
            raise ApiValueError(
                "body parameter cannot be used with post_params parameter."
            )

        post_params = post_params or {}
        headers = headers or {}
        # url already contains the URL query string
        timeout = _request_timeout or 5 * 60

        if 'Content-Type' not in headers:
            headers['Content-Type'] = 'application/json'

        args = {
            "method": method,
            "url": url,
            "timeout": timeout,
            "headers": headers
        }

        if self.proxy:
            args["proxy"] = self.proxy
        if self.proxy_headers:
            args["proxy_headers"] = self.proxy_headers

        # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
        if method in ['POST', 'PUT', 'PATCH', 'OPTIONS', 'DELETE']:
            if re.search('json', headers['Content-Type'], re.IGNORECASE):
                if body is not None:
                    body = json.dumps(body)
                args["data"] = body
            elif headers['Content-Type'] == 'application/x-www-form-urlencoded':
                args["data"] = aiohttp.FormData(post_params)
            elif headers['Content-Type'] == 'multipart/form-data':
                # must del headers['Content-Type'], or the correct
                # Content-Type which generated by aiohttp
                del headers['Content-Type']
                data = aiohttp.FormData()
                for param in post_params:
                    k, v = param
                    if isinstance(v, tuple) and len(v) == 3:
                        data.add_field(
                            k,
                            value=v[1],
                            filename=v[0],
                            content_type=v[2]
                        )
                    else:
                        data.add_field(k, v)
                args["data"] = data

            # Pass a `bytes` or `str` parameter directly in the body to support
            # other content types than Json when `body` argument is provided
            # in serialized form
            elif isinstance(body, str) or isinstance(body, bytes):
                args["data"] = body
            else:
                # Cannot generate the request from given parameters
                msg = """Cannot prepare a request message for provided
                         arguments. Please check that your arguments match
                         declared content type."""
                raise ApiException(status=0, reason=msg)

        pool_manager: Union[aiohttp.ClientSession, aiohttp_retry.RetryClient]
        if self.retry_client is not None and method in ALLOW_RETRY_METHODS:
            pool_manager = self.retry_client
        else:
            pool_manager = self.pool_manager

        r = await pool_manager.request(**args)

        return RESTResponse(r)








================================================================================
File: .\lighter\signer_client.py
================================================================================

import ctypes
from functools import wraps
import inspect
import json
import platform
import logging
import os
import time
from typing import Dict, Optional, Tuple

from eth_account import Account
from eth_account.messages import encode_defunct
from pydantic import StrictInt
import lighter
from lighter.configuration import Configuration
from lighter.errors import ValidationError
from lighter.models import TxHash
from lighter import nonce_manager
from lighter.models.resp_send_tx import RespSendTx
from lighter.transactions import CreateOrder, CancelOrder, Withdraw

logging.basicConfig(level=logging.DEBUG)

CODE_OK = 200


class ApiKeyResponse(ctypes.Structure):
    _fields_ = [("privateKey", ctypes.c_char_p), ("publicKey", ctypes.c_char_p), ("err", ctypes.c_char_p)]


class StrOrErr(ctypes.Structure):
    _fields_ = [("str", ctypes.c_char_p), ("err", ctypes.c_char_p)]


def _initialize_signer():
    is_linux = platform.system() == "Linux"
    is_mac = platform.system() == "Darwin"
    is_x64 = platform.machine().lower() in ("amd64", "x86_64")
    is_arm = platform.machine().lower() == "arm64"

    current_file_directory = os.path.dirname(os.path.abspath(__file__))
    path_to_signer_folders = os.path.join(current_file_directory, "signers")

    if is_arm and is_mac:
        logging.debug("Detected ARM architecture on macOS.")
        return ctypes.CDLL(os.path.join(path_to_signer_folders, "signer-arm64.dylib"))
    elif is_linux and is_x64:
        logging.debug("Detected x64/amd architecture on Linux.")
        return ctypes.CDLL(os.path.join(path_to_signer_folders, "signer-amd64.so"))
    else:
        raise Exception(
            f"Unsupported platform/architecture: {platform.system()}/{platform.machine()} only supports Linux(x86) and Darwin(arm64)"
        )


def create_api_key(seed=""):
    signer = _initialize_signer()
    signer.GenerateAPIKey.argtypes = [
        ctypes.c_char_p,
    ]
    signer.GenerateAPIKey.restype = ApiKeyResponse
    result = signer.GenerateAPIKey(ctypes.c_char_p(seed.encode("utf-8")))

    private_key_str = result.privateKey.decode("utf-8") if result.privateKey else None
    public_key_str = result.publicKey.decode("utf-8") if result.publicKey else None
    error = result.err.decode("utf-8") if result.err else None

    return private_key_str, public_key_str, error


def trim_exc(exception_body: str):
    return exception_body.strip().split("\n")[-1]


def process_api_key_and_nonce(func):
    @wraps(func)
    async def wrapper(self, *args, **kwargs):
        # Get the signature
        sig = inspect.signature(func)

        # Bind args and kwargs to the function's signature
        bound_args = sig.bind(self, *args, **kwargs)
        bound_args.apply_defaults()
        # Extract api_key_index and nonce from kwargs or use defaults
        api_key_index = bound_args.arguments.get("api_key_index", -1)
        nonce = bound_args.arguments.get("nonce", -1)
        if api_key_index == -1 and nonce == -1:
            api_key_index, nonce = self.nonce_manager.next_nonce()
        err = self.switch_api_key(api_key_index)
        if err != None:
            raise Exception(f"error switching api key: {err}")

        # Call the original function with modified kwargs
        ret: TxHash
        try:
            partial_arguments = {k: v for k, v in bound_args.arguments.items() if k not in ("self", "nonce", "api_key_index")}
            created_tx, ret, err = await func(self, **partial_arguments, nonce=nonce, api_key_index=api_key_index)
            if ret.code != CODE_OK:
                self.nonce_manager.acknowledge_failure(api_key_index)
        except lighter.exceptions.BadRequestException as e:
            if "invalid nonce" in str(e):
                self.nonce_manager.hard_refresh_nonce(api_key_index)
                return None, None, trim_exc(str(e))
            else:
                self.nonce_manager.acknowledge_failure(api_key_index)
                return None, None, trim_exc(str(e))

        return created_tx, ret, err

    return wrapper


class SignerClient:
    USDC_TICKER_SCALE = 1e6

    TX_TYPE_CHANGE_PUB_KEY = 8
    TX_TYPE_CREATE_SUB_ACCOUNT = 9
    TX_TYPE_CREATE_PUBLIC_POOL = 10
    TX_TYPE_UPDATE_PUBLIC_POOL = 11
    TX_TYPE_TRANSFER = 12
    TX_TYPE_WITHDRAW = 13
    TX_TYPE_CREATE_ORDER = 14
    TX_TYPE_CANCEL_ORDER = 15
    TX_TYPE_CANCEL_ALL_ORDERS = 16
    TX_TYPE_MODIFY_ORDER = 17
    TX_TYPE_MINT_SHARES = 18
    TX_TYPE_BURN_SHARES = 19
    TX_TYPE_UPDATE_LEVERAGE = 20

    ORDER_TYPE_LIMIT = 0
    ORDER_TYPE_MARKET = 1
    ORDER_TYPE_STOP_LOSS = 2
    ORDER_TYPE_STOP_LOSS_LIMIT = 3
    ORDER_TYPE_TAKE_PROFIT = 4
    ORDER_TYPE_TAKE_PROFIT_LIMIT = 5
    ORDER_TYPE_TWAP = 6

    ORDER_TIME_IN_FORCE_IMMEDIATE_OR_CANCEL = 0
    ORDER_TIME_IN_FORCE_GOOD_TILL_TIME = 1
    ORDER_TIME_IN_FORCE_POST_ONLY = 2

    CANCEL_ALL_TIF_IMMEDIATE = 0
    CANCEL_ALL_TIF_SCHEDULED = 1
    CANCEL_ALL_TIF_ABORT = 2

    NIL_TRIGGER_PRICE = 0
    DEFAULT_28_DAY_ORDER_EXPIRY = -1
    DEFAULT_IOC_EXPIRY = 0
    DEFAULT_10_MIN_AUTH_EXPIRY = -1
    MINUTE = 60

    CROSS_MARGIN_MODE  = 0
    ISOLATED_MARGIN_MODE = 1

    def __init__(
        self,
        url,
        private_key,
        api_key_index,
        account_index,
        max_api_key_index=-1,
        private_keys: Optional[Dict[int, str]] = None,
        nonce_management_type=nonce_manager.NonceManagerType.OPTIMISTIC,
    ):
        """
        First private key needs to be passed separately for backwards compatibility.
        This may get deprecated in a future version.
        """
        chain_id = 304 if "mainnet" in url else 300

        # api_key_index=0 is generally used by frontend
        if private_key.startswith("0x"):
            private_key = private_key[2:]
        self.url = url
        self.private_key = private_key
        self.chain_id = chain_id
        self.api_key_index = api_key_index
        if max_api_key_index == -1:
            self.end_api_key_index = api_key_index
        else:
            self.end_api_key_index = max_api_key_index

        private_keys = private_keys or {}
        self.validate_api_private_keys(private_key, private_keys)
        self.api_key_dict = self.build_api_key_dict(private_key, private_keys)
        self.account_index = account_index
        self.signer = _initialize_signer()
        self.api_client = lighter.ApiClient(configuration=Configuration(host=url))
        self.tx_api = lighter.TransactionApi(self.api_client)
        self.order_api = lighter.OrderApi(self.api_client)
        self.nonce_manager = nonce_manager.nonce_manager_factory(
            nonce_manager_type=nonce_management_type,
            account_index=account_index,
            api_client=self.api_client,
            start_api_key=self.api_key_index,
            end_api_key=self.end_api_key_index,
        )
        for api_key in range(self.api_key_index, self.end_api_key_index + 1):
            self.create_client(api_key)

    def validate_api_private_keys(self, initial_private_key: str, private_keys: Dict[int, str]):
        if len(private_keys) == self.end_api_key_index - self.api_key_index + 1:
            if not self.are_keys_equal(private_keys[self.api_key_index], initial_private_key):
                raise ValidationError("inconsistent private keys")
            return  # this is all we need to check in this case
        if len(private_keys) != self.end_api_key_index - self.api_key_index:
            raise ValidationError("unexpected number of private keys")
        for api_key in range(self.api_key_index + 1, self.end_api_key_index):
            if api_key not in private_keys:
                raise Exception(f"missing {api_key=} private key!")

    def build_api_key_dict(self, private_key, private_keys):
        if len(private_keys) == self.end_api_key_index - self.api_key_index:
            private_keys[self.api_key_index] = private_key
        return private_keys

    def create_client(self, api_key_index=None):
        self.signer.CreateClient.argtypes = [
            ctypes.c_char_p,
            ctypes.c_char_p,
            ctypes.c_int,
            ctypes.c_int,
            ctypes.c_longlong,
        ]
        api_key_index = api_key_index or self.api_key_index
        self.signer.CreateClient.restype = ctypes.c_char_p
        err = self.signer.CreateClient(
            self.url.encode("utf-8"),
            self.api_key_dict[api_key_index].encode("utf-8"),
            self.chain_id,
            api_key_index,
            self.account_index,
        )

        if err is None:
            return

        err_str = err.decode("utf-8")
        raise Exception(err_str)

    # check_client verifies that the given API key associated with (api_key_index, account_index) matches the one on Lighter
    def check_client(self):
        self.signer.CheckClient.argtypes = [
            ctypes.c_int,
            ctypes.c_longlong,
        ]
        self.signer.CheckClient.restype = ctypes.c_char_p

        for api_key in range(self.api_key_index, self.end_api_key_index + 1):
            result = self.signer.CheckClient(api_key, self.account_index)
            if result:
                return result.decode("utf-8") + f" on api key {self.api_key_index}"
        return result.decode("utf-8") if result else None

    def switch_api_key(self, api_key: int):
        self.signer.SwitchAPIKey.argtypes = [ctypes.c_int]
        self.signer.CheckClient.restype = ctypes.c_char_p
        result = self.signer.SwitchAPIKey(api_key)
        return result.decode("utf-8") if result else None

    def create_api_key(self, seed=""):
        self.signer.GenerateAPIKey.argtypes = [
            ctypes.c_char_p,
        ]
        self.signer.GenerateAPIKey.restype = ApiKeyResponse
        result = self.signer.GenerateAPIKey(ctypes.c_char_p(seed.encode("utf-8")))

        private_key_str = result.str.decode("utf-8") if result.privateKey else None
        public_key_str = result.str.decode("utf-8") if result.publicKey else None
        error = result.err.decode("utf-8") if result.err else None

        return private_key_str, public_key_str, error

    def sign_change_api_key(self, eth_private_key, new_pubkey: str, nonce: int):
        self.signer.SignChangePubKey.argtypes = [
            ctypes.c_char_p,
            ctypes.c_longlong,
        ]
        self.signer.SignChangePubKey.restype = StrOrErr
        result = self.signer.SignChangePubKey(ctypes.c_char_p(new_pubkey.encode("utf-8")), nonce)

        tx_info_str = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None
        if error is not None:
            return None, error

        # fetch message to sign
        tx_info = json.loads(tx_info_str)
        msg_to_sign = tx_info["MessageToSign"]
        del tx_info["MessageToSign"]

        # sign the message
        acct = Account.from_key(eth_private_key)
        message = encode_defunct(text=msg_to_sign)
        signature = acct.sign_message(message)
        tx_info["L1Sig"] = signature.signature.to_0x_hex()
        return json.dumps(tx_info), None

    def get_api_key_nonce(self, api_key_index: int, nonce: int) -> Tuple[int, int]:
        if api_key_index != -1 and nonce != -1:
            return api_key_index, nonce
        if nonce != -1:
            if self.api_key_index == self.end_api_key_index:
                return self.nonce_manager.next_nonce()
            else:
                raise Exception("ambiguous api key")
        return self.nonce_manager.next_nonce()

    def sign_create_order(
        self,
        market_index,
        client_order_index,
        base_amount,
        price,
        is_ask,
        order_type,
        time_in_force,
        reduce_only,
        trigger_price,
        order_expiry=DEFAULT_28_DAY_ORDER_EXPIRY,
        nonce=-1,
    ):
        self.signer.SignCreateOrder.argtypes = [
            ctypes.c_int,
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_int,
            ctypes.c_int,
            ctypes.c_int,
            ctypes.c_int,
            ctypes.c_int,
            ctypes.c_int,
            ctypes.c_longlong,
            ctypes.c_longlong,
        ]
        self.signer.SignCreateOrder.restype = StrOrErr

        result = self.signer.SignCreateOrder(
            market_index,
            client_order_index,
            base_amount,
            price,
            int(is_ask),
            order_type,
            time_in_force,
            reduce_only,
            trigger_price,
            order_expiry,
            nonce,
        )

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_cancel_order(self, market_index, order_index, nonce=-1):
        self.signer.SignCancelOrder.argtypes = [
            ctypes.c_int,
            ctypes.c_longlong,
            ctypes.c_longlong,
        ]
        self.signer.SignCancelOrder.restype = StrOrErr

        result = self.signer.SignCancelOrder(market_index, order_index, nonce)

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_withdraw(self, usdc_amount, nonce=-1):
        self.signer.SignWithdraw.argtypes = [ctypes.c_longlong, ctypes.c_longlong]
        self.signer.SignWithdraw.restype = StrOrErr

        result = self.signer.SignWithdraw(usdc_amount, nonce)

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_create_sub_account(self, nonce=-1):
        self.signer.SignCreateSubAccount.argtypes = [ctypes.c_longlong]
        self.signer.SignCreateSubAccount.restype = StrOrErr

        result = self.signer.SignCreateSubAccount(nonce)

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_cancel_all_orders(self, time_in_force, time, nonce=-1):
        self.signer.SignCancelAllOrders.argtypes = [
            ctypes.c_int,
            ctypes.c_longlong,
            ctypes.c_longlong,
        ]
        self.signer.SignCancelAllOrders.restype = StrOrErr

        result = self.signer.SignCancelAllOrders(time_in_force, time, nonce)

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_modify_order(self, market_index, order_index, base_amount, price, trigger_price, nonce=-1):
        self.signer.SignModifyOrder.argtypes = [
            ctypes.c_int,
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_longlong,
        ]
        self.signer.SignModifyOrder.restype = StrOrErr

        result = self.signer.SignModifyOrder(market_index, order_index, base_amount, price, trigger_price, nonce)

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_transfer(self, eth_private_key, to_account_index, usdc_amount, fee, memo, nonce=-1):
        self.signer.SignTransfer.argtypes = [
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_char_p,
            ctypes.c_longlong,
        ]
        self.signer.SignTransfer.restype = StrOrErr
        result = self.signer.SignTransfer(to_account_index, usdc_amount, fee, ctypes.c_char_p(memo.encode("utf-8")), nonce)

        tx_info_str = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        if error:
            return tx_info_str, error
        
        # fetch message to sign
        tx_info = json.loads(tx_info_str)
        msg_to_sign = tx_info["MessageToSign"]
        del tx_info["MessageToSign"]

        # sign the message
        acct = Account.from_key(eth_private_key)
        message = encode_defunct(text=msg_to_sign)
        signature = acct.sign_message(message)
        tx_info["L1Sig"] = signature.signature.to_0x_hex()
        return json.dumps(tx_info), None

    def sign_create_public_pool(self, operator_fee, initial_total_shares, min_operator_share_rate, nonce=-1):
        self.signer.SignCreatePublicPool.argtypes = [
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_longlong,
        ]
        self.signer.SignCreatePublicPool.restype = StrOrErr

        result = self.signer.SignCreatePublicPool(operator_fee, initial_total_shares, min_operator_share_rate, nonce)

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_update_public_pool(self, public_pool_index, status, operator_fee, min_operator_share_rate, nonce=-1):
        self.signer.SignUpdatePublicPool.argtypes = [
            ctypes.c_longlong,
            ctypes.c_int,
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_longlong,
        ]
        self.signer.SignUpdatePublicPool.restype = StrOrErr

        result = self.signer.SignUpdatePublicPool(
            public_pool_index, status, operator_fee, min_operator_share_rate, nonce
        )

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_mint_shares(self, public_pool_index, share_amount, nonce=-1):
        self.signer.SignMintShares.argtypes = [
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_longlong,
        ]
        self.signer.SignMintShares.restype = StrOrErr

        result = self.signer.SignMintShares(public_pool_index, share_amount, nonce)

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_burn_shares(self, public_pool_index, share_amount, nonce=-1):
        self.signer.SignBurnShares.argtypes = [
            ctypes.c_longlong,
            ctypes.c_longlong,
            ctypes.c_longlong,
        ]
        self.signer.SignBurnShares.restype = StrOrErr

        result = self.signer.SignBurnShares(public_pool_index, share_amount, nonce)

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None

        return tx_info, error

    def sign_update_leverage(self, market_index, fraction, margin_mode, nonce=-1):
        self.signer.SignUpdateLeverage.argtypes = [
            ctypes.c_int,
            ctypes.c_int,
            ctypes.c_int,
            ctypes.c_longlong,
        ]
        self.signer.SignUpdateLeverage.restype = StrOrErr
        result = self.signer.SignUpdateLeverage(market_index, fraction, margin_mode, nonce)

        tx_info = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None
        return tx_info, error

    def create_auth_token_with_expiry(self, deadline: int = DEFAULT_10_MIN_AUTH_EXPIRY):
        if deadline == SignerClient.DEFAULT_10_MIN_AUTH_EXPIRY:
            deadline = int(time.time() + 10 * SignerClient.MINUTE)
        self.signer.CreateAuthToken.argtypes = [ctypes.c_longlong]
        self.signer.CreateAuthToken.restype = StrOrErr
        result = self.signer.CreateAuthToken(deadline)

        auth = result.str.decode("utf-8") if result.str else None
        error = result.err.decode("utf-8") if result.err else None
        return auth, error

    async def change_api_key(self, eth_private_key: str, new_pubkey: str, nonce=-1):
        tx_info, error = self.sign_change_api_key(eth_private_key, new_pubkey, nonce)
        if error is not None:
            return None, error

        logging.debug(f"Change Pub Key Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_CHANGE_PUB_KEY, tx_info=tx_info)
        logging.debug(f"Change Pub Key Send Tx Response: {api_response}")
        return api_response, None

    @process_api_key_and_nonce
    async def create_order(
        self,
        market_index,
        client_order_index,
        base_amount,
        price,
        is_ask,
        order_type,
        time_in_force,
        reduce_only=False,
        trigger_price=NIL_TRIGGER_PRICE,
        order_expiry=-1,
        nonce=-1,
        api_key_index=-1,
    ) -> (CreateOrder, TxHash, str):
        tx_info, error = self.sign_create_order(
            market_index,
            client_order_index,
            base_amount,
            price,
            int(is_ask),
            order_type,
            time_in_force,
            int(reduce_only),
            trigger_price,
            order_expiry,
            nonce,
        )
        if error is not None:
            return None, None, error
        logging.debug(f"Create Order Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_CREATE_ORDER, tx_info=tx_info)
        logging.debug(f"Create Order Send Tx Response: {api_response}")
        return CreateOrder.from_json(tx_info), api_response, None

    async def create_market_order(
        self,
        market_index,
        client_order_index,
        base_amount,
        avg_execution_price,
        is_ask,
        reduce_only: bool = False,
        nonce=-1,
        api_key_index=-1,
    ) -> (CreateOrder, TxHash, str):
        return await self.create_order(
            market_index,
            client_order_index,
            base_amount,
            avg_execution_price,
            is_ask,
            order_type=self.ORDER_TYPE_MARKET,
            time_in_force=self.ORDER_TIME_IN_FORCE_IMMEDIATE_OR_CANCEL,
            order_expiry=self.DEFAULT_IOC_EXPIRY,
            reduce_only=reduce_only,
            nonce=nonce,
            api_key_index=api_key_index,
        )

    # will only do the amount such that the slippage is limited to the value provided
    async def create_market_order_limited_slippage(
        self,
        market_index,
        client_order_index,
        base_amount,
        max_slippage,
        is_ask,
        reduce_only: bool = False,
        nonce=-1,
        api_key_index=-1,
        ideal_price=None
    ) -> (CreateOrder, TxHash, str):
        if ideal_price is None:
            order_book_orders = await self.order_api.order_book_orders(market_index, 1)
            logging.debug("Create market order limited slippage is doing an API call to get the current ideal price. You can also provide it yourself to avoid this.")
            ideal_price = int((order_book_orders.bids[0].price if is_ask else order_book_orders.asks[0].price).replace(".", ""))

        acceptable_execution_price = round(ideal_price * (1 + max_slippage * (-1 if is_ask else 1)))
        return await self.create_order(
            market_index,
            client_order_index,
            base_amount,
            price=acceptable_execution_price,
            is_ask=is_ask,
            order_type=self.ORDER_TYPE_MARKET,
            time_in_force=self.ORDER_TIME_IN_FORCE_IMMEDIATE_OR_CANCEL,
            order_expiry=self.DEFAULT_IOC_EXPIRY,
            reduce_only=reduce_only,
            nonce=nonce,
            api_key_index=api_key_index,
        )

    # will only execute the order if it executes with slippage <= max_slippage
    async def create_market_order_if_slippage(
        self,
        market_index,
        client_order_index,
        base_amount,
        max_slippage,
        is_ask,
        reduce_only: bool = False,
        nonce=-1,
        api_key_index=-1,
        ideal_price=None
    ) -> (CreateOrder, TxHash, str):
        order_book_orders = await self.order_api.order_book_orders(market_index, 100)
        if ideal_price is None:
            ideal_price = int((order_book_orders.bids[0].price if is_ask else order_book_orders.asks[0].price).replace(".", ""))

        matched_usd_amount, matched_size = 0, 0
        for order_book_order in (order_book_orders.bids if is_ask else order_book_orders.asks):
            if matched_size == base_amount:
                break
            curr_order_price = int(order_book_order.price.replace(".", ""))
            curr_order_size = int(order_book_order.remaining_base_amount.replace(".", ""))
            to_be_used_order_size = min(base_amount - matched_size, curr_order_size)
            matched_usd_amount += curr_order_price * to_be_used_order_size
            matched_size += to_be_used_order_size

        potential_execution_price = matched_usd_amount / matched_size
        acceptable_execution_price = ideal_price * (1 + max_slippage * (-1 if is_ask else 1))
        if (is_ask and potential_execution_price < acceptable_execution_price) or (not is_ask and potential_execution_price > acceptable_execution_price):
            return None, None, "Excessive slippage"

        if matched_size < base_amount:
            return None, None, "Cannot be sure slippage will be acceptable due to the high size"

        return await self.create_order(
            market_index,
            client_order_index,
            base_amount,
            price=round(acceptable_execution_price),
            is_ask=is_ask,
            order_type=self.ORDER_TYPE_MARKET,
            time_in_force=self.ORDER_TIME_IN_FORCE_IMMEDIATE_OR_CANCEL,
            order_expiry=self.DEFAULT_IOC_EXPIRY,
            reduce_only=reduce_only,
            nonce=nonce,
            api_key_index=api_key_index,
        )

    @process_api_key_and_nonce
    async def cancel_order(self, market_index, order_index, nonce=-1, api_key_index=-1) -> (CancelOrder, TxHash, str):
        tx_info, error = self.sign_cancel_order(market_index, order_index, nonce)
        if error is not None:
            return None, None, error
        logging.debug(f"Cancel Order Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_CANCEL_ORDER, tx_info=tx_info)
        logging.debug(f"Cancel Order Send Tx Response: {api_response}")
        return CancelOrder.from_json(tx_info), api_response, None

    async def create_tp_order(self, market_index, client_order_index, base_amount, trigger_price, price, is_ask, reduce_only=False, nonce=-1, api_key_index=-1) -> (CreateOrder, TxHash, str):
        return await self.create_order(
            market_index,
            client_order_index,
            base_amount,
            price,
            is_ask,
            self.ORDER_TYPE_TAKE_PROFIT,
            self.DEFAULT_IOC_EXPIRY,
            reduce_only,
            trigger_price,
            self.DEFAULT_28_DAY_ORDER_EXPIRY,
            nonce,
            api_key_index=api_key_index,
        )

    async def create_tp_limit_order(self, market_index, client_order_index, base_amount, trigger_price, price, is_ask, reduce_only=False, nonce=-1, api_key_index=-1) -> (CreateOrder, TxHash, str):
        return await self.create_order(
            market_index,
            client_order_index,
            base_amount,
            price,
            is_ask,
            self.ORDER_TYPE_TAKE_PROFIT_LIMIT,
            self.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
            reduce_only,
            trigger_price,
            self.DEFAULT_28_DAY_ORDER_EXPIRY,
            nonce,
            api_key_index,
        )

    async def create_sl_order(self, market_index, client_order_index, base_amount, trigger_price, price, is_ask, reduce_only=False, nonce=-1, api_key_index=-1) -> (CreateOrder, TxHash, str):
        return await self.create_order(
            market_index,
            client_order_index,
            base_amount,
            price,
            is_ask,
            self.ORDER_TYPE_STOP_LOSS,
            self.DEFAULT_IOC_EXPIRY,
            reduce_only,
            trigger_price,
            self.DEFAULT_28_DAY_ORDER_EXPIRY,
            nonce,
            api_key_index=api_key_index,
        )

    async def create_sl_limit_order(self, market_index, client_order_index, base_amount, trigger_price, price, is_ask, reduce_only=False, nonce=-1, api_key_index=-1) -> (CreateOrder, TxHash, str):
        return await self.create_order(
            market_index,
            client_order_index,
            base_amount,
            price,
            is_ask,
            self.ORDER_TYPE_STOP_LOSS_LIMIT,
            self.ORDER_TIME_IN_FORCE_GOOD_TILL_TIME,
            reduce_only,
            trigger_price,
            self.DEFAULT_28_DAY_ORDER_EXPIRY,
            nonce,
            api_key_index,
        )

    @process_api_key_and_nonce
    async def withdraw(self, usdc_amount, nonce=-1, api_key_index=-1) -> (Withdraw, TxHash):
        usdc_amount = int(usdc_amount * self.USDC_TICKER_SCALE)

        tx_info, error = self.sign_withdraw(usdc_amount, nonce)
        if error is not None:
            return None, None, error
        logging.debug(f"Withdraw Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_WITHDRAW, tx_info=tx_info)
        logging.debug(f"Withdraw Send Tx Response: {api_response}")
        return Withdraw.from_json(tx_info), api_response, None

    async def create_sub_account(self, nonce=-1):
        tx_info, error = self.sign_create_sub_account(nonce)
        if error is not None:
            return None, None, error
        logging.debug(f"Create Sub Account Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_CREATE_SUB_ACCOUNT, tx_info=tx_info)
        logging.debug(f"Create Sub Account Send Tx Response: {api_response}")
        return tx_info, api_response, None

    @process_api_key_and_nonce
    async def cancel_all_orders(self, time_in_force, time, nonce=-1, api_key_index=-1):
        tx_info, error = self.sign_cancel_all_orders(time_in_force, time, nonce)
        if error is not None:
            return None, None, error
        logging.debug(f"Cancel All Orders Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_CANCEL_ALL_ORDERS, tx_info=tx_info)
        logging.debug(f"Cancel All Orders Send Tx Response: {api_response}")
        return tx_info, api_response, None

    @process_api_key_and_nonce
    async def modify_order(
        self, market_index, order_index, base_amount, price, trigger_price, nonce=-1, api_key_index=-1
    ):
        tx_info, error = self.sign_modify_order(market_index, order_index, base_amount, price, trigger_price, nonce)
        if error is not None:
            return None, None, error
        logging.debug(f"Modify Order Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_MODIFY_ORDER, tx_info=tx_info)
        logging.debug(f"Modify Order Send Tx Response: {api_response}")
        return tx_info, api_response, None

    @process_api_key_and_nonce
    async def transfer(self, eth_private_key: str, to_account_index, usdc_amount, fee, memo, nonce=-1, api_key_index=-1):
        usdc_amount = int(usdc_amount * self.USDC_TICKER_SCALE)

        tx_info, error = self.sign_transfer(eth_private_key, to_account_index, usdc_amount, fee, memo, nonce)
        if error is not None:
            return None, None, error
        logging.debug(f"Transfer Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_TRANSFER, tx_info=tx_info)
        logging.debug(f"Transfer Send Tx Response: {api_response}")
        return tx_info, api_response, None

    @process_api_key_and_nonce
    async def create_public_pool(
        self, operator_fee, initial_total_shares, min_operator_share_rate, nonce=-1, api_key_index=-1
    ):
        tx_info, error = self.sign_create_public_pool(
            operator_fee, initial_total_shares, min_operator_share_rate, nonce
        )
        if error is not None:
            return None, None, error
        logging.debug(f"Create Public Pool Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_CREATE_PUBLIC_POOL, tx_info=tx_info)
        logging.debug(f"Create Public Pool Send Tx Response: {api_response}")
        return tx_info, api_response, None

    @process_api_key_and_nonce
    async def update_public_pool(
        self, public_pool_index, status, operator_fee, min_operator_share_rate, nonce=-1, api_key_index=-1
    ):
        tx_info, error = self.sign_update_public_pool(
            public_pool_index, status, operator_fee, min_operator_share_rate, nonce
        )
        if error is not None:
            return None, None, error
        logging.debug(f"Update Public Pool Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_UPDATE_PUBLIC_POOL, tx_info=tx_info)
        logging.debug(f"Update Public Pool Send Tx Response: {api_response}")
        return tx_info, api_response, None

    @process_api_key_and_nonce
    async def mint_shares(self, public_pool_index, share_amount, nonce=-1, api_key_index=-1):
        tx_info, error = self.sign_mint_shares(public_pool_index, share_amount, nonce)
        if error is not None:
            return None, None, error
        logging.debug(f"Mint Shares Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_MINT_SHARES, tx_info=tx_info)
        logging.debug(f"Mint Shares Send Tx Response: {api_response}")
        return tx_info, api_response, None

    @process_api_key_and_nonce
    async def burn_shares(self, public_pool_index, share_amount, nonce=-1, api_key_index=-1):
        tx_info, error = self.sign_burn_shares(public_pool_index, share_amount, nonce)
        if error is not None:
            return None, None, error
        logging.debug(f"Burn Shares Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_BURN_SHARES, tx_info=tx_info)
        logging.debug(f"Burn Shares Send Tx Response: {api_response}")
        return tx_info, api_response, None
    
    @process_api_key_and_nonce
    async def update_leverage(self, market_index, margin_mode, leverage, nonce=-1, api_key_index=-1):
        imf = int(10_000 / leverage)
        tx_info, error = self.sign_update_leverage(market_index, imf, margin_mode, nonce)

        if error is not None:
            return None, None, error
        logging.debug(f"Update Leverage Tx Info: {tx_info}")

        api_response = await self.send_tx(tx_type=self.TX_TYPE_UPDATE_LEVERAGE, tx_info=tx_info)
        logging.debug(f"Update Leverage Tx Response: {api_response}")
        return tx_info, api_response, None


    async def send_tx(self, tx_type: StrictInt, tx_info: str) -> RespSendTx:
        if tx_info[0] != "{":
            raise Exception(tx_info)
        return await self.tx_api.send_tx(tx_type=tx_type, tx_info=tx_info)

    async def close(self):
        await self.api_client.close()

    @staticmethod
    def are_keys_equal(key1, key2) -> bool:
        start_index1, start_index2 = 0, 0
        if key1.startswith("0x"):
            start_index1 = 2
        if key2.startswith("0x"):
            start_index2 = 2
        return key1[start_index1:] == key2[start_index2:]



================================================================================
File: .\lighter\ws_client.py
================================================================================

import json
from websockets.sync.client import connect
from websockets.client import connect as connect_async
from lighter.configuration import Configuration


class WsClient:
    def __init__(
        self,
        host=None,
        path="/stream",
        order_book_ids=[],
        account_ids=[],
        on_order_book_update=print,
        on_account_update=print,
    ):
        if host is None:
            host = Configuration.get_default().host.replace("https://", "")

        self.base_url = f"wss://{host}{path}"

        self.subscriptions = {
            "order_books": order_book_ids,
            "accounts": account_ids,
        }

        if len(order_book_ids) == 0 and len(account_ids) == 0:
            raise Exception("No subscriptions provided.")

        self.order_book_states = {}
        self.account_states = {}

        self.on_order_book_update = on_order_book_update
        self.on_account_update = on_account_update

        self.ws = None

    def on_message(self, ws, message):
        if isinstance(message, str):
            message = json.loads(message)

        message_type = message.get("type")

        if message_type == "connected":
            self.handle_connected(ws)
        elif message_type == "subscribed/order_book":
            self.handle_subscribed_order_book(message)
        elif message_type == "update/order_book":
            self.handle_update_order_book(message)
        elif message_type == "subscribed/account_all":
            self.handle_subscribed_account(message)
        elif message_type == "update/account_all":
            self.handle_update_account(message)
        else:
            self.handle_unhandled_message(message)

    async def on_message_async(self, ws, message):
        message = json.loads(message)
        message_type = message.get("type")

        if message_type == "connected":
            await self.handle_connected_async(ws)
        else:
            self.on_message(ws, message)

    def handle_connected(self, ws):
        for market_id in self.subscriptions["order_books"]:
            ws.send(
                json.dumps({"type": "subscribe", "channel": f"order_book/{market_id}"})
            )
        for account_id in self.subscriptions["accounts"]:
            ws.send(
                json.dumps(
                    {"type": "subscribe", "channel": f"account_all/{account_id}"}
                )
            )

    async def handle_connected_async(self, ws):
        for market_id in self.subscriptions["order_books"]:
            await ws.send(
                json.dumps({"type": "subscribe", "channel": f"order_book/{market_id}"})
            )
        for account_id in self.subscriptions["accounts"]:
            await ws.send(
                json.dumps(
                    {"type": "subscribe", "channel": f"account_all/{account_id}"}
                )
            )

    def handle_subscribed_order_book(self, message):
        market_id = message["channel"].split(":")[1]
        self.order_book_states[market_id] = message["order_book"]
        if self.on_order_book_update:
            self.on_order_book_update(market_id, self.order_book_states[market_id])

    def handle_update_order_book(self, message):
        market_id = message["channel"].split(":")[1]
        self.update_order_book_state(market_id, message["order_book"])
        if self.on_order_book_update:
            self.on_order_book_update(market_id, self.order_book_states[market_id])

    def update_order_book_state(self, market_id, order_book):
        self.update_orders(
            order_book["asks"], self.order_book_states[market_id]["asks"]
        )
        self.update_orders(
            order_book["bids"], self.order_book_states[market_id]["bids"]
        )

    def update_orders(self, new_orders, existing_orders):
        for new_order in new_orders:
            is_new_order = True
            for existing_order in existing_orders:
                if new_order["price"] == existing_order["price"]:
                    is_new_order = False
                    existing_order["size"] = new_order["size"]
                    if float(new_order["size"]) == 0:
                        existing_orders.remove(existing_order)
                    break
            if is_new_order:
                existing_orders.append(new_order)

        existing_orders = [
            order for order in existing_orders if float(order["size"]) > 0
        ]

    def handle_subscribed_account(self, message):
        account_id = message["channel"].split(":")[1]
        self.account_states[account_id] = message
        if self.on_account_update:
            self.on_account_update(account_id, self.account_states[account_id])

    def handle_update_account(self, message):
        account_id = message["channel"].split(":")[1]
        self.account_states[account_id] = message
        if self.on_account_update:
            self.on_account_update(account_id, self.account_states[account_id])

    def handle_unhandled_message(self, message):
        raise Exception(f"Unhandled message: {message}")

    def on_error(self, ws, error):
        raise Exception(f"Error: {error}")

    def on_close(self, ws, close_status_code, close_msg):
        raise Exception(f"Closed: {close_status_code} {close_msg}")

    def run(self):
        ws = connect(self.base_url)
        self.ws = ws

        for message in ws:
            self.on_message(ws, message)

    async def run_async(self):
        ws = await connect_async(self.base_url)
        self.ws = ws

        async for message in ws:
            await self.on_message_async(ws, message)



================================================================================
File: .\lighter\__init__.py
================================================================================

# coding: utf-8

# flake8: noqa

"""
    zkLighter API

    Public APIs for Lighter

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


__version__ = "1.0.0"

# import apis into sdk package
from lighter.api.account_api import AccountApi
from lighter.api.announcement_api import AnnouncementApi
from lighter.api.block_api import BlockApi
from lighter.api.bridge_api import BridgeApi
from lighter.api.candlestick_api import CandlestickApi
from lighter.api.funding_api import FundingApi
from lighter.api.info_api import InfoApi
from lighter.api.notification_api import NotificationApi
from lighter.api.order_api import OrderApi
from lighter.api.referral_api import ReferralApi
from lighter.api.root_api import RootApi
from lighter.api.transaction_api import TransactionApi

# import ApiClient
from lighter.api_response import ApiResponse
from lighter.api_client import ApiClient
from lighter.configuration import Configuration
from lighter.exceptions import OpenApiException
from lighter.exceptions import ApiTypeError
from lighter.exceptions import ApiValueError
from lighter.exceptions import ApiKeyError
from lighter.exceptions import ApiAttributeError
from lighter.exceptions import ApiException

# import models into sdk package
from lighter.models.account import Account
from lighter.models.account_api_keys import AccountApiKeys
from lighter.models.account_limits import AccountLimits
from lighter.models.account_margin_stats import AccountMarginStats
from lighter.models.account_market_stats import AccountMarketStats
from lighter.models.account_metadata import AccountMetadata
from lighter.models.account_metadatas import AccountMetadatas
from lighter.models.account_pn_l import AccountPnL
from lighter.models.account_position import AccountPosition
from lighter.models.account_stats import AccountStats
from lighter.models.account_trade_stats import AccountTradeStats
from lighter.models.announcement import Announcement
from lighter.models.announcements import Announcements
from lighter.models.api_key import ApiKey
from lighter.models.block import Block
from lighter.models.blocks import Blocks
from lighter.models.bridge_supported_network import BridgeSupportedNetwork
from lighter.models.candlestick import Candlestick
from lighter.models.candlesticks import Candlesticks
from lighter.models.contract_address import ContractAddress
from lighter.models.current_height import CurrentHeight
from lighter.models.cursor import Cursor
from lighter.models.daily_return import DailyReturn
from lighter.models.deposit_history import DepositHistory
from lighter.models.deposit_history_item import DepositHistoryItem
from lighter.models.detailed_account import DetailedAccount
from lighter.models.detailed_accounts import DetailedAccounts
from lighter.models.detailed_candlestick import DetailedCandlestick
from lighter.models.enriched_tx import EnrichedTx
from lighter.models.exchange_stats import ExchangeStats
from lighter.models.export_data import ExportData
from lighter.models.funding import Funding
from lighter.models.funding_rate import FundingRate
from lighter.models.funding_rates import FundingRates
from lighter.models.fundings import Fundings
from lighter.models.l1_metadata import L1Metadata
from lighter.models.l1_provider_info import L1ProviderInfo
from lighter.models.liq_trade import LiqTrade
from lighter.models.liquidation import Liquidation
from lighter.models.liquidation_info import LiquidationInfo
from lighter.models.liquidation_infos import LiquidationInfos
from lighter.models.market_info import MarketInfo
from lighter.models.next_nonce import NextNonce
from lighter.models.order import Order
from lighter.models.order_book import OrderBook
from lighter.models.order_book_depth import OrderBookDepth
from lighter.models.order_book_detail import OrderBookDetail
from lighter.models.order_book_details import OrderBookDetails
from lighter.models.order_book_orders import OrderBookOrders
from lighter.models.order_book_stats import OrderBookStats
from lighter.models.order_books import OrderBooks
from lighter.models.orders import Orders
from lighter.models.pn_l_entry import PnLEntry
from lighter.models.position_funding import PositionFunding
from lighter.models.position_fundings import PositionFundings
from lighter.models.price_level import PriceLevel
from lighter.models.public_pool import PublicPool
from lighter.models.public_pool_info import PublicPoolInfo
from lighter.models.public_pool_metadata import PublicPoolMetadata
from lighter.models.public_pool_share import PublicPoolShare
from lighter.models.public_pools import PublicPools
from lighter.models.referral_point_entry import ReferralPointEntry
from lighter.models.referral_points import ReferralPoints
from lighter.models.req_export_data import ReqExportData
from lighter.models.req_get_account import ReqGetAccount
from lighter.models.req_get_account_active_orders import ReqGetAccountActiveOrders
from lighter.models.req_get_account_api_keys import ReqGetAccountApiKeys
from lighter.models.req_get_account_by_l1_address import ReqGetAccountByL1Address
from lighter.models.req_get_account_inactive_orders import ReqGetAccountInactiveOrders
from lighter.models.req_get_account_limits import ReqGetAccountLimits
from lighter.models.req_get_account_metadata import ReqGetAccountMetadata
from lighter.models.req_get_account_pn_l import ReqGetAccountPnL
from lighter.models.req_get_account_txs import ReqGetAccountTxs
from lighter.models.req_get_block import ReqGetBlock
from lighter.models.req_get_block_txs import ReqGetBlockTxs
from lighter.models.req_get_by_account import ReqGetByAccount
from lighter.models.req_get_candlesticks import ReqGetCandlesticks
from lighter.models.req_get_deposit_history import ReqGetDepositHistory
from lighter.models.req_get_fast_withdraw_info import ReqGetFastWithdrawInfo
from lighter.models.req_get_fundings import ReqGetFundings
from lighter.models.req_get_l1_metadata import ReqGetL1Metadata
from lighter.models.req_get_l1_tx import ReqGetL1Tx
from lighter.models.req_get_latest_deposit import ReqGetLatestDeposit
from lighter.models.req_get_liquidation_infos import ReqGetLiquidationInfos
from lighter.models.req_get_next_nonce import ReqGetNextNonce
from lighter.models.req_get_order_book_details import ReqGetOrderBookDetails
from lighter.models.req_get_order_book_orders import ReqGetOrderBookOrders
from lighter.models.req_get_order_books import ReqGetOrderBooks
from lighter.models.req_get_position_funding import ReqGetPositionFunding
from lighter.models.req_get_public_pools import ReqGetPublicPools
from lighter.models.req_get_public_pools_metadata import ReqGetPublicPoolsMetadata
from lighter.models.req_get_range_with_cursor import ReqGetRangeWithCursor
from lighter.models.req_get_range_with_index import ReqGetRangeWithIndex
from lighter.models.req_get_range_with_index_sortable import ReqGetRangeWithIndexSortable
from lighter.models.req_get_recent_trades import ReqGetRecentTrades
from lighter.models.req_get_referral_points import ReqGetReferralPoints
from lighter.models.req_get_trades import ReqGetTrades
from lighter.models.req_get_transfer_fee_info import ReqGetTransferFeeInfo
from lighter.models.req_get_transfer_history import ReqGetTransferHistory
from lighter.models.req_get_tx import ReqGetTx
from lighter.models.req_get_withdraw_history import ReqGetWithdrawHistory
from lighter.models.resp_change_account_tier import RespChangeAccountTier
from lighter.models.resp_get_fast_bridge_info import RespGetFastBridgeInfo
from lighter.models.resp_public_pools_metadata import RespPublicPoolsMetadata
from lighter.models.resp_send_tx import RespSendTx
from lighter.models.resp_send_tx_batch import RespSendTxBatch
from lighter.models.resp_withdrawal_delay import RespWithdrawalDelay
from lighter.models.result_code import ResultCode
from lighter.models.risk_info import RiskInfo
from lighter.models.risk_parameters import RiskParameters
from lighter.models.share_price import SharePrice
from lighter.models.simple_order import SimpleOrder
from lighter.models.status import Status
from lighter.models.sub_accounts import SubAccounts
from lighter.models.ticker import Ticker
from lighter.models.trade import Trade
from lighter.models.trades import Trades
from lighter.models.transfer_fee_info import TransferFeeInfo
from lighter.models.transfer_history import TransferHistory
from lighter.models.transfer_history_item import TransferHistoryItem
from lighter.models.tx import Tx
from lighter.models.tx_hash import TxHash
from lighter.models.tx_hashes import TxHashes
from lighter.models.txs import Txs
from lighter.models.validator_info import ValidatorInfo
from lighter.models.withdraw_history import WithdrawHistory
from lighter.models.withdraw_history_item import WithdrawHistoryItem
from lighter.models.zk_lighter_info import ZkLighterInfo
from lighter.ws_client import WsClient
from lighter.signer_client import SignerClient, create_api_key


================================================================================
File: .\lighter\api\account_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from lighter.models.account_api_keys import AccountApiKeys
from lighter.models.account_limits import AccountLimits
from lighter.models.account_metadatas import AccountMetadatas
from lighter.models.account_pn_l import AccountPnL
from lighter.models.detailed_accounts import DetailedAccounts
from lighter.models.l1_metadata import L1Metadata
from lighter.models.liquidation_infos import LiquidationInfos
from lighter.models.position_fundings import PositionFundings
from lighter.models.public_pools import PublicPools
from lighter.models.resp_change_account_tier import RespChangeAccountTier
from lighter.models.resp_public_pools_metadata import RespPublicPoolsMetadata
from lighter.models.sub_accounts import SubAccounts

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class AccountApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def account(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DetailedAccounts:
        """account

        Get account by account's index. <br>More details about account index: [Account Index](https://apidocs.lighter.xyz/docs/account-index)<hr>**Response Description:**<br><br>1) **Status:** 1 is active 0 is inactive.<br>2) **Collateral:** The amount of collateral in the account.<hr>**Position Details Description:**<br>1) **OOC:** Open order count in that market.<br>2) **Sign:** 1 for Long, -1 for Short.<br>3) **Position:** The amount of position in that market.<br>4) **Avg Entry Price:** The average entry price of the position.<br>5) **Position Value:** The value of the position.<br>6) **Unrealized PnL:** The unrealized profit and loss of the position.<br>7) **Realized PnL:** The realized profit and loss of the position.

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DetailedAccounts",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def account_with_http_info(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DetailedAccounts]:
        """account

        Get account by account's index. <br>More details about account index: [Account Index](https://apidocs.lighter.xyz/docs/account-index)<hr>**Response Description:**<br><br>1) **Status:** 1 is active 0 is inactive.<br>2) **Collateral:** The amount of collateral in the account.<hr>**Position Details Description:**<br>1) **OOC:** Open order count in that market.<br>2) **Sign:** 1 for Long, -1 for Short.<br>3) **Position:** The amount of position in that market.<br>4) **Avg Entry Price:** The average entry price of the position.<br>5) **Position Value:** The value of the position.<br>6) **Unrealized PnL:** The unrealized profit and loss of the position.<br>7) **Realized PnL:** The realized profit and loss of the position.

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DetailedAccounts",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def account_without_preload_content(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """account

        Get account by account's index. <br>More details about account index: [Account Index](https://apidocs.lighter.xyz/docs/account-index)<hr>**Response Description:**<br><br>1) **Status:** 1 is active 0 is inactive.<br>2) **Collateral:** The amount of collateral in the account.<hr>**Position Details Description:**<br>1) **OOC:** Open order count in that market.<br>2) **Sign:** 1 for Long, -1 for Short.<br>3) **Position:** The amount of position in that market.<br>4) **Avg Entry Price:** The average entry price of the position.<br>5) **Position Value:** The value of the position.<br>6) **Unrealized PnL:** The unrealized profit and loss of the position.<br>7) **Realized PnL:** The realized profit and loss of the position.

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DetailedAccounts",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _account_serialize(
        self,
        by,
        value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if by is not None:
            
            _query_params.append(('by', by))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/account',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def account_limits(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountLimits:
        """accountLimits

        Get account limits

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_limits_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLimits",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def account_limits_with_http_info(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountLimits]:
        """accountLimits

        Get account limits

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_limits_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLimits",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def account_limits_without_preload_content(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accountLimits

        Get account limits

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_limits_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLimits",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _account_limits_serialize(
        self,
        account_index,
        authorization,
        auth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/accountLimits',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def account_metadata(
        self,
        by: StrictStr,
        value: StrictStr,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountMetadatas:
        """accountMetadata

        Get account metadatas

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_metadata_serialize(
            by=by,
            value=value,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountMetadatas",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def account_metadata_with_http_info(
        self,
        by: StrictStr,
        value: StrictStr,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountMetadatas]:
        """accountMetadata

        Get account metadatas

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_metadata_serialize(
            by=by,
            value=value,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountMetadatas",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def account_metadata_without_preload_content(
        self,
        by: StrictStr,
        value: StrictStr,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accountMetadata

        Get account metadatas

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_metadata_serialize(
            by=by,
            value=value,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountMetadatas",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _account_metadata_serialize(
        self,
        by,
        value,
        authorization,
        auth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if by is not None:
            
            _query_params.append(('by', by))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/accountMetadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def accounts_by_l1_address(
        self,
        l1_address: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SubAccounts:
        """accountsByL1Address

        Get accounts by l1_address returns all accounts associated with the given L1 address

        :param l1_address: (required)
        :type l1_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accounts_by_l1_address_serialize(
            l1_address=l1_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubAccounts",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def accounts_by_l1_address_with_http_info(
        self,
        l1_address: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SubAccounts]:
        """accountsByL1Address

        Get accounts by l1_address returns all accounts associated with the given L1 address

        :param l1_address: (required)
        :type l1_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accounts_by_l1_address_serialize(
            l1_address=l1_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubAccounts",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def accounts_by_l1_address_without_preload_content(
        self,
        l1_address: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accountsByL1Address

        Get accounts by l1_address returns all accounts associated with the given L1 address

        :param l1_address: (required)
        :type l1_address: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._accounts_by_l1_address_serialize(
            l1_address=l1_address,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SubAccounts",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _accounts_by_l1_address_serialize(
        self,
        l1_address,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if l1_address is not None:
            
            _query_params.append(('l1_address', l1_address))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/accountsByL1Address',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def apikeys(
        self,
        account_index: StrictInt,
        api_key_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountApiKeys:
        """apikeys

        Get account api key. Set `api_key_index` to 255 to retrieve all api keys associated with the account.

        :param account_index: (required)
        :type account_index: int
        :param api_key_index:
        :type api_key_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apikeys_serialize(
            account_index=account_index,
            api_key_index=api_key_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountApiKeys",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def apikeys_with_http_info(
        self,
        account_index: StrictInt,
        api_key_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountApiKeys]:
        """apikeys

        Get account api key. Set `api_key_index` to 255 to retrieve all api keys associated with the account.

        :param account_index: (required)
        :type account_index: int
        :param api_key_index:
        :type api_key_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apikeys_serialize(
            account_index=account_index,
            api_key_index=api_key_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountApiKeys",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def apikeys_without_preload_content(
        self,
        account_index: StrictInt,
        api_key_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """apikeys

        Get account api key. Set `api_key_index` to 255 to retrieve all api keys associated with the account.

        :param account_index: (required)
        :type account_index: int
        :param api_key_index:
        :type api_key_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._apikeys_serialize(
            account_index=account_index,
            api_key_index=api_key_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountApiKeys",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _apikeys_serialize(
        self,
        account_index,
        api_key_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if api_key_index is not None:
            
            _query_params.append(('api_key_index', api_key_index))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/apikeys',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def change_account_tier(
        self,
        account_index: StrictInt,
        new_tier: StrictStr,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RespChangeAccountTier:
        """changeAccountTier

        Change account tier

        :param account_index: (required)
        :type account_index: int
        :param new_tier: (required)
        :type new_tier: str
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_account_tier_serialize(
            account_index=account_index,
            new_tier=new_tier,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespChangeAccountTier",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def change_account_tier_with_http_info(
        self,
        account_index: StrictInt,
        new_tier: StrictStr,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RespChangeAccountTier]:
        """changeAccountTier

        Change account tier

        :param account_index: (required)
        :type account_index: int
        :param new_tier: (required)
        :type new_tier: str
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_account_tier_serialize(
            account_index=account_index,
            new_tier=new_tier,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespChangeAccountTier",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def change_account_tier_without_preload_content(
        self,
        account_index: StrictInt,
        new_tier: StrictStr,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """changeAccountTier

        Change account tier

        :param account_index: (required)
        :type account_index: int
        :param new_tier: (required)
        :type new_tier: str
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._change_account_tier_serialize(
            account_index=account_index,
            new_tier=new_tier,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespChangeAccountTier",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _change_account_tier_serialize(
        self,
        account_index,
        new_tier,
        authorization,
        auth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        if auth is not None:
            _form_params.append(('auth', auth))
        if account_index is not None:
            _form_params.append(('account_index', account_index))
        if new_tier is not None:
            _form_params.append(('new_tier', new_tier))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/changeAccountTier',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def l1_metadata(
        self,
        l1_address: StrictStr,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> L1Metadata:
        """l1Metadata

        Get L1 metadata

        :param l1_address: (required)
        :type l1_address: str
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._l1_metadata_serialize(
            l1_address=l1_address,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L1Metadata",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def l1_metadata_with_http_info(
        self,
        l1_address: StrictStr,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[L1Metadata]:
        """l1Metadata

        Get L1 metadata

        :param l1_address: (required)
        :type l1_address: str
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._l1_metadata_serialize(
            l1_address=l1_address,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L1Metadata",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def l1_metadata_without_preload_content(
        self,
        l1_address: StrictStr,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """l1Metadata

        Get L1 metadata

        :param l1_address: (required)
        :type l1_address: str
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._l1_metadata_serialize(
            l1_address=l1_address,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "L1Metadata",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _l1_metadata_serialize(
        self,
        l1_address,
        authorization,
        auth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if l1_address is not None:
            
            _query_params.append(('l1_address', l1_address))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/l1Metadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def liquidations(
        self,
        account_index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        market_id: Optional[StrictInt] = None,
        cursor: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LiquidationInfos:
        """liquidations

        Get liquidation infos

        :param account_index: (required)
        :type account_index: int
        :param limit: (required)
        :type limit: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param market_id:
        :type market_id: int
        :param cursor:
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidations_serialize(
            account_index=account_index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LiquidationInfos",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def liquidations_with_http_info(
        self,
        account_index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        market_id: Optional[StrictInt] = None,
        cursor: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LiquidationInfos]:
        """liquidations

        Get liquidation infos

        :param account_index: (required)
        :type account_index: int
        :param limit: (required)
        :type limit: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param market_id:
        :type market_id: int
        :param cursor:
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidations_serialize(
            account_index=account_index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LiquidationInfos",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def liquidations_without_preload_content(
        self,
        account_index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        market_id: Optional[StrictInt] = None,
        cursor: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """liquidations

        Get liquidation infos

        :param account_index: (required)
        :type account_index: int
        :param limit: (required)
        :type limit: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param market_id:
        :type market_id: int
        :param cursor:
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._liquidations_serialize(
            account_index=account_index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LiquidationInfos",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _liquidations_serialize(
        self,
        account_index,
        limit,
        authorization,
        auth,
        market_id,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/liquidations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def pnl(
        self,
        by: StrictStr,
        value: StrictStr,
        resolution: StrictStr,
        start_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        end_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        count_back: StrictInt,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        ignore_transfers: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountPnL:
        """pnl

        Get account PnL chart

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param resolution: (required)
        :type resolution: str
        :param start_timestamp: (required)
        :type start_timestamp: int
        :param end_timestamp: (required)
        :type end_timestamp: int
        :param count_back: (required)
        :type count_back: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param ignore_transfers:
        :type ignore_transfers: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pnl_serialize(
            by=by,
            value=value,
            resolution=resolution,
            start_timestamp=start_timestamp,
            end_timestamp=end_timestamp,
            count_back=count_back,
            authorization=authorization,
            auth=auth,
            ignore_transfers=ignore_transfers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountPnL",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def pnl_with_http_info(
        self,
        by: StrictStr,
        value: StrictStr,
        resolution: StrictStr,
        start_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        end_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        count_back: StrictInt,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        ignore_transfers: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountPnL]:
        """pnl

        Get account PnL chart

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param resolution: (required)
        :type resolution: str
        :param start_timestamp: (required)
        :type start_timestamp: int
        :param end_timestamp: (required)
        :type end_timestamp: int
        :param count_back: (required)
        :type count_back: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param ignore_transfers:
        :type ignore_transfers: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pnl_serialize(
            by=by,
            value=value,
            resolution=resolution,
            start_timestamp=start_timestamp,
            end_timestamp=end_timestamp,
            count_back=count_back,
            authorization=authorization,
            auth=auth,
            ignore_transfers=ignore_transfers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountPnL",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def pnl_without_preload_content(
        self,
        by: StrictStr,
        value: StrictStr,
        resolution: StrictStr,
        start_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        end_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        count_back: StrictInt,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        ignore_transfers: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """pnl

        Get account PnL chart

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param resolution: (required)
        :type resolution: str
        :param start_timestamp: (required)
        :type start_timestamp: int
        :param end_timestamp: (required)
        :type end_timestamp: int
        :param count_back: (required)
        :type count_back: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param ignore_transfers:
        :type ignore_transfers: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._pnl_serialize(
            by=by,
            value=value,
            resolution=resolution,
            start_timestamp=start_timestamp,
            end_timestamp=end_timestamp,
            count_back=count_back,
            authorization=authorization,
            auth=auth,
            ignore_transfers=ignore_transfers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountPnL",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _pnl_serialize(
        self,
        by,
        value,
        resolution,
        start_timestamp,
        end_timestamp,
        count_back,
        authorization,
        auth,
        ignore_transfers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if by is not None:
            
            _query_params.append(('by', by))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if start_timestamp is not None:
            
            _query_params.append(('start_timestamp', start_timestamp))
            
        if end_timestamp is not None:
            
            _query_params.append(('end_timestamp', end_timestamp))
            
        if count_back is not None:
            
            _query_params.append(('count_back', count_back))
            
        if ignore_transfers is not None:
            
            _query_params.append(('ignore_transfers', ignore_transfers))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/pnl',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def position_funding(
        self,
        account_index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        market_id: Optional[StrictInt] = None,
        cursor: Optional[StrictStr] = None,
        side: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PositionFundings:
        """positionFunding

        Get accounts position fundings

        :param account_index: (required)
        :type account_index: int
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param market_id:
        :type market_id: int
        :param cursor:
        :type cursor: str
        :param side:
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._position_funding_serialize(
            account_index=account_index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            cursor=cursor,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PositionFundings",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def position_funding_with_http_info(
        self,
        account_index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        market_id: Optional[StrictInt] = None,
        cursor: Optional[StrictStr] = None,
        side: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PositionFundings]:
        """positionFunding

        Get accounts position fundings

        :param account_index: (required)
        :type account_index: int
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param market_id:
        :type market_id: int
        :param cursor:
        :type cursor: str
        :param side:
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._position_funding_serialize(
            account_index=account_index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            cursor=cursor,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PositionFundings",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def position_funding_without_preload_content(
        self,
        account_index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        market_id: Optional[StrictInt] = None,
        cursor: Optional[StrictStr] = None,
        side: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """positionFunding

        Get accounts position fundings

        :param account_index: (required)
        :type account_index: int
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param market_id:
        :type market_id: int
        :param cursor:
        :type cursor: str
        :param side:
        :type side: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._position_funding_serialize(
            account_index=account_index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            cursor=cursor,
            side=side,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PositionFundings",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _position_funding_serialize(
        self,
        account_index,
        limit,
        authorization,
        auth,
        market_id,
        cursor,
        side,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if side is not None:
            
            _query_params.append(('side', side))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/positionFunding',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def public_pools(
        self,
        index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        account_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PublicPools:
        """publicPools

        Get public pools

        :param index: (required)
        :type index: int
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param filter:
        :type filter: str
        :param account_index:
        :type account_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._public_pools_serialize(
            index=index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            filter=filter,
            account_index=account_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PublicPools",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def public_pools_with_http_info(
        self,
        index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        account_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PublicPools]:
        """publicPools

        Get public pools

        :param index: (required)
        :type index: int
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param filter:
        :type filter: str
        :param account_index:
        :type account_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._public_pools_serialize(
            index=index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            filter=filter,
            account_index=account_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PublicPools",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def public_pools_without_preload_content(
        self,
        index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        account_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """publicPools

        Get public pools

        :param index: (required)
        :type index: int
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param filter:
        :type filter: str
        :param account_index:
        :type account_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._public_pools_serialize(
            index=index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            filter=filter,
            account_index=account_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PublicPools",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _public_pools_serialize(
        self,
        index,
        limit,
        authorization,
        auth,
        filter,
        account_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if index is not None:
            
            _query_params.append(('index', index))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/publicPools',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def public_pools_metadata(
        self,
        index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        account_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RespPublicPoolsMetadata:
        """publicPoolsMetadata

        Get public pools metadata

        :param index: (required)
        :type index: int
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param filter:
        :type filter: str
        :param account_index:
        :type account_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._public_pools_metadata_serialize(
            index=index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            filter=filter,
            account_index=account_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespPublicPoolsMetadata",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def public_pools_metadata_with_http_info(
        self,
        index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        account_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RespPublicPoolsMetadata]:
        """publicPoolsMetadata

        Get public pools metadata

        :param index: (required)
        :type index: int
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param filter:
        :type filter: str
        :param account_index:
        :type account_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._public_pools_metadata_serialize(
            index=index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            filter=filter,
            account_index=account_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespPublicPoolsMetadata",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def public_pools_metadata_without_preload_content(
        self,
        index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        account_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """publicPoolsMetadata

        Get public pools metadata

        :param index: (required)
        :type index: int
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param filter:
        :type filter: str
        :param account_index:
        :type account_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._public_pools_metadata_serialize(
            index=index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            filter=filter,
            account_index=account_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespPublicPoolsMetadata",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _public_pools_metadata_serialize(
        self,
        index,
        limit,
        authorization,
        auth,
        filter,
        account_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if index is not None:
            
            _query_params.append(('index', index))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/publicPoolsMetadata',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\announcement_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from lighter.models.announcements import Announcements

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class AnnouncementApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def announcement(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Announcements:
        """announcement

        Get announcement

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._announcement_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Announcements",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def announcement_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Announcements]:
        """announcement

        Get announcement

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._announcement_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Announcements",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def announcement_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """announcement

        Get announcement

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._announcement_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Announcements",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _announcement_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/announcement',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\block_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from lighter.models.blocks import Blocks
from lighter.models.current_height import CurrentHeight

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class BlockApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def block(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Blocks:
        """block

        Get block by its height or commitment

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._block_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Blocks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def block_with_http_info(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Blocks]:
        """block

        Get block by its height or commitment

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._block_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Blocks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def block_without_preload_content(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """block

        Get block by its height or commitment

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._block_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Blocks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _block_serialize(
        self,
        by,
        value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if by is not None:
            
            _query_params.append(('by', by))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/block',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def blocks(
        self,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        index: Optional[StrictInt] = None,
        sort: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Blocks:
        """blocks

        Get blocks

        :param limit: (required)
        :type limit: int
        :param index:
        :type index: int
        :param sort:
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._blocks_serialize(
            limit=limit,
            index=index,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Blocks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def blocks_with_http_info(
        self,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        index: Optional[StrictInt] = None,
        sort: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Blocks]:
        """blocks

        Get blocks

        :param limit: (required)
        :type limit: int
        :param index:
        :type index: int
        :param sort:
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._blocks_serialize(
            limit=limit,
            index=index,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Blocks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def blocks_without_preload_content(
        self,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        index: Optional[StrictInt] = None,
        sort: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """blocks

        Get blocks

        :param limit: (required)
        :type limit: int
        :param index:
        :type index: int
        :param sort:
        :type sort: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._blocks_serialize(
            limit=limit,
            index=index,
            sort=sort,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Blocks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _blocks_serialize(
        self,
        limit,
        index,
        sort,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            
            _query_params.append(('index', index))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort is not None:
            
            _query_params.append(('sort', sort))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/blocks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def current_height(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CurrentHeight:
        """currentHeight

        Get current height

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._current_height_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CurrentHeight",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def current_height_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CurrentHeight]:
        """currentHeight

        Get current height

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._current_height_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CurrentHeight",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def current_height_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """currentHeight

        Get current height

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._current_height_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CurrentHeight",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _current_height_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/currentHeight',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\bridge_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from lighter.models.resp_get_fast_bridge_info import RespGetFastBridgeInfo

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class BridgeApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def fastbridge_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RespGetFastBridgeInfo:
        """fastbridge_info

        Get fast bridge info

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fastbridge_info_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespGetFastBridgeInfo",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def fastbridge_info_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RespGetFastBridgeInfo]:
        """fastbridge_info

        Get fast bridge info

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fastbridge_info_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespGetFastBridgeInfo",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def fastbridge_info_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """fastbridge_info

        Get fast bridge info

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fastbridge_info_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespGetFastBridgeInfo",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fastbridge_info_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fastbridge/info',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\candlestick_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from lighter.models.candlesticks import Candlesticks
from lighter.models.fundings import Fundings

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class CandlestickApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def candlesticks(
        self,
        market_id: StrictInt,
        resolution: StrictStr,
        start_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        end_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        count_back: StrictInt,
        set_timestamp_to_end: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Candlesticks:
        """candlesticks

        Get candlesticks

        :param market_id: (required)
        :type market_id: int
        :param resolution: (required)
        :type resolution: str
        :param start_timestamp: (required)
        :type start_timestamp: int
        :param end_timestamp: (required)
        :type end_timestamp: int
        :param count_back: (required)
        :type count_back: int
        :param set_timestamp_to_end:
        :type set_timestamp_to_end: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._candlesticks_serialize(
            market_id=market_id,
            resolution=resolution,
            start_timestamp=start_timestamp,
            end_timestamp=end_timestamp,
            count_back=count_back,
            set_timestamp_to_end=set_timestamp_to_end,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Candlesticks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def candlesticks_with_http_info(
        self,
        market_id: StrictInt,
        resolution: StrictStr,
        start_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        end_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        count_back: StrictInt,
        set_timestamp_to_end: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Candlesticks]:
        """candlesticks

        Get candlesticks

        :param market_id: (required)
        :type market_id: int
        :param resolution: (required)
        :type resolution: str
        :param start_timestamp: (required)
        :type start_timestamp: int
        :param end_timestamp: (required)
        :type end_timestamp: int
        :param count_back: (required)
        :type count_back: int
        :param set_timestamp_to_end:
        :type set_timestamp_to_end: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._candlesticks_serialize(
            market_id=market_id,
            resolution=resolution,
            start_timestamp=start_timestamp,
            end_timestamp=end_timestamp,
            count_back=count_back,
            set_timestamp_to_end=set_timestamp_to_end,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Candlesticks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def candlesticks_without_preload_content(
        self,
        market_id: StrictInt,
        resolution: StrictStr,
        start_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        end_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        count_back: StrictInt,
        set_timestamp_to_end: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """candlesticks

        Get candlesticks

        :param market_id: (required)
        :type market_id: int
        :param resolution: (required)
        :type resolution: str
        :param start_timestamp: (required)
        :type start_timestamp: int
        :param end_timestamp: (required)
        :type end_timestamp: int
        :param count_back: (required)
        :type count_back: int
        :param set_timestamp_to_end:
        :type set_timestamp_to_end: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._candlesticks_serialize(
            market_id=market_id,
            resolution=resolution,
            start_timestamp=start_timestamp,
            end_timestamp=end_timestamp,
            count_back=count_back,
            set_timestamp_to_end=set_timestamp_to_end,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Candlesticks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _candlesticks_serialize(
        self,
        market_id,
        resolution,
        start_timestamp,
        end_timestamp,
        count_back,
        set_timestamp_to_end,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if start_timestamp is not None:
            
            _query_params.append(('start_timestamp', start_timestamp))
            
        if end_timestamp is not None:
            
            _query_params.append(('end_timestamp', end_timestamp))
            
        if count_back is not None:
            
            _query_params.append(('count_back', count_back))
            
        if set_timestamp_to_end is not None:
            
            _query_params.append(('set_timestamp_to_end', set_timestamp_to_end))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/candlesticks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def fundings(
        self,
        market_id: StrictInt,
        resolution: StrictStr,
        start_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        end_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        count_back: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Fundings:
        """fundings

        Get fundings

        :param market_id: (required)
        :type market_id: int
        :param resolution: (required)
        :type resolution: str
        :param start_timestamp: (required)
        :type start_timestamp: int
        :param end_timestamp: (required)
        :type end_timestamp: int
        :param count_back: (required)
        :type count_back: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fundings_serialize(
            market_id=market_id,
            resolution=resolution,
            start_timestamp=start_timestamp,
            end_timestamp=end_timestamp,
            count_back=count_back,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Fundings",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def fundings_with_http_info(
        self,
        market_id: StrictInt,
        resolution: StrictStr,
        start_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        end_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        count_back: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Fundings]:
        """fundings

        Get fundings

        :param market_id: (required)
        :type market_id: int
        :param resolution: (required)
        :type resolution: str
        :param start_timestamp: (required)
        :type start_timestamp: int
        :param end_timestamp: (required)
        :type end_timestamp: int
        :param count_back: (required)
        :type count_back: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fundings_serialize(
            market_id=market_id,
            resolution=resolution,
            start_timestamp=start_timestamp,
            end_timestamp=end_timestamp,
            count_back=count_back,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Fundings",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def fundings_without_preload_content(
        self,
        market_id: StrictInt,
        resolution: StrictStr,
        start_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        end_timestamp: Annotated[int, Field(le=5000000000000, strict=True, ge=0)],
        count_back: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """fundings

        Get fundings

        :param market_id: (required)
        :type market_id: int
        :param resolution: (required)
        :type resolution: str
        :param start_timestamp: (required)
        :type start_timestamp: int
        :param end_timestamp: (required)
        :type end_timestamp: int
        :param count_back: (required)
        :type count_back: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fundings_serialize(
            market_id=market_id,
            resolution=resolution,
            start_timestamp=start_timestamp,
            end_timestamp=end_timestamp,
            count_back=count_back,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Fundings",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fundings_serialize(
        self,
        market_id,
        resolution,
        start_timestamp,
        end_timestamp,
        count_back,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if resolution is not None:
            
            _query_params.append(('resolution', resolution))
            
        if start_timestamp is not None:
            
            _query_params.append(('start_timestamp', start_timestamp))
            
        if end_timestamp is not None:
            
            _query_params.append(('end_timestamp', end_timestamp))
            
        if count_back is not None:
            
            _query_params.append(('count_back', count_back))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fundings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\funding_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from lighter.models.funding_rates import FundingRates

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class FundingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def funding_rates(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FundingRates:
        """funding-rates

        Get funding rates

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._funding_rates_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FundingRates",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def funding_rates_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FundingRates]:
        """funding-rates

        Get funding rates

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._funding_rates_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FundingRates",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def funding_rates_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """funding-rates

        Get funding rates

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._funding_rates_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FundingRates",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _funding_rates_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/funding-rates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\info_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import StrictInt, StrictStr
from typing import Optional
from lighter.models.resp_withdrawal_delay import RespWithdrawalDelay
from lighter.models.transfer_fee_info import TransferFeeInfo

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class InfoApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def transfer_fee_info(
        self,
        account_index: StrictInt,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        to_account_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TransferFeeInfo:
        """transferFeeInfo

        Transfer fee info

        :param account_index: (required)
        :type account_index: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param to_account_index:
        :type to_account_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._transfer_fee_info_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            to_account_index=to_account_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TransferFeeInfo",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def transfer_fee_info_with_http_info(
        self,
        account_index: StrictInt,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        to_account_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TransferFeeInfo]:
        """transferFeeInfo

        Transfer fee info

        :param account_index: (required)
        :type account_index: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param to_account_index:
        :type to_account_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._transfer_fee_info_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            to_account_index=to_account_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TransferFeeInfo",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def transfer_fee_info_without_preload_content(
        self,
        account_index: StrictInt,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        to_account_index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """transferFeeInfo

        Transfer fee info

        :param account_index: (required)
        :type account_index: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param to_account_index:
        :type to_account_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._transfer_fee_info_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            to_account_index=to_account_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TransferFeeInfo",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _transfer_fee_info_serialize(
        self,
        account_index,
        authorization,
        auth,
        to_account_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if to_account_index is not None:
            
            _query_params.append(('to_account_index', to_account_index))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/transferFeeInfo',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def withdrawal_delay(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RespWithdrawalDelay:
        """withdrawalDelay

        Withdrawal delay in seconds

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._withdrawal_delay_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespWithdrawalDelay",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def withdrawal_delay_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RespWithdrawalDelay]:
        """withdrawalDelay

        Withdrawal delay in seconds

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._withdrawal_delay_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespWithdrawalDelay",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def withdrawal_delay_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """withdrawalDelay

        Withdrawal delay in seconds

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._withdrawal_delay_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespWithdrawalDelay",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _withdrawal_delay_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/withdrawalDelay',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\notification_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr
from typing import Optional
from typing_extensions import Annotated
from lighter.models.result_code import ResultCode

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class NotificationApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def notification_ack(
        self,
        notif_id: StrictStr,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ResultCode:
        """notification_ack

        Ack notification

        :param notif_id: (required)
        :type notif_id: str
        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._notification_ack_serialize(
            notif_id=notif_id,
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResultCode",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def notification_ack_with_http_info(
        self,
        notif_id: StrictStr,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ResultCode]:
        """notification_ack

        Ack notification

        :param notif_id: (required)
        :type notif_id: str
        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._notification_ack_serialize(
            notif_id=notif_id,
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResultCode",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def notification_ack_without_preload_content(
        self,
        notif_id: StrictStr,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """notification_ack

        Ack notification

        :param notif_id: (required)
        :type notif_id: str
        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._notification_ack_serialize(
            notif_id=notif_id,
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ResultCode",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _notification_ack_serialize(
        self,
        notif_id,
        account_index,
        authorization,
        auth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        if notif_id is not None:
            _form_params.append(('notif_id', notif_id))
        if auth is not None:
            _form_params.append(('auth', auth))
        if account_index is not None:
            _form_params.append(('account_index', account_index))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/notification/ack',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\order_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr, field_validator
from typing import Optional
from typing_extensions import Annotated
from lighter.models.exchange_stats import ExchangeStats
from lighter.models.export_data import ExportData
from lighter.models.order_book_details import OrderBookDetails
from lighter.models.order_book_orders import OrderBookOrders
from lighter.models.order_books import OrderBooks
from lighter.models.orders import Orders
from lighter.models.trades import Trades

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class OrderApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def account_active_orders(
        self,
        account_index: StrictInt,
        market_id: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Orders:
        """accountActiveOrders

        Get account active orders. `auth` can be generated using the SDK.

        :param account_index: (required)
        :type account_index: int
        :param market_id: (required)
        :type market_id: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_active_orders_serialize(
            account_index=account_index,
            market_id=market_id,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Orders",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def account_active_orders_with_http_info(
        self,
        account_index: StrictInt,
        market_id: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Orders]:
        """accountActiveOrders

        Get account active orders. `auth` can be generated using the SDK.

        :param account_index: (required)
        :type account_index: int
        :param market_id: (required)
        :type market_id: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_active_orders_serialize(
            account_index=account_index,
            market_id=market_id,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Orders",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def account_active_orders_without_preload_content(
        self,
        account_index: StrictInt,
        market_id: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accountActiveOrders

        Get account active orders. `auth` can be generated using the SDK.

        :param account_index: (required)
        :type account_index: int
        :param market_id: (required)
        :type market_id: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_active_orders_serialize(
            account_index=account_index,
            market_id=market_id,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Orders",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _account_active_orders_serialize(
        self,
        account_index,
        market_id,
        authorization,
        auth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/accountActiveOrders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def account_inactive_orders(
        self,
        account_index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        market_id: Optional[StrictInt] = None,
        ask_filter: Optional[StrictInt] = None,
        between_timestamps: Optional[StrictStr] = None,
        cursor: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Orders:
        """accountInactiveOrders

        Get account inactive orders

        :param account_index: (required)
        :type account_index: int
        :param limit: (required)
        :type limit: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param market_id:
        :type market_id: int
        :param ask_filter:
        :type ask_filter: int
        :param between_timestamps:
        :type between_timestamps: str
        :param cursor:
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_inactive_orders_serialize(
            account_index=account_index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            ask_filter=ask_filter,
            between_timestamps=between_timestamps,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Orders",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def account_inactive_orders_with_http_info(
        self,
        account_index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        market_id: Optional[StrictInt] = None,
        ask_filter: Optional[StrictInt] = None,
        between_timestamps: Optional[StrictStr] = None,
        cursor: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Orders]:
        """accountInactiveOrders

        Get account inactive orders

        :param account_index: (required)
        :type account_index: int
        :param limit: (required)
        :type limit: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param market_id:
        :type market_id: int
        :param ask_filter:
        :type ask_filter: int
        :param between_timestamps:
        :type between_timestamps: str
        :param cursor:
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_inactive_orders_serialize(
            account_index=account_index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            ask_filter=ask_filter,
            between_timestamps=between_timestamps,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Orders",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def account_inactive_orders_without_preload_content(
        self,
        account_index: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        market_id: Optional[StrictInt] = None,
        ask_filter: Optional[StrictInt] = None,
        between_timestamps: Optional[StrictStr] = None,
        cursor: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accountInactiveOrders

        Get account inactive orders

        :param account_index: (required)
        :type account_index: int
        :param limit: (required)
        :type limit: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param market_id:
        :type market_id: int
        :param ask_filter:
        :type ask_filter: int
        :param between_timestamps:
        :type between_timestamps: str
        :param cursor:
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_inactive_orders_serialize(
            account_index=account_index,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            ask_filter=ask_filter,
            between_timestamps=between_timestamps,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Orders",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _account_inactive_orders_serialize(
        self,
        account_index,
        limit,
        authorization,
        auth,
        market_id,
        ask_filter,
        between_timestamps,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if ask_filter is not None:
            
            _query_params.append(('ask_filter', ask_filter))
            
        if between_timestamps is not None:
            
            _query_params.append(('between_timestamps', between_timestamps))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/accountInactiveOrders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def exchange_stats(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExchangeStats:
        """exchangeStats

        Get exchange stats

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._exchange_stats_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExchangeStats",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def exchange_stats_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExchangeStats]:
        """exchangeStats

        Get exchange stats

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._exchange_stats_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExchangeStats",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def exchange_stats_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """exchangeStats

        Get exchange stats

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._exchange_stats_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExchangeStats",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _exchange_stats_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/exchangeStats',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def export(
        self,
        type: StrictStr,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        account_index: Optional[StrictInt] = None,
        market_id: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ExportData:
        """export

        Export data

        :param type: (required)
        :type type: str
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param account_index:
        :type account_index: int
        :param market_id:
        :type market_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_serialize(
            type=type,
            authorization=authorization,
            auth=auth,
            account_index=account_index,
            market_id=market_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExportData",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def export_with_http_info(
        self,
        type: StrictStr,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        account_index: Optional[StrictInt] = None,
        market_id: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ExportData]:
        """export

        Export data

        :param type: (required)
        :type type: str
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param account_index:
        :type account_index: int
        :param market_id:
        :type market_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_serialize(
            type=type,
            authorization=authorization,
            auth=auth,
            account_index=account_index,
            market_id=market_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExportData",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def export_without_preload_content(
        self,
        type: StrictStr,
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        account_index: Optional[StrictInt] = None,
        market_id: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """export

        Export data

        :param type: (required)
        :type type: str
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param account_index:
        :type account_index: int
        :param market_id:
        :type market_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_serialize(
            type=type,
            authorization=authorization,
            auth=auth,
            account_index=account_index,
            market_id=market_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ExportData",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _export_serialize(
        self,
        type,
        authorization,
        auth,
        account_index,
        market_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/export',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def order_book_details(
        self,
        market_id: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderBookDetails:
        """orderBookDetails

        Get order books metadata

        :param market_id:
        :type market_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._order_book_details_serialize(
            market_id=market_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBookDetails",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def order_book_details_with_http_info(
        self,
        market_id: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderBookDetails]:
        """orderBookDetails

        Get order books metadata

        :param market_id:
        :type market_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._order_book_details_serialize(
            market_id=market_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBookDetails",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def order_book_details_without_preload_content(
        self,
        market_id: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """orderBookDetails

        Get order books metadata

        :param market_id:
        :type market_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._order_book_details_serialize(
            market_id=market_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBookDetails",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _order_book_details_serialize(
        self,
        market_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/orderBookDetails',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def order_book_orders(
        self,
        market_id: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderBookOrders:
        """orderBookOrders

        Get order book orders

        :param market_id: (required)
        :type market_id: int
        :param limit: (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._order_book_orders_serialize(
            market_id=market_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBookOrders",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def order_book_orders_with_http_info(
        self,
        market_id: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderBookOrders]:
        """orderBookOrders

        Get order book orders

        :param market_id: (required)
        :type market_id: int
        :param limit: (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._order_book_orders_serialize(
            market_id=market_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBookOrders",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def order_book_orders_without_preload_content(
        self,
        market_id: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """orderBookOrders

        Get order book orders

        :param market_id: (required)
        :type market_id: int
        :param limit: (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._order_book_orders_serialize(
            market_id=market_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBookOrders",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _order_book_orders_serialize(
        self,
        market_id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/orderBookOrders',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def order_books(
        self,
        market_id: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderBooks:
        """orderBooks

        Get order books metadata.<hr>**Response Description:**<br><br>1) **Taker and maker fees** are in percentage.<br>2) **Min base amount:** The amount of base token that can be traded in a single order.<br>3) **Min quote amount:** The amount of quote token that can be traded in a single order.<br>4) **Supported size decimals:** The number of decimal places that can be used for the size of the order.<br>5) **Supported price decimals:** The number of decimal places that can be used for the price of the order.<br>6) **Supported quote decimals:** Size Decimals + Quote Decimals.

        :param market_id:
        :type market_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._order_books_serialize(
            market_id=market_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBooks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def order_books_with_http_info(
        self,
        market_id: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderBooks]:
        """orderBooks

        Get order books metadata.<hr>**Response Description:**<br><br>1) **Taker and maker fees** are in percentage.<br>2) **Min base amount:** The amount of base token that can be traded in a single order.<br>3) **Min quote amount:** The amount of quote token that can be traded in a single order.<br>4) **Supported size decimals:** The number of decimal places that can be used for the size of the order.<br>5) **Supported price decimals:** The number of decimal places that can be used for the price of the order.<br>6) **Supported quote decimals:** Size Decimals + Quote Decimals.

        :param market_id:
        :type market_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._order_books_serialize(
            market_id=market_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBooks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def order_books_without_preload_content(
        self,
        market_id: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """orderBooks

        Get order books metadata.<hr>**Response Description:**<br><br>1) **Taker and maker fees** are in percentage.<br>2) **Min base amount:** The amount of base token that can be traded in a single order.<br>3) **Min quote amount:** The amount of quote token that can be traded in a single order.<br>4) **Supported size decimals:** The number of decimal places that can be used for the size of the order.<br>5) **Supported price decimals:** The number of decimal places that can be used for the price of the order.<br>6) **Supported quote decimals:** Size Decimals + Quote Decimals.

        :param market_id:
        :type market_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._order_books_serialize(
            market_id=market_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderBooks",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _order_books_serialize(
        self,
        market_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/orderBooks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def recent_trades(
        self,
        market_id: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Trades:
        """recentTrades

        Get recent trades

        :param market_id: (required)
        :type market_id: int
        :param limit: (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recent_trades_serialize(
            market_id=market_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Trades",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def recent_trades_with_http_info(
        self,
        market_id: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Trades]:
        """recentTrades

        Get recent trades

        :param market_id: (required)
        :type market_id: int
        :param limit: (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recent_trades_serialize(
            market_id=market_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Trades",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def recent_trades_without_preload_content(
        self,
        market_id: StrictInt,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """recentTrades

        Get recent trades

        :param market_id: (required)
        :type market_id: int
        :param limit: (required)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._recent_trades_serialize(
            market_id=market_id,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Trades",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _recent_trades_serialize(
        self,
        market_id,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/recentTrades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def trades(
        self,
        sort_by: StrictStr,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        market_id: Optional[StrictInt] = None,
        account_index: Optional[StrictInt] = None,
        order_index: Optional[StrictInt] = None,
        sort_dir: Optional[StrictStr] = None,
        cursor: Optional[StrictStr] = None,
        var_from: Optional[StrictInt] = None,
        ask_filter: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Trades:
        """trades

        Get trades

        :param sort_by: (required)
        :type sort_by: str
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param market_id:
        :type market_id: int
        :param account_index:
        :type account_index: int
        :param order_index:
        :type order_index: int
        :param sort_dir:
        :type sort_dir: str
        :param cursor:
        :type cursor: str
        :param var_from:
        :type var_from: int
        :param ask_filter:
        :type ask_filter: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trades_serialize(
            sort_by=sort_by,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            account_index=account_index,
            order_index=order_index,
            sort_dir=sort_dir,
            cursor=cursor,
            var_from=var_from,
            ask_filter=ask_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Trades",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def trades_with_http_info(
        self,
        sort_by: StrictStr,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        market_id: Optional[StrictInt] = None,
        account_index: Optional[StrictInt] = None,
        order_index: Optional[StrictInt] = None,
        sort_dir: Optional[StrictStr] = None,
        cursor: Optional[StrictStr] = None,
        var_from: Optional[StrictInt] = None,
        ask_filter: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Trades]:
        """trades

        Get trades

        :param sort_by: (required)
        :type sort_by: str
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param market_id:
        :type market_id: int
        :param account_index:
        :type account_index: int
        :param order_index:
        :type order_index: int
        :param sort_dir:
        :type sort_dir: str
        :param cursor:
        :type cursor: str
        :param var_from:
        :type var_from: int
        :param ask_filter:
        :type ask_filter: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trades_serialize(
            sort_by=sort_by,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            account_index=account_index,
            order_index=order_index,
            sort_dir=sort_dir,
            cursor=cursor,
            var_from=var_from,
            ask_filter=ask_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Trades",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def trades_without_preload_content(
        self,
        sort_by: StrictStr,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        authorization: Optional[StrictStr] = None,
        auth: Optional[StrictStr] = None,
        market_id: Optional[StrictInt] = None,
        account_index: Optional[StrictInt] = None,
        order_index: Optional[StrictInt] = None,
        sort_dir: Optional[StrictStr] = None,
        cursor: Optional[StrictStr] = None,
        var_from: Optional[StrictInt] = None,
        ask_filter: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """trades

        Get trades

        :param sort_by: (required)
        :type sort_by: str
        :param limit: (required)
        :type limit: int
        :param authorization:
        :type authorization: str
        :param auth:
        :type auth: str
        :param market_id:
        :type market_id: int
        :param account_index:
        :type account_index: int
        :param order_index:
        :type order_index: int
        :param sort_dir:
        :type sort_dir: str
        :param cursor:
        :type cursor: str
        :param var_from:
        :type var_from: int
        :param ask_filter:
        :type ask_filter: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._trades_serialize(
            sort_by=sort_by,
            limit=limit,
            authorization=authorization,
            auth=auth,
            market_id=market_id,
            account_index=account_index,
            order_index=order_index,
            sort_dir=sort_dir,
            cursor=cursor,
            var_from=var_from,
            ask_filter=ask_filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Trades",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _trades_serialize(
        self,
        sort_by,
        limit,
        authorization,
        auth,
        market_id,
        account_index,
        order_index,
        sort_dir,
        cursor,
        var_from,
        ask_filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if market_id is not None:
            
            _query_params.append(('market_id', market_id))
            
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if order_index is not None:
            
            _query_params.append(('order_index', order_index))
            
        if sort_by is not None:
            
            _query_params.append(('sort_by', sort_by))
            
        if sort_dir is not None:
            
            _query_params.append(('sort_dir', sort_dir))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if var_from is not None:
            
            _query_params.append(('from', var_from))
            
        if ask_filter is not None:
            
            _query_params.append(('ask_filter', ask_filter))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/trades',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\referral_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr
from typing import Optional
from typing_extensions import Annotated
from lighter.models.referral_points import ReferralPoints

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class ReferralApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def referral_points(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ReferralPoints:
        """referral_points

        Get referral points

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._referral_points_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ReferralPoints",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def referral_points_with_http_info(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ReferralPoints]:
        """referral_points

        Get referral points

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._referral_points_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ReferralPoints",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def referral_points_without_preload_content(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """referral_points

        Get referral points

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._referral_points_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ReferralPoints",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _referral_points_serialize(
        self,
        account_index,
        authorization,
        auth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/referral/points',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\root_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from lighter.models.status import Status
from lighter.models.zk_lighter_info import ZkLighterInfo

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class RootApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ZkLighterInfo:
        """info

        Get info of zklighter

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._info_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ZkLighterInfo",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def info_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ZkLighterInfo]:
        """info

        Get info of zklighter

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._info_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ZkLighterInfo",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def info_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """info

        Get info of zklighter

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._info_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ZkLighterInfo",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _info_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/info',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def status(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Status:
        """status

        Get status of zklighter

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._status_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Status",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def status_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Status]:
        """status

        Get status of zklighter

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._status_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Status",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def status_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """status

        Get status of zklighter

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._status_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Status",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _status_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\transaction_api.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from lighter.models.deposit_history import DepositHistory
from lighter.models.enriched_tx import EnrichedTx
from lighter.models.next_nonce import NextNonce
from lighter.models.resp_send_tx import RespSendTx
from lighter.models.resp_send_tx_batch import RespSendTxBatch
from lighter.models.transfer_history import TransferHistory
from lighter.models.txs import Txs
from lighter.models.withdraw_history import WithdrawHistory

from lighter.api_client import ApiClient, RequestSerialized
from lighter.api_response import ApiResponse
from lighter.rest import RESTResponseType


class TransactionApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def account_txs(
        self,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        by: StrictStr,
        value: StrictStr,
        authorization: Optional[StrictStr] = None,
        index: Optional[StrictInt] = None,
        types: Optional[List[StrictInt]] = None,
        auth: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Txs:
        """accountTxs

        Get transactions of a specific account

        :param limit: (required)
        :type limit: int
        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param authorization:
        :type authorization: str
        :param index:
        :type index: int
        :param types:
        :type types: List[int]
        :param auth:
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_txs_serialize(
            limit=limit,
            by=by,
            value=value,
            authorization=authorization,
            index=index,
            types=types,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Txs",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def account_txs_with_http_info(
        self,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        by: StrictStr,
        value: StrictStr,
        authorization: Optional[StrictStr] = None,
        index: Optional[StrictInt] = None,
        types: Optional[List[StrictInt]] = None,
        auth: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Txs]:
        """accountTxs

        Get transactions of a specific account

        :param limit: (required)
        :type limit: int
        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param authorization:
        :type authorization: str
        :param index:
        :type index: int
        :param types:
        :type types: List[int]
        :param auth:
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_txs_serialize(
            limit=limit,
            by=by,
            value=value,
            authorization=authorization,
            index=index,
            types=types,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Txs",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def account_txs_without_preload_content(
        self,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        by: StrictStr,
        value: StrictStr,
        authorization: Optional[StrictStr] = None,
        index: Optional[StrictInt] = None,
        types: Optional[List[StrictInt]] = None,
        auth: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """accountTxs

        Get transactions of a specific account

        :param limit: (required)
        :type limit: int
        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param authorization:
        :type authorization: str
        :param index:
        :type index: int
        :param types:
        :type types: List[int]
        :param auth:
        :type auth: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_txs_serialize(
            limit=limit,
            by=by,
            value=value,
            authorization=authorization,
            index=index,
            types=types,
            auth=auth,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Txs",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _account_txs_serialize(
        self,
        limit,
        by,
        value,
        authorization,
        index,
        types,
        auth,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'types': 'csv',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            
            _query_params.append(('index', index))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if by is not None:
            
            _query_params.append(('by', by))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/accountTxs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def block_txs(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Txs:
        """blockTxs

        Get transactions in a block

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._block_txs_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Txs",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def block_txs_with_http_info(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Txs]:
        """blockTxs

        Get transactions in a block

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._block_txs_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Txs",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def block_txs_without_preload_content(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """blockTxs

        Get transactions in a block

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._block_txs_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Txs",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _block_txs_serialize(
        self,
        by,
        value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if by is not None:
            
            _query_params.append(('by', by))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/blockTxs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def deposit_history(
        self,
        account_index: StrictInt,
        l1_address: StrictStr,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        cursor: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DepositHistory:
        """deposit_history

        Get deposit history

        :param account_index: (required)
        :type account_index: int
        :param l1_address: (required)
        :type l1_address: str
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param cursor:
        :type cursor: str
        :param filter:
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._deposit_history_serialize(
            account_index=account_index,
            l1_address=l1_address,
            authorization=authorization,
            auth=auth,
            cursor=cursor,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DepositHistory",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def deposit_history_with_http_info(
        self,
        account_index: StrictInt,
        l1_address: StrictStr,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        cursor: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DepositHistory]:
        """deposit_history

        Get deposit history

        :param account_index: (required)
        :type account_index: int
        :param l1_address: (required)
        :type l1_address: str
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param cursor:
        :type cursor: str
        :param filter:
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._deposit_history_serialize(
            account_index=account_index,
            l1_address=l1_address,
            authorization=authorization,
            auth=auth,
            cursor=cursor,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DepositHistory",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def deposit_history_without_preload_content(
        self,
        account_index: StrictInt,
        l1_address: StrictStr,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        cursor: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """deposit_history

        Get deposit history

        :param account_index: (required)
        :type account_index: int
        :param l1_address: (required)
        :type l1_address: str
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param cursor:
        :type cursor: str
        :param filter:
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._deposit_history_serialize(
            account_index=account_index,
            l1_address=l1_address,
            authorization=authorization,
            auth=auth,
            cursor=cursor,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DepositHistory",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _deposit_history_serialize(
        self,
        account_index,
        l1_address,
        authorization,
        auth,
        cursor,
        filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if l1_address is not None:
            
            _query_params.append(('l1_address', l1_address))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/deposit/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def next_nonce(
        self,
        account_index: StrictInt,
        api_key_index: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NextNonce:
        """nextNonce

        Get next nonce for a specific account and api key

        :param account_index: (required)
        :type account_index: int
        :param api_key_index: (required)
        :type api_key_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._next_nonce_serialize(
            account_index=account_index,
            api_key_index=api_key_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NextNonce",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def next_nonce_with_http_info(
        self,
        account_index: StrictInt,
        api_key_index: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NextNonce]:
        """nextNonce

        Get next nonce for a specific account and api key

        :param account_index: (required)
        :type account_index: int
        :param api_key_index: (required)
        :type api_key_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._next_nonce_serialize(
            account_index=account_index,
            api_key_index=api_key_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NextNonce",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def next_nonce_without_preload_content(
        self,
        account_index: StrictInt,
        api_key_index: StrictInt,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """nextNonce

        Get next nonce for a specific account and api key

        :param account_index: (required)
        :type account_index: int
        :param api_key_index: (required)
        :type api_key_index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._next_nonce_serialize(
            account_index=account_index,
            api_key_index=api_key_index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NextNonce",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _next_nonce_serialize(
        self,
        account_index,
        api_key_index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if api_key_index is not None:
            
            _query_params.append(('api_key_index', api_key_index))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/nextNonce',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def send_tx(
        self,
        tx_type: StrictInt,
        tx_info: StrictStr,
        price_protection: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RespSendTx:
        """sendTx

        You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)

        :param tx_type: (required)
        :type tx_type: int
        :param tx_info: (required)
        :type tx_info: str
        :param price_protection:
        :type price_protection: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_tx_serialize(
            tx_type=tx_type,
            tx_info=tx_info,
            price_protection=price_protection,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespSendTx",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def send_tx_with_http_info(
        self,
        tx_type: StrictInt,
        tx_info: StrictStr,
        price_protection: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RespSendTx]:
        """sendTx

        You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)

        :param tx_type: (required)
        :type tx_type: int
        :param tx_info: (required)
        :type tx_info: str
        :param price_protection:
        :type price_protection: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_tx_serialize(
            tx_type=tx_type,
            tx_info=tx_info,
            price_protection=price_protection,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespSendTx",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def send_tx_without_preload_content(
        self,
        tx_type: StrictInt,
        tx_info: StrictStr,
        price_protection: Optional[StrictBool] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """sendTx

        You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)

        :param tx_type: (required)
        :type tx_type: int
        :param tx_info: (required)
        :type tx_info: str
        :param price_protection:
        :type price_protection: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_tx_serialize(
            tx_type=tx_type,
            tx_info=tx_info,
            price_protection=price_protection,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespSendTx",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _send_tx_serialize(
        self,
        tx_type,
        tx_info,
        price_protection,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if tx_type is not None:
            _form_params.append(('tx_type', tx_type))
        if tx_info is not None:
            _form_params.append(('tx_info', tx_info))
        if price_protection is not None:
            _form_params.append(('price_protection', price_protection))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/sendTx',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def send_tx_batch(
        self,
        tx_types: StrictStr,
        tx_infos: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RespSendTxBatch:
        """sendTxBatch

        You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)

        :param tx_types: (required)
        :type tx_types: str
        :param tx_infos: (required)
        :type tx_infos: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_tx_batch_serialize(
            tx_types=tx_types,
            tx_infos=tx_infos,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespSendTxBatch",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def send_tx_batch_with_http_info(
        self,
        tx_types: StrictStr,
        tx_infos: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RespSendTxBatch]:
        """sendTxBatch

        You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)

        :param tx_types: (required)
        :type tx_types: str
        :param tx_infos: (required)
        :type tx_infos: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_tx_batch_serialize(
            tx_types=tx_types,
            tx_infos=tx_infos,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespSendTxBatch",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def send_tx_batch_without_preload_content(
        self,
        tx_types: StrictStr,
        tx_infos: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """sendTxBatch

        You need to sign the transaction body before sending it to the server. More details can be found in the Get Started docs: [Get Started For Programmers](https://apidocs.lighter.xyz/docs/get-started-for-programmers)

        :param tx_types: (required)
        :type tx_types: str
        :param tx_infos: (required)
        :type tx_infos: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_tx_batch_serialize(
            tx_types=tx_types,
            tx_infos=tx_infos,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RespSendTxBatch",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _send_tx_batch_serialize(
        self,
        tx_types,
        tx_infos,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        if tx_types is not None:
            _form_params.append(('tx_types', tx_types))
        if tx_infos is not None:
            _form_params.append(('tx_infos', tx_infos))
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )

        # set the HTTP header `Content-Type`
        if _content_type:
            _header_params['Content-Type'] = _content_type
        else:
            _default_content_type = (
                self.api_client.select_header_content_type(
                    [
                        'multipart/form-data'
                    ]
                )
            )
            if _default_content_type is not None:
                _header_params['Content-Type'] = _default_content_type

        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/v1/sendTxBatch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def transfer_history(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        cursor: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TransferHistory:
        """transfer_history

        Get transfer history

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param cursor:
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._transfer_history_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TransferHistory",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def transfer_history_with_http_info(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        cursor: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TransferHistory]:
        """transfer_history

        Get transfer history

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param cursor:
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._transfer_history_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TransferHistory",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def transfer_history_without_preload_content(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        cursor: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """transfer_history

        Get transfer history

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param cursor:
        :type cursor: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._transfer_history_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            cursor=cursor,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TransferHistory",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _transfer_history_serialize(
        self,
        account_index,
        authorization,
        auth,
        cursor,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/transfer/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def tx(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EnrichedTx:
        """tx

        Get transaction by hash or sequence index

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tx_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EnrichedTx",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def tx_with_http_info(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EnrichedTx]:
        """tx

        Get transaction by hash or sequence index

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tx_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EnrichedTx",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def tx_without_preload_content(
        self,
        by: StrictStr,
        value: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """tx

        Get transaction by hash or sequence index

        :param by: (required)
        :type by: str
        :param value: (required)
        :type value: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tx_serialize(
            by=by,
            value=value,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EnrichedTx",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tx_serialize(
        self,
        by,
        value,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if by is not None:
            
            _query_params.append(('by', by))
            
        if value is not None:
            
            _query_params.append(('value', value))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/tx',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def tx_from_l1_tx_hash(
        self,
        hash: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> EnrichedTx:
        """txFromL1TxHash

        Get L1 transaction by L1 transaction hash

        :param hash: (required)
        :type hash: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tx_from_l1_tx_hash_serialize(
            hash=hash,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EnrichedTx",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def tx_from_l1_tx_hash_with_http_info(
        self,
        hash: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[EnrichedTx]:
        """txFromL1TxHash

        Get L1 transaction by L1 transaction hash

        :param hash: (required)
        :type hash: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tx_from_l1_tx_hash_serialize(
            hash=hash,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EnrichedTx",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def tx_from_l1_tx_hash_without_preload_content(
        self,
        hash: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """txFromL1TxHash

        Get L1 transaction by L1 transaction hash

        :param hash: (required)
        :type hash: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._tx_from_l1_tx_hash_serialize(
            hash=hash,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "EnrichedTx",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _tx_from_l1_tx_hash_serialize(
        self,
        hash,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if hash is not None:
            
            _query_params.append(('hash', hash))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/txFromL1TxHash',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def txs(
        self,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> Txs:
        """txs

        Get transactions which are already packed into blocks

        :param limit: (required)
        :type limit: int
        :param index:
        :type index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._txs_serialize(
            limit=limit,
            index=index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Txs",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def txs_with_http_info(
        self,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[Txs]:
        """txs

        Get transactions which are already packed into blocks

        :param limit: (required)
        :type limit: int
        :param index:
        :type index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._txs_serialize(
            limit=limit,
            index=index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Txs",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def txs_without_preload_content(
        self,
        limit: Annotated[int, Field(le=100, strict=True, ge=1)],
        index: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """txs

        Get transactions which are already packed into blocks

        :param limit: (required)
        :type limit: int
        :param index:
        :type index: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._txs_serialize(
            limit=limit,
            index=index,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "Txs",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _txs_serialize(
        self,
        limit,
        index,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if index is not None:
            
            _query_params.append(('index', index))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/txs',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def withdraw_history(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        cursor: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> WithdrawHistory:
        """withdraw_history

        Get withdraw history

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param cursor:
        :type cursor: str
        :param filter:
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._withdraw_history_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            cursor=cursor,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WithdrawHistory",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def withdraw_history_with_http_info(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        cursor: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[WithdrawHistory]:
        """withdraw_history

        Get withdraw history

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param cursor:
        :type cursor: str
        :param filter:
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._withdraw_history_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            cursor=cursor,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WithdrawHistory",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def withdraw_history_without_preload_content(
        self,
        account_index: StrictInt,
        authorization: Annotated[Optional[StrictStr], Field(description=" make required after integ is done")] = None,
        auth: Annotated[Optional[StrictStr], Field(description=" made optional to support header auth clients")] = None,
        cursor: Optional[StrictStr] = None,
        filter: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """withdraw_history

        Get withdraw history

        :param account_index: (required)
        :type account_index: int
        :param authorization:  make required after integ is done
        :type authorization: str
        :param auth:  made optional to support header auth clients
        :type auth: str
        :param cursor:
        :type cursor: str
        :param filter:
        :type filter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._withdraw_history_serialize(
            account_index=account_index,
            authorization=authorization,
            auth=auth,
            cursor=cursor,
            filter=filter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "WithdrawHistory",
            '400': "ResultCode",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _withdraw_history_serialize(
        self,
        account_index,
        authorization,
        auth,
        cursor,
        filter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, Union[str, bytes]] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_index is not None:
            
            _query_params.append(('account_index', account_index))
            
        if auth is not None:
            
            _query_params.append(('auth', auth))
            
        if cursor is not None:
            
            _query_params.append(('cursor', cursor))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        # process the header parameters
        if authorization is not None:
            _header_params['authorization'] = authorization
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/withdraw/history',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )





================================================================================
File: .\lighter\api\__init__.py
================================================================================

# flake8: noqa

# import apis into api package
from lighter.api.account_api import AccountApi
from lighter.api.announcement_api import AnnouncementApi
from lighter.api.block_api import BlockApi
from lighter.api.bridge_api import BridgeApi
from lighter.api.candlestick_api import CandlestickApi
from lighter.api.funding_api import FundingApi
from lighter.api.info_api import InfoApi
from lighter.api.notification_api import NotificationApi
from lighter.api.order_api import OrderApi
from lighter.api.referral_api import ReferralApi
from lighter.api.root_api import RootApi
from lighter.api.transaction_api import TransactionApi




================================================================================
File: .\lighter\models\account.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class Account(BaseModel):
    """
    Account
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    account_type: StrictInt
    index: StrictInt
    l1_address: StrictStr
    cancel_all_time: StrictInt
    total_order_count: StrictInt
    total_isolated_order_count: StrictInt
    pending_order_count: StrictInt
    available_balance: Optional[StrictStr]
    status: StrictInt
    collateral: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "account_type", "index", "l1_address", "cancel_all_time", "total_order_count", "total_isolated_order_count", "pending_order_count", "available_balance", "status", "collateral"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Account from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Account from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "account_type": obj.get("account_type"),
            "index": obj.get("index"),
            "l1_address": obj.get("l1_address"),
            "cancel_all_time": obj.get("cancel_all_time"),
            "total_order_count": obj.get("total_order_count"),
            "total_isolated_order_count": obj.get("total_isolated_order_count"),
            "pending_order_count": obj.get("pending_order_count"),
            "available_balance": obj.get("available_balance"),
            "status": obj.get("status"),
            "collateral": obj.get("collateral")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_api_keys.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.api_key import ApiKey
from typing import Optional, Set
from typing_extensions import Self

class AccountApiKeys(BaseModel):
    """
    AccountApiKeys
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    api_keys: List[ApiKey]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "api_keys"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountApiKeys from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in api_keys (list)
        _items = []
        if self.api_keys:
            for _item in self.api_keys:
                if _item:
                    _items.append(_item.to_dict())
            _dict['api_keys'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountApiKeys from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "api_keys": [ApiKey.from_dict(_item) for _item in obj["api_keys"]] if obj.get("api_keys") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_limits.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class AccountLimits(BaseModel):
    """
    AccountLimits
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    max_llp_percentage: StrictInt
    user_tier: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "max_llp_percentage", "user_tier"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountLimits from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountLimits from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "max_llp_percentage": obj.get("max_llp_percentage"),
            "user_tier": obj.get("user_tier")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_margin_stats.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class AccountMarginStats(BaseModel):
    """
    AccountMarginStats
    """ # noqa: E501
    collateral: StrictStr
    portfolio_value: StrictStr
    leverage: StrictStr
    available_balance: StrictStr
    margin_usage: StrictStr
    buying_power: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["collateral", "portfolio_value", "leverage", "available_balance", "margin_usage", "buying_power"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountMarginStats from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountMarginStats from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "collateral": obj.get("collateral"),
            "portfolio_value": obj.get("portfolio_value"),
            "leverage": obj.get("leverage"),
            "available_balance": obj.get("available_balance"),
            "margin_usage": obj.get("margin_usage"),
            "buying_power": obj.get("buying_power")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_market_stats.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class AccountMarketStats(BaseModel):
    """
    AccountMarketStats
    """ # noqa: E501
    market_id: StrictInt
    daily_trades_count: StrictInt
    daily_base_token_volume: Union[StrictFloat, StrictInt]
    daily_quote_token_volume: Union[StrictFloat, StrictInt]
    weekly_trades_count: StrictInt
    weekly_base_token_volume: Union[StrictFloat, StrictInt]
    weekly_quote_token_volume: Union[StrictFloat, StrictInt]
    monthly_trades_count: StrictInt
    monthly_base_token_volume: Union[StrictFloat, StrictInt]
    monthly_quote_token_volume: Union[StrictFloat, StrictInt]
    total_trades_count: StrictInt
    total_base_token_volume: Union[StrictFloat, StrictInt]
    total_quote_token_volume: Union[StrictFloat, StrictInt]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id", "daily_trades_count", "daily_base_token_volume", "daily_quote_token_volume", "weekly_trades_count", "weekly_base_token_volume", "weekly_quote_token_volume", "monthly_trades_count", "monthly_base_token_volume", "monthly_quote_token_volume", "total_trades_count", "total_base_token_volume", "total_quote_token_volume"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountMarketStats from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountMarketStats from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id"),
            "daily_trades_count": obj.get("daily_trades_count"),
            "daily_base_token_volume": obj.get("daily_base_token_volume"),
            "daily_quote_token_volume": obj.get("daily_quote_token_volume"),
            "weekly_trades_count": obj.get("weekly_trades_count"),
            "weekly_base_token_volume": obj.get("weekly_base_token_volume"),
            "weekly_quote_token_volume": obj.get("weekly_quote_token_volume"),
            "monthly_trades_count": obj.get("monthly_trades_count"),
            "monthly_base_token_volume": obj.get("monthly_base_token_volume"),
            "monthly_quote_token_volume": obj.get("monthly_quote_token_volume"),
            "total_trades_count": obj.get("total_trades_count"),
            "total_base_token_volume": obj.get("total_base_token_volume"),
            "total_quote_token_volume": obj.get("total_quote_token_volume")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_metadata.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class AccountMetadata(BaseModel):
    """
    AccountMetadata
    """ # noqa: E501
    account_index: StrictInt
    name: StrictStr
    description: StrictStr
    can_invite: StrictBool = Field(description=" Remove After FE uses L1 meta endpoint")
    referral_points_percentage: StrictStr = Field(description=" Remove After FE uses L1 meta endpoint")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "name", "description", "can_invite", "referral_points_percentage"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountMetadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountMetadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "name": obj.get("name"),
            "description": obj.get("description"),
            "can_invite": obj.get("can_invite"),
            "referral_points_percentage": obj.get("referral_points_percentage")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_metadatas.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.account_metadata import AccountMetadata
from typing import Optional, Set
from typing_extensions import Self

class AccountMetadatas(BaseModel):
    """
    AccountMetadatas
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    account_metadatas: List[AccountMetadata]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "account_metadatas"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountMetadatas from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in account_metadatas (list)
        _items = []
        if self.account_metadatas:
            for _item in self.account_metadatas:
                if _item:
                    _items.append(_item.to_dict())
            _dict['account_metadatas'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountMetadatas from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "account_metadatas": [AccountMetadata.from_dict(_item) for _item in obj["account_metadatas"]] if obj.get("account_metadatas") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_pn_l.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.pn_l_entry import PnLEntry
from typing import Optional, Set
from typing_extensions import Self

class AccountPnL(BaseModel):
    """
    AccountPnL
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    resolution: StrictStr
    pnl: List[PnLEntry]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "resolution", "pnl"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountPnL from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in pnl (list)
        _items = []
        if self.pnl:
            for _item in self.pnl:
                if _item:
                    _items.append(_item.to_dict())
            _dict['pnl'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountPnL from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "resolution": obj.get("resolution"),
            "pnl": [PnLEntry.from_dict(_item) for _item in obj["pnl"]] if obj.get("pnl") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_position.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class AccountPosition(BaseModel):
    """
    AccountPosition
    """ # noqa: E501
    market_id: StrictInt
    symbol: StrictStr
    initial_margin_fraction: StrictStr
    open_order_count: StrictInt
    pending_order_count: StrictInt
    position_tied_order_count: StrictInt
    sign: StrictInt
    position: StrictStr
    avg_entry_price: StrictStr
    position_value: StrictStr
    unrealized_pnl: StrictStr
    realized_pnl: StrictStr
    liquidation_price: StrictStr
    total_funding_paid_out: Optional[StrictStr] = None
    margin_mode: StrictInt
    allocated_margin: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id", "symbol", "initial_margin_fraction", "open_order_count", "pending_order_count", "position_tied_order_count", "sign", "position", "avg_entry_price", "position_value", "unrealized_pnl", "realized_pnl", "liquidation_price", "total_funding_paid_out", "margin_mode", "allocated_margin"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountPosition from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountPosition from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id"),
            "symbol": obj.get("symbol"),
            "initial_margin_fraction": obj.get("initial_margin_fraction"),
            "open_order_count": obj.get("open_order_count"),
            "pending_order_count": obj.get("pending_order_count"),
            "position_tied_order_count": obj.get("position_tied_order_count"),
            "sign": obj.get("sign"),
            "position": obj.get("position"),
            "avg_entry_price": obj.get("avg_entry_price"),
            "position_value": obj.get("position_value"),
            "unrealized_pnl": obj.get("unrealized_pnl"),
            "realized_pnl": obj.get("realized_pnl"),
            "liquidation_price": obj.get("liquidation_price"),
            "total_funding_paid_out": obj.get("total_funding_paid_out"),
            "margin_mode": obj.get("margin_mode"),
            "allocated_margin": obj.get("allocated_margin")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_stats.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from lighter.models.account_margin_stats import AccountMarginStats
from typing import Optional, Set
from typing_extensions import Self

class AccountStats(BaseModel):
    """
    AccountStats
    """ # noqa: E501
    collateral: StrictStr
    portfolio_value: StrictStr
    leverage: StrictStr
    available_balance: Optional[StrictStr]
    margin_usage: StrictStr
    buying_power: StrictStr
    cross_stats: AccountMarginStats
    total_stats: AccountMarginStats
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["collateral", "portfolio_value", "leverage", "available_balance", "margin_usage", "buying_power", "cross_stats", "total_stats"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountStats from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of cross_stats
        if self.cross_stats:
            _dict['cross_stats'] = self.cross_stats.to_dict()
        # override the default output from pydantic by calling `to_dict()` of total_stats
        if self.total_stats:
            _dict['total_stats'] = self.total_stats.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountStats from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "collateral": obj.get("collateral"),
            "portfolio_value": obj.get("portfolio_value"),
            "leverage": obj.get("leverage"),
            "available_balance": obj.get("available_balance"),
            "margin_usage": obj.get("margin_usage"),
            "buying_power": obj.get("buying_power"),
            "cross_stats": AccountMarginStats.from_dict(obj["cross_stats"]) if obj.get("cross_stats") is not None else None,
            "total_stats": AccountMarginStats.from_dict(obj["total_stats"]) if obj.get("total_stats") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\account_trade_stats.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class AccountTradeStats(BaseModel):
    """
    AccountTradeStats
    """ # noqa: E501
    daily_trades_count: StrictInt
    daily_volume: Union[StrictFloat, StrictInt]
    weekly_trades_count: StrictInt
    weekly_volume: Union[StrictFloat, StrictInt]
    monthly_trades_count: StrictInt
    monthly_volume: Union[StrictFloat, StrictInt]
    total_trades_count: StrictInt
    total_volume: Union[StrictFloat, StrictInt]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["daily_trades_count", "daily_volume", "weekly_trades_count", "weekly_volume", "monthly_trades_count", "monthly_volume", "total_trades_count", "total_volume"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountTradeStats from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountTradeStats from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "daily_trades_count": obj.get("daily_trades_count"),
            "daily_volume": obj.get("daily_volume"),
            "weekly_trades_count": obj.get("weekly_trades_count"),
            "weekly_volume": obj.get("weekly_volume"),
            "monthly_trades_count": obj.get("monthly_trades_count"),
            "monthly_volume": obj.get("monthly_volume"),
            "total_trades_count": obj.get("total_trades_count"),
            "total_volume": obj.get("total_volume")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\announcement.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class Announcement(BaseModel):
    """
    Announcement
    """ # noqa: E501
    title: StrictStr
    content: StrictStr
    created_at: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["title", "content", "created_at"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Announcement from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Announcement from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "title": obj.get("title"),
            "content": obj.get("content"),
            "created_at": obj.get("created_at")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\announcements.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.announcement import Announcement
from typing import Optional, Set
from typing_extensions import Self

class Announcements(BaseModel):
    """
    Announcements
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    announcements: List[Announcement]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "announcements"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Announcements from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in announcements (list)
        _items = []
        if self.announcements:
            for _item in self.announcements:
                if _item:
                    _items.append(_item.to_dict())
            _dict['announcements'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Announcements from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "announcements": [Announcement.from_dict(_item) for _item in obj["announcements"]] if obj.get("announcements") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\api_key.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ApiKey(BaseModel):
    """
    ApiKey
    """ # noqa: E501
    account_index: StrictInt
    api_key_index: StrictInt
    nonce: StrictInt
    public_key: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "api_key_index", "nonce", "public_key"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ApiKey from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ApiKey from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "api_key_index": obj.get("api_key_index"),
            "nonce": obj.get("nonce"),
            "public_key": obj.get("public_key")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\block.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from lighter.models.tx import Tx
from typing import Optional, Set
from typing_extensions import Self

class Block(BaseModel):
    """
    Block
    """ # noqa: E501
    commitment: StrictStr
    height: StrictInt
    state_root: StrictStr
    priority_operations: StrictInt
    on_chain_l2_operations: StrictInt
    pending_on_chain_operations_pub_data: StrictStr
    committed_tx_hash: StrictStr
    committed_at: StrictInt
    verified_tx_hash: StrictStr
    verified_at: StrictInt
    txs: List[Tx]
    status: StrictInt
    size: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["commitment", "height", "state_root", "priority_operations", "on_chain_l2_operations", "pending_on_chain_operations_pub_data", "committed_tx_hash", "committed_at", "verified_tx_hash", "verified_at", "txs", "status", "size"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Block from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in txs (list)
        _items = []
        if self.txs:
            for _item in self.txs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['txs'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Block from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "commitment": obj.get("commitment"),
            "height": obj.get("height"),
            "state_root": obj.get("state_root"),
            "priority_operations": obj.get("priority_operations"),
            "on_chain_l2_operations": obj.get("on_chain_l2_operations"),
            "pending_on_chain_operations_pub_data": obj.get("pending_on_chain_operations_pub_data"),
            "committed_tx_hash": obj.get("committed_tx_hash"),
            "committed_at": obj.get("committed_at"),
            "verified_tx_hash": obj.get("verified_tx_hash"),
            "verified_at": obj.get("verified_at"),
            "txs": [Tx.from_dict(_item) for _item in obj["txs"]] if obj.get("txs") is not None else None,
            "status": obj.get("status"),
            "size": obj.get("size")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\blocks.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.block import Block
from typing import Optional, Set
from typing_extensions import Self

class Blocks(BaseModel):
    """
    Blocks
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    total: StrictInt
    blocks: List[Block]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "total", "blocks"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Blocks from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in blocks (list)
        _items = []
        if self.blocks:
            for _item in self.blocks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['blocks'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Blocks from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "total": obj.get("total"),
            "blocks": [Block.from_dict(_item) for _item in obj["blocks"]] if obj.get("blocks") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\bridge_supported_network.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class BridgeSupportedNetwork(BaseModel):
    """
    BridgeSupportedNetwork
    """ # noqa: E501
    name: StrictStr
    chain_id: StrictStr
    explorer: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["name", "chain_id", "explorer"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of BridgeSupportedNetwork from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of BridgeSupportedNetwork from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "chain_id": obj.get("chain_id"),
            "explorer": obj.get("explorer")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\candlestick.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class Candlestick(BaseModel):
    """
    Candlestick
    """ # noqa: E501
    timestamp: StrictInt
    open: Union[StrictFloat, StrictInt]
    high: Union[StrictFloat, StrictInt]
    low: Union[StrictFloat, StrictInt]
    close: Union[StrictFloat, StrictInt]
    volume0: Union[StrictFloat, StrictInt]
    volume1: Union[StrictFloat, StrictInt]
    last_trade_id: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["timestamp", "open", "high", "low", "close", "volume0", "volume1", "last_trade_id"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Candlestick from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Candlestick from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "timestamp": obj.get("timestamp"),
            "open": obj.get("open"),
            "high": obj.get("high"),
            "low": obj.get("low"),
            "close": obj.get("close"),
            "volume0": obj.get("volume0"),
            "volume1": obj.get("volume1"),
            "last_trade_id": obj.get("last_trade_id")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\candlesticks.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.candlestick import Candlestick
from typing import Optional, Set
from typing_extensions import Self

class Candlesticks(BaseModel):
    """
    Candlesticks
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    resolution: StrictStr
    candlesticks: List[Candlestick]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "resolution", "candlesticks"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Candlesticks from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in candlesticks (list)
        _items = []
        if self.candlesticks:
            for _item in self.candlesticks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['candlesticks'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Candlesticks from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "resolution": obj.get("resolution"),
            "candlesticks": [Candlestick.from_dict(_item) for _item in obj["candlesticks"]] if obj.get("candlesticks") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\contract_address.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ContractAddress(BaseModel):
    """
    ContractAddress
    """ # noqa: E501
    name: StrictStr
    address: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["name", "address"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ContractAddress from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ContractAddress from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "address": obj.get("address")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\current_height.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class CurrentHeight(BaseModel):
    """
    CurrentHeight
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    height: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "height"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of CurrentHeight from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of CurrentHeight from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "height": obj.get("height")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\cursor.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class Cursor(BaseModel):
    """
    Cursor
    """ # noqa: E501
    next_cursor: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["next_cursor"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Cursor from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Cursor from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "next_cursor": obj.get("next_cursor")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\daily_return.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class DailyReturn(BaseModel):
    """
    DailyReturn
    """ # noqa: E501
    timestamp: StrictInt
    daily_return: Union[StrictFloat, StrictInt]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["timestamp", "daily_return"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DailyReturn from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DailyReturn from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "timestamp": obj.get("timestamp"),
            "daily_return": obj.get("daily_return")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\deposit_history.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.deposit_history_item import DepositHistoryItem
from typing import Optional, Set
from typing_extensions import Self

class DepositHistory(BaseModel):
    """
    DepositHistory
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    deposits: List[DepositHistoryItem]
    cursor: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "deposits", "cursor"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DepositHistory from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in deposits (list)
        _items = []
        if self.deposits:
            for _item in self.deposits:
                if _item:
                    _items.append(_item.to_dict())
            _dict['deposits'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DepositHistory from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "deposits": [DepositHistoryItem.from_dict(_item) for _item in obj["deposits"]] if obj.get("deposits") is not None else None,
            "cursor": obj.get("cursor")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\deposit_history_item.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class DepositHistoryItem(BaseModel):
    """
    DepositHistoryItem
    """ # noqa: E501
    id: StrictStr
    amount: StrictStr
    timestamp: StrictInt
    status: StrictStr
    l1_tx_hash: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["id", "amount", "timestamp", "status", "l1_tx_hash"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['failed', 'pending', 'completed', 'claimable']):
            raise ValueError("must be one of enum values ('failed', 'pending', 'completed', 'claimable')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DepositHistoryItem from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DepositHistoryItem from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "amount": obj.get("amount"),
            "timestamp": obj.get("timestamp"),
            "status": obj.get("status"),
            "l1_tx_hash": obj.get("l1_tx_hash")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\detailed_account.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.account_position import AccountPosition
from lighter.models.public_pool_info import PublicPoolInfo
from lighter.models.public_pool_share import PublicPoolShare
from typing import Optional, Set
from typing_extensions import Self

class DetailedAccount(BaseModel):
    """
    DetailedAccount
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    account_type: StrictInt
    index: StrictInt
    l1_address: StrictStr
    cancel_all_time: StrictInt
    total_order_count: StrictInt
    total_isolated_order_count: StrictInt
    pending_order_count: StrictInt
    available_balance: Optional[StrictStr]
    status: StrictInt
    collateral: StrictStr
    account_index: StrictInt
    name: StrictStr
    description: StrictStr
    can_invite: StrictBool = Field(description=" Remove After FE uses L1 meta endpoint")
    referral_points_percentage: StrictStr = Field(description=" Remove After FE uses L1 meta endpoint")
    positions: List[AccountPosition]
    total_asset_value: StrictStr
    cross_asset_value: StrictStr
    pool_info: Optional[PublicPoolInfo]
    shares: List[PublicPoolShare]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "account_type", "index", "l1_address", "cancel_all_time", "total_order_count", "total_isolated_order_count", "pending_order_count", "available_balance", "status", "collateral", "account_index", "name", "description", "can_invite", "referral_points_percentage", "positions", "total_asset_value", "cross_asset_value", "pool_info", "shares"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DetailedAccount from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in positions (list)
        _items = []
        if self.positions:
            for _item in self.positions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['positions'] = _items
        # override the default output from pydantic by calling `to_dict()` of pool_info
        if self.pool_info:
            _dict['pool_info'] = self.pool_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in shares (list)
        _items = []
        if self.shares:
            for _item in self.shares:
                if _item:
                    _items.append(_item.to_dict())
            _dict['shares'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DetailedAccount from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "account_type": obj.get("account_type"),
            "index": obj.get("index"),
            "l1_address": obj.get("l1_address"),
            "cancel_all_time": obj.get("cancel_all_time"),
            "total_order_count": obj.get("total_order_count"),
            "total_isolated_order_count": obj.get("total_isolated_order_count"),
            "pending_order_count": obj.get("pending_order_count"),
            "available_balance": obj.get("available_balance"),
            "status": obj.get("status"),
            "collateral": obj.get("collateral"),
            "account_index": obj.get("account_index"),
            "name": obj.get("name"),
            "description": obj.get("description"),
            "can_invite": obj.get("can_invite"),
            "referral_points_percentage": obj.get("referral_points_percentage"),
            "positions": [AccountPosition.from_dict(_item) for _item in obj["positions"]] if obj.get("positions") is not None else None,
            "total_asset_value": obj.get("total_asset_value"),
            "cross_asset_value": obj.get("cross_asset_value"),
            "pool_info": PublicPoolInfo.from_dict(obj["pool_info"]) if obj.get("pool_info") is not None else None,
            "shares": [PublicPoolShare.from_dict(_item) for _item in obj["shares"]] if obj.get("shares") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\detailed_accounts.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.detailed_account import DetailedAccount
from typing import Optional, Set
from typing_extensions import Self

class DetailedAccounts(BaseModel):
    """
    DetailedAccounts
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    total: StrictInt
    accounts: List[DetailedAccount]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "total", "accounts"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DetailedAccounts from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in accounts (list)
        _items = []
        if self.accounts:
            for _item in self.accounts:
                if _item:
                    _items.append(_item.to_dict())
            _dict['accounts'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DetailedAccounts from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "total": obj.get("total"),
            "accounts": [DetailedAccount.from_dict(_item) for _item in obj["accounts"]] if obj.get("accounts") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\detailed_candlestick.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class DetailedCandlestick(BaseModel):
    """
    DetailedCandlestick
    """ # noqa: E501
    timestamp: StrictInt
    open: Union[StrictFloat, StrictInt]
    high: Union[StrictFloat, StrictInt]
    low: Union[StrictFloat, StrictInt]
    close: Union[StrictFloat, StrictInt]
    volume0: Union[StrictFloat, StrictInt]
    volume1: Union[StrictFloat, StrictInt]
    last_trade_id: StrictInt
    trade_count: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["timestamp", "open", "high", "low", "close", "volume0", "volume1", "last_trade_id", "trade_count"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of DetailedCandlestick from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of DetailedCandlestick from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "timestamp": obj.get("timestamp"),
            "open": obj.get("open"),
            "high": obj.get("high"),
            "low": obj.get("low"),
            "close": obj.get("close"),
            "volume0": obj.get("volume0"),
            "volume1": obj.get("volume1"),
            "last_trade_id": obj.get("last_trade_id"),
            "trade_count": obj.get("trade_count")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\enriched_tx.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class EnrichedTx(BaseModel):
    """
    EnrichedTx
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    hash: StrictStr
    type: Annotated[int, Field(le=64, strict=True, ge=1)]
    info: StrictStr
    event_info: StrictStr
    status: StrictInt
    transaction_index: StrictInt
    l1_address: StrictStr
    account_index: StrictInt
    nonce: StrictInt
    expire_at: StrictInt
    block_height: StrictInt
    queued_at: StrictInt
    executed_at: StrictInt
    sequence_index: StrictInt
    parent_hash: StrictStr
    committed_at: StrictInt
    verified_at: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "hash", "type", "info", "event_info", "status", "transaction_index", "l1_address", "account_index", "nonce", "expire_at", "block_height", "queued_at", "executed_at", "sequence_index", "parent_hash", "committed_at", "verified_at"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EnrichedTx from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EnrichedTx from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "hash": obj.get("hash"),
            "type": obj.get("type"),
            "info": obj.get("info"),
            "event_info": obj.get("event_info"),
            "status": obj.get("status"),
            "transaction_index": obj.get("transaction_index"),
            "l1_address": obj.get("l1_address"),
            "account_index": obj.get("account_index"),
            "nonce": obj.get("nonce"),
            "expire_at": obj.get("expire_at"),
            "block_height": obj.get("block_height"),
            "queued_at": obj.get("queued_at"),
            "executed_at": obj.get("executed_at"),
            "sequence_index": obj.get("sequence_index"),
            "parent_hash": obj.get("parent_hash"),
            "committed_at": obj.get("committed_at"),
            "verified_at": obj.get("verified_at")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\exchange_stats.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from lighter.models.order_book_stats import OrderBookStats
from typing import Optional, Set
from typing_extensions import Self

class ExchangeStats(BaseModel):
    """
    ExchangeStats
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    total: StrictInt
    order_book_stats: List[OrderBookStats]
    daily_usd_volume: Union[StrictFloat, StrictInt]
    daily_trades_count: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "total", "order_book_stats", "daily_usd_volume", "daily_trades_count"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ExchangeStats from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in order_book_stats (list)
        _items = []
        if self.order_book_stats:
            for _item in self.order_book_stats:
                if _item:
                    _items.append(_item.to_dict())
            _dict['order_book_stats'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ExchangeStats from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "total": obj.get("total"),
            "order_book_stats": [OrderBookStats.from_dict(_item) for _item in obj["order_book_stats"]] if obj.get("order_book_stats") is not None else None,
            "daily_usd_volume": obj.get("daily_usd_volume"),
            "daily_trades_count": obj.get("daily_trades_count")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\export_data.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ExportData(BaseModel):
    """
    ExportData
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    data_url: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "data_url"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ExportData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ExportData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "data_url": obj.get("data_url")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\funding.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class Funding(BaseModel):
    """
    Funding
    """ # noqa: E501
    timestamp: StrictInt
    value: StrictStr
    rate: StrictStr
    direction: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["timestamp", "value", "rate", "direction"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Funding from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Funding from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "timestamp": obj.get("timestamp"),
            "value": obj.get("value"),
            "rate": obj.get("rate"),
            "direction": obj.get("direction")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\fundings.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.funding import Funding
from typing import Optional, Set
from typing_extensions import Self

class Fundings(BaseModel):
    """
    Fundings
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    resolution: StrictStr
    fundings: List[Funding]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "resolution", "fundings"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Fundings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in fundings (list)
        _items = []
        if self.fundings:
            for _item in self.fundings:
                if _item:
                    _items.append(_item.to_dict())
            _dict['fundings'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Fundings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "resolution": obj.get("resolution"),
            "fundings": [Funding.from_dict(_item) for _item in obj["fundings"]] if obj.get("fundings") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\funding_rate.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class FundingRate(BaseModel):
    """
    FundingRate
    """ # noqa: E501
    market_id: StrictInt
    exchange: StrictStr
    symbol: StrictStr
    rate: Union[StrictFloat, StrictInt]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id", "exchange", "symbol", "rate"]

    @field_validator('exchange')
    def exchange_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['binance', 'bybit', 'hyperliquid', 'lighter']):
            raise ValueError("must be one of enum values ('binance', 'bybit', 'hyperliquid', 'lighter')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FundingRate from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FundingRate from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id"),
            "exchange": obj.get("exchange"),
            "symbol": obj.get("symbol"),
            "rate": obj.get("rate")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\funding_rates.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.funding_rate import FundingRate
from typing import Optional, Set
from typing_extensions import Self

class FundingRates(BaseModel):
    """
    FundingRates
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    funding_rates: List[FundingRate]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "funding_rates"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of FundingRates from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in funding_rates (list)
        _items = []
        if self.funding_rates:
            for _item in self.funding_rates:
                if _item:
                    _items.append(_item.to_dict())
            _dict['funding_rates'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of FundingRates from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "funding_rates": [FundingRate.from_dict(_item) for _item in obj["funding_rates"]] if obj.get("funding_rates") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\l1_metadata.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class L1Metadata(BaseModel):
    """
    L1Metadata
    """ # noqa: E501
    l1_address: StrictStr
    can_invite: StrictBool
    referral_points_percentage: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["l1_address", "can_invite", "referral_points_percentage"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of L1Metadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of L1Metadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "l1_address": obj.get("l1_address"),
            "can_invite": obj.get("can_invite"),
            "referral_points_percentage": obj.get("referral_points_percentage")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\l1_provider_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class L1ProviderInfo(BaseModel):
    """
    L1ProviderInfo
    """ # noqa: E501
    chain_id: StrictInt = Field(alias="chainId")
    network_id: StrictInt = Field(alias="networkId")
    latest_block_number: StrictInt = Field(alias="latestBlockNumber")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["chainId", "networkId", "latestBlockNumber"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of L1ProviderInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of L1ProviderInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "chainId": obj.get("chainId"),
            "networkId": obj.get("networkId"),
            "latestBlockNumber": obj.get("latestBlockNumber")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\liquidation.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from lighter.models.liq_trade import LiqTrade
from lighter.models.liquidation_info import LiquidationInfo
from typing import Optional, Set
from typing_extensions import Self

class Liquidation(BaseModel):
    """
    Liquidation
    """ # noqa: E501
    id: StrictInt
    market_id: StrictInt
    type: StrictStr
    trade: LiqTrade
    info: LiquidationInfo
    executed_at: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["id", "market_id", "type", "trade", "info", "executed_at"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['partial', 'deleverage']):
            raise ValueError("must be one of enum values ('partial', 'deleverage')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Liquidation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of trade
        if self.trade:
            _dict['trade'] = self.trade.to_dict()
        # override the default output from pydantic by calling `to_dict()` of info
        if self.info:
            _dict['info'] = self.info.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Liquidation from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "market_id": obj.get("market_id"),
            "type": obj.get("type"),
            "trade": LiqTrade.from_dict(obj["trade"]) if obj.get("trade") is not None else None,
            "info": LiquidationInfo.from_dict(obj["info"]) if obj.get("info") is not None else None,
            "executed_at": obj.get("executed_at")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\liquidation_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Union
from lighter.models.account_position import AccountPosition
from lighter.models.risk_info import RiskInfo
from typing import Optional, Set
from typing_extensions import Self

class LiquidationInfo(BaseModel):
    """
    LiquidationInfo
    """ # noqa: E501
    positions: List[AccountPosition]
    risk_info_before: RiskInfo
    risk_info_after: RiskInfo
    mark_prices: Dict[str, Union[StrictFloat, StrictInt]]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["positions", "risk_info_before", "risk_info_after", "mark_prices"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of LiquidationInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in positions (list)
        _items = []
        if self.positions:
            for _item in self.positions:
                if _item:
                    _items.append(_item.to_dict())
            _dict['positions'] = _items
        # override the default output from pydantic by calling `to_dict()` of risk_info_before
        if self.risk_info_before:
            _dict['risk_info_before'] = self.risk_info_before.to_dict()
        # override the default output from pydantic by calling `to_dict()` of risk_info_after
        if self.risk_info_after:
            _dict['risk_info_after'] = self.risk_info_after.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of LiquidationInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "positions": [AccountPosition.from_dict(_item) for _item in obj["positions"]] if obj.get("positions") is not None else None,
            "risk_info_before": RiskInfo.from_dict(obj["risk_info_before"]) if obj.get("risk_info_before") is not None else None,
            "risk_info_after": RiskInfo.from_dict(obj["risk_info_after"]) if obj.get("risk_info_after") is not None else None,
            "mark_prices": obj.get("mark_prices")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\liquidation_infos.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.liquidation import Liquidation
from typing import Optional, Set
from typing_extensions import Self

class LiquidationInfos(BaseModel):
    """
    LiquidationInfos
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    liquidations: List[Liquidation]
    next_cursor: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "liquidations", "next_cursor"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of LiquidationInfos from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in liquidations (list)
        _items = []
        if self.liquidations:
            for _item in self.liquidations:
                if _item:
                    _items.append(_item.to_dict())
            _dict['liquidations'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of LiquidationInfos from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "liquidations": [Liquidation.from_dict(_item) for _item in obj["liquidations"]] if obj.get("liquidations") is not None else None,
            "next_cursor": obj.get("next_cursor")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\liq_trade.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class LiqTrade(BaseModel):
    """
    LiqTrade
    """ # noqa: E501
    price: StrictStr
    size: StrictStr
    taker_fee: StrictStr
    maker_fee: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["price", "size", "taker_fee", "maker_fee"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of LiqTrade from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of LiqTrade from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "price": obj.get("price"),
            "size": obj.get("size"),
            "taker_fee": obj.get("taker_fee"),
            "maker_fee": obj.get("maker_fee")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\market_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class MarketInfo(BaseModel):
    """
    MarketInfo
    """ # noqa: E501
    market_id: StrictInt
    index_price: StrictStr
    mark_price: StrictStr
    open_interest: StrictStr
    last_trade_price: StrictStr
    current_funding_rate: StrictStr
    funding_rate: StrictStr
    funding_timestamp: StrictInt
    daily_base_token_volume: Union[StrictFloat, StrictInt]
    daily_quote_token_volume: Union[StrictFloat, StrictInt]
    daily_price_low: Union[StrictFloat, StrictInt]
    daily_price_high: Union[StrictFloat, StrictInt]
    daily_price_change: Union[StrictFloat, StrictInt]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id", "index_price", "mark_price", "open_interest", "last_trade_price", "current_funding_rate", "funding_rate", "funding_timestamp", "daily_base_token_volume", "daily_quote_token_volume", "daily_price_low", "daily_price_high", "daily_price_change"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of MarketInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of MarketInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id"),
            "index_price": obj.get("index_price"),
            "mark_price": obj.get("mark_price"),
            "open_interest": obj.get("open_interest"),
            "last_trade_price": obj.get("last_trade_price"),
            "current_funding_rate": obj.get("current_funding_rate"),
            "funding_rate": obj.get("funding_rate"),
            "funding_timestamp": obj.get("funding_timestamp"),
            "daily_base_token_volume": obj.get("daily_base_token_volume"),
            "daily_quote_token_volume": obj.get("daily_quote_token_volume"),
            "daily_price_low": obj.get("daily_price_low"),
            "daily_price_high": obj.get("daily_price_high"),
            "daily_price_change": obj.get("daily_price_change")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\next_nonce.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class NextNonce(BaseModel):
    """
    NextNonce
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    nonce: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "nonce"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of NextNonce from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of NextNonce from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "nonce": obj.get("nonce")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\order.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class Order(BaseModel):
    """
    Order
    """ # noqa: E501
    order_index: StrictInt
    client_order_index: StrictInt
    order_id: StrictStr
    client_order_id: StrictStr
    market_index: StrictInt
    owner_account_index: StrictInt
    initial_base_amount: StrictStr
    price: StrictStr
    nonce: StrictInt
    remaining_base_amount: StrictStr
    is_ask: StrictBool
    base_size: StrictInt
    base_price: StrictInt
    filled_base_amount: StrictStr
    filled_quote_amount: StrictStr
    side: StrictStr = Field(description=" TODO: remove this")
    type: StrictStr
    time_in_force: StrictStr
    reduce_only: StrictBool
    trigger_price: StrictStr
    order_expiry: StrictInt
    status: StrictStr
    trigger_status: StrictStr
    trigger_time: StrictInt
    parent_order_index: StrictInt
    parent_order_id: StrictStr
    to_trigger_order_id_0: StrictStr
    to_trigger_order_id_1: StrictStr
    to_cancel_order_id_0: StrictStr
    block_height: StrictInt
    timestamp: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["order_index", "client_order_index", "order_id", "client_order_id", "market_index", "owner_account_index", "initial_base_amount", "price", "nonce", "remaining_base_amount", "is_ask", "base_size", "base_price", "filled_base_amount", "filled_quote_amount", "side", "type", "time_in_force", "reduce_only", "trigger_price", "order_expiry", "status", "trigger_status", "trigger_time", "parent_order_index", "parent_order_id", "to_trigger_order_id_0", "to_trigger_order_id_1", "to_cancel_order_id_0", "block_height", "timestamp"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['limit', 'market', 'stop-loss', 'stop-loss-limit', 'take-profit', 'take-profit-limit', 'twap', 'twap-sub', 'liquidation']):
            raise ValueError("must be one of enum values ('limit', 'market', 'stop-loss', 'stop-loss-limit', 'take-profit', 'take-profit-limit', 'twap', 'twap-sub', 'liquidation')")
        return value

    @field_validator('time_in_force')
    def time_in_force_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['good-till-time', 'immediate-or-cancel', 'post-only', 'Unknown']):
            raise ValueError("must be one of enum values ('good-till-time', 'immediate-or-cancel', 'post-only', 'Unknown')")
        return value

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['in-progress', 'pending', 'open', 'filled', 'canceled', 'canceled-post-only', 'canceled-reduce-only', 'canceled-position-not-allowed', 'canceled-margin-not-allowed', 'canceled-too-much-slippage', 'canceled-not-enough-liquidity', 'canceled-self-trade', 'canceled-expired', 'canceled-oco', 'canceled-child', 'canceled-liquidation']):
            raise ValueError("must be one of enum values ('in-progress', 'pending', 'open', 'filled', 'canceled', 'canceled-post-only', 'canceled-reduce-only', 'canceled-position-not-allowed', 'canceled-margin-not-allowed', 'canceled-too-much-slippage', 'canceled-not-enough-liquidity', 'canceled-self-trade', 'canceled-expired', 'canceled-oco', 'canceled-child', 'canceled-liquidation')")
        return value

    @field_validator('trigger_status')
    def trigger_status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['na', 'ready', 'mark-price', 'twap', 'parent-order']):
            raise ValueError("must be one of enum values ('na', 'ready', 'mark-price', 'twap', 'parent-order')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Order from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Order from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "order_index": obj.get("order_index"),
            "client_order_index": obj.get("client_order_index"),
            "order_id": obj.get("order_id"),
            "client_order_id": obj.get("client_order_id"),
            "market_index": obj.get("market_index"),
            "owner_account_index": obj.get("owner_account_index"),
            "initial_base_amount": obj.get("initial_base_amount"),
            "price": obj.get("price"),
            "nonce": obj.get("nonce"),
            "remaining_base_amount": obj.get("remaining_base_amount"),
            "is_ask": obj.get("is_ask"),
            "base_size": obj.get("base_size"),
            "base_price": obj.get("base_price"),
            "filled_base_amount": obj.get("filled_base_amount"),
            "filled_quote_amount": obj.get("filled_quote_amount"),
            "side": obj.get("side") if obj.get("side") is not None else 'buy',
            "type": obj.get("type"),
            "time_in_force": obj.get("time_in_force") if obj.get("time_in_force") is not None else 'good-till-time',
            "reduce_only": obj.get("reduce_only"),
            "trigger_price": obj.get("trigger_price"),
            "order_expiry": obj.get("order_expiry"),
            "status": obj.get("status"),
            "trigger_status": obj.get("trigger_status"),
            "trigger_time": obj.get("trigger_time"),
            "parent_order_index": obj.get("parent_order_index"),
            "parent_order_id": obj.get("parent_order_id"),
            "to_trigger_order_id_0": obj.get("to_trigger_order_id_0"),
            "to_trigger_order_id_1": obj.get("to_trigger_order_id_1"),
            "to_cancel_order_id_0": obj.get("to_cancel_order_id_0"),
            "block_height": obj.get("block_height"),
            "timestamp": obj.get("timestamp")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\orders.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.order import Order
from typing import Optional, Set
from typing_extensions import Self

class Orders(BaseModel):
    """
    Orders
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    next_cursor: Optional[StrictStr] = None
    orders: List[Order]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "next_cursor", "orders"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Orders from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in orders (list)
        _items = []
        if self.orders:
            for _item in self.orders:
                if _item:
                    _items.append(_item.to_dict())
            _dict['orders'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Orders from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "next_cursor": obj.get("next_cursor"),
            "orders": [Order.from_dict(_item) for _item in obj["orders"]] if obj.get("orders") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\order_book.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class OrderBook(BaseModel):
    """
    OrderBook
    """ # noqa: E501
    symbol: StrictStr
    market_id: StrictInt
    status: StrictStr
    taker_fee: StrictStr
    maker_fee: StrictStr
    liquidation_fee: StrictStr
    min_base_amount: StrictStr
    min_quote_amount: StrictStr
    supported_size_decimals: StrictInt
    supported_price_decimals: StrictInt
    supported_quote_decimals: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["symbol", "market_id", "status", "taker_fee", "maker_fee", "liquidation_fee", "min_base_amount", "min_quote_amount", "supported_size_decimals", "supported_price_decimals", "supported_quote_decimals"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['inactive', 'frozen', 'active']):
            raise ValueError("must be one of enum values ('inactive', 'frozen', 'active')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderBook from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderBook from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "symbol": obj.get("symbol"),
            "market_id": obj.get("market_id"),
            "status": obj.get("status"),
            "taker_fee": obj.get("taker_fee"),
            "maker_fee": obj.get("maker_fee"),
            "liquidation_fee": obj.get("liquidation_fee"),
            "min_base_amount": obj.get("min_base_amount"),
            "min_quote_amount": obj.get("min_quote_amount"),
            "supported_size_decimals": obj.get("supported_size_decimals"),
            "supported_price_decimals": obj.get("supported_price_decimals"),
            "supported_quote_decimals": obj.get("supported_quote_decimals")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\order_books.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.order_book import OrderBook
from typing import Optional, Set
from typing_extensions import Self

class OrderBooks(BaseModel):
    """
    OrderBooks
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    order_books: List[OrderBook]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "order_books"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderBooks from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in order_books (list)
        _items = []
        if self.order_books:
            for _item in self.order_books:
                if _item:
                    _items.append(_item.to_dict())
            _dict['order_books'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderBooks from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "order_books": [OrderBook.from_dict(_item) for _item in obj["order_books"]] if obj.get("order_books") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\order_book_depth.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.price_level import PriceLevel
from typing import Optional, Set
from typing_extensions import Self

class OrderBookDepth(BaseModel):
    """
    OrderBookDepth
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    asks: List[PriceLevel]
    bids: List[PriceLevel]
    offset: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "asks", "bids", "offset"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderBookDepth from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in asks (list)
        _items = []
        if self.asks:
            for _item in self.asks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['asks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bids (list)
        _items = []
        if self.bids:
            for _item in self.bids:
                if _item:
                    _items.append(_item.to_dict())
            _dict['bids'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderBookDepth from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "asks": [PriceLevel.from_dict(_item) for _item in obj["asks"]] if obj.get("asks") is not None else None,
            "bids": [PriceLevel.from_dict(_item) for _item in obj["bids"]] if obj.get("bids") is not None else None,
            "offset": obj.get("offset")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\order_book_detail.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class OrderBookDetail(BaseModel):
    """
    OrderBookDetail
    """ # noqa: E501
    symbol: StrictStr
    market_id: StrictInt
    status: StrictStr
    taker_fee: StrictStr
    maker_fee: StrictStr
    liquidation_fee: StrictStr
    min_base_amount: StrictStr
    min_quote_amount: StrictStr
    supported_size_decimals: StrictInt
    supported_price_decimals: StrictInt
    supported_quote_decimals: StrictInt
    size_decimals: StrictInt
    price_decimals: StrictInt
    quote_multiplier: StrictInt
    default_initial_margin_fraction: StrictInt
    min_initial_margin_fraction: StrictInt
    maintenance_margin_fraction: StrictInt
    closeout_margin_fraction: StrictInt
    last_trade_price: Union[StrictFloat, StrictInt]
    daily_trades_count: StrictInt
    daily_base_token_volume: Union[StrictFloat, StrictInt]
    daily_quote_token_volume: Union[StrictFloat, StrictInt]
    daily_price_low: Union[StrictFloat, StrictInt]
    daily_price_high: Union[StrictFloat, StrictInt]
    daily_price_change: Union[StrictFloat, StrictInt]
    open_interest: Union[StrictFloat, StrictInt]
    daily_chart: Dict[str, Union[StrictFloat, StrictInt]]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["symbol", "market_id", "status", "taker_fee", "maker_fee", "liquidation_fee", "min_base_amount", "min_quote_amount", "supported_size_decimals", "supported_price_decimals", "supported_quote_decimals", "size_decimals", "price_decimals", "quote_multiplier", "default_initial_margin_fraction", "min_initial_margin_fraction", "maintenance_margin_fraction", "closeout_margin_fraction", "last_trade_price", "daily_trades_count", "daily_base_token_volume", "daily_quote_token_volume", "daily_price_low", "daily_price_high", "daily_price_change", "open_interest", "daily_chart"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['inactive', 'frozen', 'active']):
            raise ValueError("must be one of enum values ('inactive', 'frozen', 'active')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderBookDetail from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderBookDetail from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "symbol": obj.get("symbol"),
            "market_id": obj.get("market_id"),
            "status": obj.get("status"),
            "taker_fee": obj.get("taker_fee"),
            "maker_fee": obj.get("maker_fee"),
            "liquidation_fee": obj.get("liquidation_fee"),
            "min_base_amount": obj.get("min_base_amount"),
            "min_quote_amount": obj.get("min_quote_amount"),
            "supported_size_decimals": obj.get("supported_size_decimals"),
            "supported_price_decimals": obj.get("supported_price_decimals"),
            "supported_quote_decimals": obj.get("supported_quote_decimals"),
            "size_decimals": obj.get("size_decimals"),
            "price_decimals": obj.get("price_decimals"),
            "quote_multiplier": obj.get("quote_multiplier"),
            "default_initial_margin_fraction": obj.get("default_initial_margin_fraction"),
            "min_initial_margin_fraction": obj.get("min_initial_margin_fraction"),
            "maintenance_margin_fraction": obj.get("maintenance_margin_fraction"),
            "closeout_margin_fraction": obj.get("closeout_margin_fraction"),
            "last_trade_price": obj.get("last_trade_price"),
            "daily_trades_count": obj.get("daily_trades_count"),
            "daily_base_token_volume": obj.get("daily_base_token_volume"),
            "daily_quote_token_volume": obj.get("daily_quote_token_volume"),
            "daily_price_low": obj.get("daily_price_low"),
            "daily_price_high": obj.get("daily_price_high"),
            "daily_price_change": obj.get("daily_price_change"),
            "open_interest": obj.get("open_interest"),
            "daily_chart": obj.get("daily_chart")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\order_book_details.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.order_book_detail import OrderBookDetail
from typing import Optional, Set
from typing_extensions import Self

class OrderBookDetails(BaseModel):
    """
    OrderBookDetails
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    order_book_details: List[OrderBookDetail]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "order_book_details"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderBookDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in order_book_details (list)
        _items = []
        if self.order_book_details:
            for _item in self.order_book_details:
                if _item:
                    _items.append(_item.to_dict())
            _dict['order_book_details'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderBookDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "order_book_details": [OrderBookDetail.from_dict(_item) for _item in obj["order_book_details"]] if obj.get("order_book_details") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\order_book_orders.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.simple_order import SimpleOrder
from typing import Optional, Set
from typing_extensions import Self

class OrderBookOrders(BaseModel):
    """
    OrderBookOrders
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    total_asks: StrictInt
    asks: List[SimpleOrder]
    total_bids: StrictInt
    bids: List[SimpleOrder]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "total_asks", "asks", "total_bids", "bids"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderBookOrders from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in asks (list)
        _items = []
        if self.asks:
            for _item in self.asks:
                if _item:
                    _items.append(_item.to_dict())
            _dict['asks'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in bids (list)
        _items = []
        if self.bids:
            for _item in self.bids:
                if _item:
                    _items.append(_item.to_dict())
            _dict['bids'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderBookOrders from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "total_asks": obj.get("total_asks"),
            "asks": [SimpleOrder.from_dict(_item) for _item in obj["asks"]] if obj.get("asks") is not None else None,
            "total_bids": obj.get("total_bids"),
            "bids": [SimpleOrder.from_dict(_item) for _item in obj["bids"]] if obj.get("bids") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\order_book_stats.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class OrderBookStats(BaseModel):
    """
    OrderBookStats
    """ # noqa: E501
    symbol: StrictStr
    last_trade_price: Union[StrictFloat, StrictInt]
    daily_trades_count: StrictInt
    daily_base_token_volume: Union[StrictFloat, StrictInt]
    daily_quote_token_volume: Union[StrictFloat, StrictInt]
    daily_price_change: Union[StrictFloat, StrictInt]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["symbol", "last_trade_price", "daily_trades_count", "daily_base_token_volume", "daily_quote_token_volume", "daily_price_change"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of OrderBookStats from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of OrderBookStats from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "symbol": obj.get("symbol"),
            "last_trade_price": obj.get("last_trade_price"),
            "daily_trades_count": obj.get("daily_trades_count"),
            "daily_base_token_volume": obj.get("daily_base_token_volume"),
            "daily_quote_token_volume": obj.get("daily_quote_token_volume"),
            "daily_price_change": obj.get("daily_price_change")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\pn_l_entry.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class PnLEntry(BaseModel):
    """
    PnLEntry
    """ # noqa: E501
    timestamp: StrictInt
    trade_pnl: Union[StrictFloat, StrictInt]
    inflow: Union[StrictFloat, StrictInt]
    outflow: Union[StrictFloat, StrictInt]
    pool_pnl: Union[StrictFloat, StrictInt]
    pool_inflow: Union[StrictFloat, StrictInt]
    pool_outflow: Union[StrictFloat, StrictInt]
    pool_total_shares: Union[StrictFloat, StrictInt]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["timestamp", "trade_pnl", "inflow", "outflow", "pool_pnl", "pool_inflow", "pool_outflow", "pool_total_shares"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PnLEntry from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PnLEntry from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "timestamp": obj.get("timestamp"),
            "trade_pnl": obj.get("trade_pnl"),
            "inflow": obj.get("inflow"),
            "outflow": obj.get("outflow"),
            "pool_pnl": obj.get("pool_pnl"),
            "pool_inflow": obj.get("pool_inflow"),
            "pool_outflow": obj.get("pool_outflow"),
            "pool_total_shares": obj.get("pool_total_shares")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\position_funding.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class PositionFunding(BaseModel):
    """
    PositionFunding
    """ # noqa: E501
    timestamp: StrictInt
    market_id: StrictInt
    funding_id: StrictInt
    change: StrictStr
    rate: StrictStr
    position_size: StrictStr
    position_side: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["timestamp", "market_id", "funding_id", "change", "rate", "position_size", "position_side"]

    @field_validator('position_side')
    def position_side_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['long', 'short']):
            raise ValueError("must be one of enum values ('long', 'short')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PositionFunding from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PositionFunding from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "timestamp": obj.get("timestamp"),
            "market_id": obj.get("market_id"),
            "funding_id": obj.get("funding_id"),
            "change": obj.get("change"),
            "rate": obj.get("rate"),
            "position_size": obj.get("position_size"),
            "position_side": obj.get("position_side")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\position_fundings.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.position_funding import PositionFunding
from typing import Optional, Set
from typing_extensions import Self

class PositionFundings(BaseModel):
    """
    PositionFundings
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    position_fundings: List[PositionFunding]
    next_cursor: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "position_fundings", "next_cursor"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PositionFundings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in position_fundings (list)
        _items = []
        if self.position_fundings:
            for _item in self.position_fundings:
                if _item:
                    _items.append(_item.to_dict())
            _dict['position_fundings'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PositionFundings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "position_fundings": [PositionFunding.from_dict(_item) for _item in obj["position_fundings"]] if obj.get("position_fundings") is not None else None,
            "next_cursor": obj.get("next_cursor")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\price_level.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class PriceLevel(BaseModel):
    """
    PriceLevel
    """ # noqa: E501
    price: StrictStr
    size: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["price", "size"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PriceLevel from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PriceLevel from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "price": obj.get("price"),
            "size": obj.get("size")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\public_pool.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.public_pool_info import PublicPoolInfo
from lighter.models.public_pool_share import PublicPoolShare
from typing import Optional, Set
from typing_extensions import Self

class PublicPool(BaseModel):
    """
    PublicPool
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    account_type: StrictInt
    index: StrictInt
    l1_address: StrictStr
    cancel_all_time: StrictInt
    total_order_count: StrictInt
    total_isolated_order_count: StrictInt
    pending_order_count: StrictInt
    available_balance: StrictStr
    status: StrictInt
    collateral: StrictStr
    account_index: StrictInt
    name: StrictStr
    description: StrictStr
    can_invite: StrictBool = Field(description=" Remove After FE uses L1 meta endpoint")
    referral_points_percentage: StrictStr = Field(description=" Remove After FE uses L1 meta endpoint")
    total_asset_value: StrictStr
    cross_asset_value: StrictStr
    pool_info: PublicPoolInfo
    account_share: Optional[PublicPoolShare] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "account_type", "index", "l1_address", "cancel_all_time", "total_order_count", "total_isolated_order_count", "pending_order_count", "available_balance", "status", "collateral", "account_index", "name", "description", "can_invite", "referral_points_percentage", "total_asset_value", "cross_asset_value", "pool_info", "account_share"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PublicPool from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of pool_info
        if self.pool_info:
            _dict['pool_info'] = self.pool_info.to_dict()
        # override the default output from pydantic by calling `to_dict()` of account_share
        if self.account_share:
            _dict['account_share'] = self.account_share.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PublicPool from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "account_type": obj.get("account_type"),
            "index": obj.get("index"),
            "l1_address": obj.get("l1_address"),
            "cancel_all_time": obj.get("cancel_all_time"),
            "total_order_count": obj.get("total_order_count"),
            "total_isolated_order_count": obj.get("total_isolated_order_count"),
            "pending_order_count": obj.get("pending_order_count"),
            "available_balance": obj.get("available_balance"),
            "status": obj.get("status"),
            "collateral": obj.get("collateral"),
            "account_index": obj.get("account_index"),
            "name": obj.get("name"),
            "description": obj.get("description"),
            "can_invite": obj.get("can_invite"),
            "referral_points_percentage": obj.get("referral_points_percentage"),
            "total_asset_value": obj.get("total_asset_value"),
            "cross_asset_value": obj.get("cross_asset_value"),
            "pool_info": PublicPoolInfo.from_dict(obj["pool_info"]) if obj.get("pool_info") is not None else None,
            "account_share": PublicPoolShare.from_dict(obj["account_share"]) if obj.get("account_share") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\public_pools.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.public_pool import PublicPool
from typing import Optional, Set
from typing_extensions import Self

class PublicPools(BaseModel):
    """
    PublicPools
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    total: StrictInt
    public_pools: List[PublicPool]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "total", "public_pools"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PublicPools from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in public_pools (list)
        _items = []
        if self.public_pools:
            for _item in self.public_pools:
                if _item:
                    _items.append(_item.to_dict())
            _dict['public_pools'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PublicPools from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "total": obj.get("total"),
            "public_pools": [PublicPool.from_dict(_item) for _item in obj["public_pools"]] if obj.get("public_pools") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\public_pool_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Union
from lighter.models.daily_return import DailyReturn
from lighter.models.share_price import SharePrice
from typing import Optional, Set
from typing_extensions import Self

class PublicPoolInfo(BaseModel):
    """
    PublicPoolInfo
    """ # noqa: E501
    status: StrictInt
    operator_fee: StrictStr
    min_operator_share_rate: StrictStr
    total_shares: StrictInt
    operator_shares: StrictInt
    annual_percentage_yield: Union[StrictFloat, StrictInt]
    daily_returns: List[DailyReturn]
    share_prices: List[SharePrice]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["status", "operator_fee", "min_operator_share_rate", "total_shares", "operator_shares", "annual_percentage_yield", "daily_returns", "share_prices"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PublicPoolInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in daily_returns (list)
        _items = []
        if self.daily_returns:
            for _item in self.daily_returns:
                if _item:
                    _items.append(_item.to_dict())
            _dict['daily_returns'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in share_prices (list)
        _items = []
        if self.share_prices:
            for _item in self.share_prices:
                if _item:
                    _items.append(_item.to_dict())
            _dict['share_prices'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PublicPoolInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "status": obj.get("status"),
            "operator_fee": obj.get("operator_fee"),
            "min_operator_share_rate": obj.get("min_operator_share_rate"),
            "total_shares": obj.get("total_shares"),
            "operator_shares": obj.get("operator_shares"),
            "annual_percentage_yield": obj.get("annual_percentage_yield"),
            "daily_returns": [DailyReturn.from_dict(_item) for _item in obj["daily_returns"]] if obj.get("daily_returns") is not None else None,
            "share_prices": [SharePrice.from_dict(_item) for _item in obj["share_prices"]] if obj.get("share_prices") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\public_pool_metadata.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional, Union
from lighter.models.public_pool_share import PublicPoolShare
from typing import Optional, Set
from typing_extensions import Self

class PublicPoolMetadata(BaseModel):
    """
    PublicPoolMetadata
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    account_index: StrictInt
    account_type: StrictInt
    name: StrictStr
    l1_address: StrictStr
    annual_percentage_yield: Union[StrictFloat, StrictInt]
    status: StrictInt
    operator_fee: StrictStr
    total_asset_value: StrictStr
    total_shares: StrictInt
    account_share: Optional[PublicPoolShare] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "account_index", "account_type", "name", "l1_address", "annual_percentage_yield", "status", "operator_fee", "total_asset_value", "total_shares", "account_share"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PublicPoolMetadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of account_share
        if self.account_share:
            _dict['account_share'] = self.account_share.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PublicPoolMetadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "account_index": obj.get("account_index"),
            "account_type": obj.get("account_type"),
            "name": obj.get("name"),
            "l1_address": obj.get("l1_address"),
            "annual_percentage_yield": obj.get("annual_percentage_yield"),
            "status": obj.get("status"),
            "operator_fee": obj.get("operator_fee"),
            "total_asset_value": obj.get("total_asset_value"),
            "total_shares": obj.get("total_shares"),
            "account_share": PublicPoolShare.from_dict(obj["account_share"]) if obj.get("account_share") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\public_pool_share.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class PublicPoolShare(BaseModel):
    """
    PublicPoolShare
    """ # noqa: E501
    public_pool_index: StrictInt
    shares_amount: StrictInt
    entry_usdc: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["public_pool_index", "shares_amount", "entry_usdc"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of PublicPoolShare from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of PublicPoolShare from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "public_pool_index": obj.get("public_pool_index"),
            "shares_amount": obj.get("shares_amount"),
            "entry_usdc": obj.get("entry_usdc")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\referral_points.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from lighter.models.referral_point_entry import ReferralPointEntry
from typing import Optional, Set
from typing_extensions import Self

class ReferralPoints(BaseModel):
    """
    ReferralPoints
    """ # noqa: E501
    referrals: List[ReferralPointEntry]
    user_total_points: StrictInt
    user_last_week_points: StrictInt
    user_total_referral_reward_points: StrictInt
    user_last_week_referral_reward_points: StrictInt
    reward_point_multiplier: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["referrals", "user_total_points", "user_last_week_points", "user_total_referral_reward_points", "user_last_week_referral_reward_points", "reward_point_multiplier"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReferralPoints from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in referrals (list)
        _items = []
        if self.referrals:
            for _item in self.referrals:
                if _item:
                    _items.append(_item.to_dict())
            _dict['referrals'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReferralPoints from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "referrals": [ReferralPointEntry.from_dict(_item) for _item in obj["referrals"]] if obj.get("referrals") is not None else None,
            "user_total_points": obj.get("user_total_points"),
            "user_last_week_points": obj.get("user_last_week_points"),
            "user_total_referral_reward_points": obj.get("user_total_referral_reward_points"),
            "user_last_week_referral_reward_points": obj.get("user_last_week_referral_reward_points"),
            "reward_point_multiplier": obj.get("reward_point_multiplier")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\referral_point_entry.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReferralPointEntry(BaseModel):
    """
    ReferralPointEntry
    """ # noqa: E501
    l1_address: StrictStr
    total_points: StrictInt
    week_points: StrictInt
    total_reward_points: StrictInt
    week_reward_points: StrictInt
    reward_point_multiplier: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["l1_address", "total_points", "week_points", "total_reward_points", "week_reward_points", "reward_point_multiplier"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReferralPointEntry from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReferralPointEntry from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "l1_address": obj.get("l1_address"),
            "total_points": obj.get("total_points"),
            "week_points": obj.get("week_points"),
            "total_reward_points": obj.get("total_reward_points"),
            "week_reward_points": obj.get("week_reward_points"),
            "reward_point_multiplier": obj.get("reward_point_multiplier")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_export_data.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqExportData(BaseModel):
    """
    ReqExportData
    """ # noqa: E501
    auth: Optional[StrictStr] = None
    account_index: Optional[StrictInt] = -1
    market_id: Optional[StrictInt] = None
    type: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "account_index", "market_id", "type"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['funding', 'trade']):
            raise ValueError("must be one of enum values ('funding', 'trade')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqExportData from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqExportData from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "account_index": obj.get("account_index") if obj.get("account_index") is not None else -1,
            "market_id": obj.get("market_id"),
            "type": obj.get("type")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_account.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReqGetAccount(BaseModel):
    """
    ReqGetAccount
    """ # noqa: E501
    by: StrictStr
    value: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["by", "value"]

    @field_validator('by')
    def by_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['index', 'l1_address']):
            raise ValueError("must be one of enum values ('index', 'l1_address')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetAccount from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetAccount from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "by": obj.get("by"),
            "value": obj.get("value")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_account_active_orders.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetAccountActiveOrders(BaseModel):
    """
    ReqGetAccountActiveOrders
    """ # noqa: E501
    account_index: StrictInt
    market_id: StrictInt
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "market_id", "auth"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetAccountActiveOrders from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetAccountActiveOrders from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "market_id": obj.get("market_id"),
            "auth": obj.get("auth")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_account_api_keys.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetAccountApiKeys(BaseModel):
    """
    ReqGetAccountApiKeys
    """ # noqa: E501
    account_index: StrictInt
    api_key_index: Optional[StrictInt] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "api_key_index"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetAccountApiKeys from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetAccountApiKeys from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "api_key_index": obj.get("api_key_index")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_account_by_l1_address.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReqGetAccountByL1Address(BaseModel):
    """
    ReqGetAccountByL1Address
    """ # noqa: E501
    l1_address: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["l1_address"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetAccountByL1Address from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetAccountByL1Address from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "l1_address": obj.get("l1_address")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_account_inactive_orders.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetAccountInactiveOrders(BaseModel):
    """
    ReqGetAccountInactiveOrders
    """ # noqa: E501
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    account_index: StrictInt
    market_id: Optional[StrictInt] = None
    ask_filter: Optional[StrictInt] = None
    between_timestamps: Optional[StrictStr] = None
    cursor: Optional[StrictStr] = None
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "account_index", "market_id", "ask_filter", "between_timestamps", "cursor", "limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetAccountInactiveOrders from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetAccountInactiveOrders from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "account_index": obj.get("account_index"),
            "market_id": obj.get("market_id"),
            "ask_filter": obj.get("ask_filter"),
            "between_timestamps": obj.get("between_timestamps"),
            "cursor": obj.get("cursor"),
            "limit": obj.get("limit")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_account_limits.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetAccountLimits(BaseModel):
    """
    ReqGetAccountLimits
    """ # noqa: E501
    account_index: StrictInt
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "auth"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetAccountLimits from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetAccountLimits from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "auth": obj.get("auth")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_account_metadata.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetAccountMetadata(BaseModel):
    """
    ReqGetAccountMetadata
    """ # noqa: E501
    by: StrictStr
    value: StrictStr
    auth: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["by", "value", "auth"]

    @field_validator('by')
    def by_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['index', 'l1_address']):
            raise ValueError("must be one of enum values ('index', 'l1_address')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetAccountMetadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetAccountMetadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "by": obj.get("by"),
            "value": obj.get("value"),
            "auth": obj.get("auth")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_account_pn_l.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetAccountPnL(BaseModel):
    """
    ReqGetAccountPnL
    """ # noqa: E501
    auth: Optional[StrictStr] = None
    by: StrictStr
    value: StrictStr
    resolution: StrictStr
    start_timestamp: Annotated[int, Field(le=5000000000000, strict=True)]
    end_timestamp: Annotated[int, Field(le=5000000000000, strict=True)]
    count_back: StrictInt
    ignore_transfers: Optional[StrictBool] = False
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "by", "value", "resolution", "start_timestamp", "end_timestamp", "count_back", "ignore_transfers"]

    @field_validator('by')
    def by_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['index']):
            raise ValueError("must be one of enum values ('index')")
        return value

    @field_validator('resolution')
    def resolution_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['1m', '5m', '15m', '1h', '4h', '1d']):
            raise ValueError("must be one of enum values ('1m', '5m', '15m', '1h', '4h', '1d')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetAccountPnL from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetAccountPnL from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "by": obj.get("by"),
            "value": obj.get("value"),
            "resolution": obj.get("resolution"),
            "start_timestamp": obj.get("start_timestamp"),
            "end_timestamp": obj.get("end_timestamp"),
            "count_back": obj.get("count_back"),
            "ignore_transfers": obj.get("ignore_transfers") if obj.get("ignore_transfers") is not None else False
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_account_txs.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetAccountTxs(BaseModel):
    """
    ReqGetAccountTxs
    """ # noqa: E501
    index: Optional[StrictInt] = None
    limit: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = None
    by: Optional[StrictStr] = None
    value: Optional[StrictStr] = None
    types: Optional[List[StrictInt]] = None
    auth: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["index", "limit", "by", "value", "types", "auth"]

    @field_validator('by')
    def by_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['account_index']):
            raise ValueError("must be one of enum values ('account_index')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetAccountTxs from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetAccountTxs from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "index": obj.get("index"),
            "limit": obj.get("limit"),
            "by": obj.get("by"),
            "value": obj.get("value"),
            "types": obj.get("types"),
            "auth": obj.get("auth")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_block.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReqGetBlock(BaseModel):
    """
    ReqGetBlock
    """ # noqa: E501
    by: StrictStr
    value: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["by", "value"]

    @field_validator('by')
    def by_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['commitment', 'height']):
            raise ValueError("must be one of enum values ('commitment', 'height')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetBlock from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetBlock from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "by": obj.get("by"),
            "value": obj.get("value")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_block_txs.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReqGetBlockTxs(BaseModel):
    """
    ReqGetBlockTxs
    """ # noqa: E501
    by: StrictStr
    value: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["by", "value"]

    @field_validator('by')
    def by_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['block_height', 'block_commitment']):
            raise ValueError("must be one of enum values ('block_height', 'block_commitment')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetBlockTxs from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetBlockTxs from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "by": obj.get("by"),
            "value": obj.get("value")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_by_account.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReqGetByAccount(BaseModel):
    """
    ReqGetByAccount
    """ # noqa: E501
    by: StrictStr
    value: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["by", "value"]

    @field_validator('by')
    def by_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['account_index']):
            raise ValueError("must be one of enum values ('account_index')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetByAccount from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetByAccount from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "by": obj.get("by"),
            "value": obj.get("value")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_candlesticks.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetCandlesticks(BaseModel):
    """
    ReqGetCandlesticks
    """ # noqa: E501
    market_id: StrictInt
    resolution: StrictStr
    start_timestamp: Annotated[int, Field(le=5000000000000, strict=True)]
    end_timestamp: Annotated[int, Field(le=5000000000000, strict=True)]
    count_back: StrictInt
    set_timestamp_to_end: Optional[StrictBool] = False
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id", "resolution", "start_timestamp", "end_timestamp", "count_back", "set_timestamp_to_end"]

    @field_validator('resolution')
    def resolution_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['1m', '5m', '15m', '1h', '4h', '1d']):
            raise ValueError("must be one of enum values ('1m', '5m', '15m', '1h', '4h', '1d')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetCandlesticks from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetCandlesticks from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id"),
            "resolution": obj.get("resolution"),
            "start_timestamp": obj.get("start_timestamp"),
            "end_timestamp": obj.get("end_timestamp"),
            "count_back": obj.get("count_back"),
            "set_timestamp_to_end": obj.get("set_timestamp_to_end") if obj.get("set_timestamp_to_end") is not None else False
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_deposit_history.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetDepositHistory(BaseModel):
    """
    ReqGetDepositHistory
    """ # noqa: E501
    account_index: StrictInt
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    l1_address: StrictStr
    cursor: Optional[StrictStr] = None
    filter: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "auth", "l1_address", "cursor", "filter"]

    @field_validator('filter')
    def filter_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['all', 'pending', 'claimable']):
            raise ValueError("must be one of enum values ('all', 'pending', 'claimable')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetDepositHistory from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetDepositHistory from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "auth": obj.get("auth"),
            "l1_address": obj.get("l1_address"),
            "cursor": obj.get("cursor"),
            "filter": obj.get("filter")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_fast_withdraw_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetFastWithdrawInfo(BaseModel):
    """
    ReqGetFastWithdrawInfo
    """ # noqa: E501
    account_index: StrictInt
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "auth"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetFastWithdrawInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetFastWithdrawInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "auth": obj.get("auth")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_fundings.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetFundings(BaseModel):
    """
    ReqGetFundings
    """ # noqa: E501
    market_id: StrictInt
    resolution: StrictStr
    start_timestamp: Annotated[int, Field(le=5000000000000, strict=True)]
    end_timestamp: Annotated[int, Field(le=5000000000000, strict=True)]
    count_back: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id", "resolution", "start_timestamp", "end_timestamp", "count_back"]

    @field_validator('resolution')
    def resolution_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['1h', '1d']):
            raise ValueError("must be one of enum values ('1h', '1d')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetFundings from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetFundings from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id"),
            "resolution": obj.get("resolution"),
            "start_timestamp": obj.get("start_timestamp"),
            "end_timestamp": obj.get("end_timestamp"),
            "count_back": obj.get("count_back")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_l1_metadata.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetL1Metadata(BaseModel):
    """
    ReqGetL1Metadata
    """ # noqa: E501
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    l1_address: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "l1_address"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetL1Metadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetL1Metadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "l1_address": obj.get("l1_address")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_l1_tx.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReqGetL1Tx(BaseModel):
    """
    ReqGetL1Tx
    """ # noqa: E501
    hash: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["hash"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetL1Tx from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetL1Tx from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "hash": obj.get("hash")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_latest_deposit.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReqGetLatestDeposit(BaseModel):
    """
    ReqGetLatestDeposit
    """ # noqa: E501
    l1_address: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["l1_address"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetLatestDeposit from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetLatestDeposit from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "l1_address": obj.get("l1_address")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_liquidation_infos.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetLiquidationInfos(BaseModel):
    """
    ReqGetLiquidationInfos
    """ # noqa: E501
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    account_index: StrictInt
    market_id: Optional[StrictInt] = None
    cursor: Optional[StrictStr] = None
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "account_index", "market_id", "cursor", "limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetLiquidationInfos from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetLiquidationInfos from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "account_index": obj.get("account_index"),
            "market_id": obj.get("market_id"),
            "cursor": obj.get("cursor"),
            "limit": obj.get("limit")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_next_nonce.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReqGetNextNonce(BaseModel):
    """
    ReqGetNextNonce
    """ # noqa: E501
    account_index: StrictInt
    api_key_index: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "api_key_index"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetNextNonce from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetNextNonce from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "api_key_index": obj.get("api_key_index")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_order_books.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetOrderBooks(BaseModel):
    """
    ReqGetOrderBooks
    """ # noqa: E501
    market_id: Optional[StrictInt] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetOrderBooks from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetOrderBooks from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_order_book_details.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetOrderBookDetails(BaseModel):
    """
    ReqGetOrderBookDetails
    """ # noqa: E501
    market_id: Optional[StrictInt] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetOrderBookDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetOrderBookDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_order_book_orders.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt
from typing import Any, ClassVar, Dict, List
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetOrderBookOrders(BaseModel):
    """
    ReqGetOrderBookOrders
    """ # noqa: E501
    market_id: StrictInt
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id", "limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetOrderBookOrders from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetOrderBookOrders from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id"),
            "limit": obj.get("limit")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_position_funding.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetPositionFunding(BaseModel):
    """
    ReqGetPositionFunding
    """ # noqa: E501
    auth: Optional[StrictStr] = None
    account_index: StrictInt
    market_id: Optional[StrictInt] = None
    cursor: Optional[StrictStr] = None
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    side: Optional[StrictStr] = 'all'
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "account_index", "market_id", "cursor", "limit", "side"]

    @field_validator('side')
    def side_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['long', 'short', 'all']):
            raise ValueError("must be one of enum values ('long', 'short', 'all')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetPositionFunding from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetPositionFunding from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "account_index": obj.get("account_index"),
            "market_id": obj.get("market_id"),
            "cursor": obj.get("cursor"),
            "limit": obj.get("limit"),
            "side": obj.get("side") if obj.get("side") is not None else 'all'
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_public_pools.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetPublicPools(BaseModel):
    """
    ReqGetPublicPools
    """ # noqa: E501
    auth: Optional[StrictStr] = None
    filter: Optional[StrictStr] = None
    index: StrictInt
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    account_index: Optional[StrictInt] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "filter", "index", "limit", "account_index"]

    @field_validator('filter')
    def filter_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['all', 'user', 'protocol', 'account_index']):
            raise ValueError("must be one of enum values ('all', 'user', 'protocol', 'account_index')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetPublicPools from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetPublicPools from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "filter": obj.get("filter"),
            "index": obj.get("index"),
            "limit": obj.get("limit"),
            "account_index": obj.get("account_index")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_public_pools_metadata.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetPublicPoolsMetadata(BaseModel):
    """
    ReqGetPublicPoolsMetadata
    """ # noqa: E501
    auth: Optional[StrictStr] = None
    filter: Optional[StrictStr] = None
    index: StrictInt
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    account_index: Optional[StrictInt] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "filter", "index", "limit", "account_index"]

    @field_validator('filter')
    def filter_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['all', 'user', 'protocol', 'account_index']):
            raise ValueError("must be one of enum values ('all', 'user', 'protocol', 'account_index')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetPublicPoolsMetadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetPublicPoolsMetadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "filter": obj.get("filter"),
            "index": obj.get("index"),
            "limit": obj.get("limit"),
            "account_index": obj.get("account_index")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_range_with_cursor.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetRangeWithCursor(BaseModel):
    """
    ReqGetRangeWithCursor
    """ # noqa: E501
    cursor: Optional[StrictStr] = None
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["cursor", "limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetRangeWithCursor from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetRangeWithCursor from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cursor": obj.get("cursor"),
            "limit": obj.get("limit")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_range_with_index.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetRangeWithIndex(BaseModel):
    """
    ReqGetRangeWithIndex
    """ # noqa: E501
    index: Optional[StrictInt] = None
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["index", "limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetRangeWithIndex from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetRangeWithIndex from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "index": obj.get("index"),
            "limit": obj.get("limit")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_range_with_index_sortable.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetRangeWithIndexSortable(BaseModel):
    """
    ReqGetRangeWithIndexSortable
    """ # noqa: E501
    index: Optional[StrictInt] = None
    limit: Optional[Annotated[int, Field(le=100, strict=True, ge=1)]] = None
    sort: Optional[StrictStr] = 'asc'
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["index", "limit", "sort"]

    @field_validator('sort')
    def sort_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['asc', 'desc']):
            raise ValueError("must be one of enum values ('asc', 'desc')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetRangeWithIndexSortable from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetRangeWithIndexSortable from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "index": obj.get("index"),
            "limit": obj.get("limit"),
            "sort": obj.get("sort") if obj.get("sort") is not None else 'asc'
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_recent_trades.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt
from typing import Any, ClassVar, Dict, List
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetRecentTrades(BaseModel):
    """
    ReqGetRecentTrades
    """ # noqa: E501
    market_id: StrictInt
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id", "limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetRecentTrades from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetRecentTrades from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id"),
            "limit": obj.get("limit")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_referral_points.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetReferralPoints(BaseModel):
    """
    ReqGetReferralPoints
    """ # noqa: E501
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    account_index: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "account_index"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetReferralPoints from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetReferralPoints from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "account_index": obj.get("account_index")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_trades.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class ReqGetTrades(BaseModel):
    """
    ReqGetTrades
    """ # noqa: E501
    auth: Optional[StrictStr] = None
    market_id: Optional[StrictInt] = None
    account_index: Optional[StrictInt] = -1
    order_index: Optional[StrictInt] = None
    sort_by: StrictStr
    sort_dir: Optional[StrictStr] = 'desc'
    cursor: Optional[StrictStr] = None
    var_from: Optional[StrictInt] = Field(default=-1, alias="from")
    ask_filter: Optional[StrictInt] = None
    limit: Annotated[int, Field(le=100, strict=True, ge=1)]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "market_id", "account_index", "order_index", "sort_by", "sort_dir", "cursor", "from", "ask_filter", "limit"]

    @field_validator('sort_by')
    def sort_by_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['block_height', 'timestamp', 'trade_id']):
            raise ValueError("must be one of enum values ('block_height', 'timestamp', 'trade_id')")
        return value

    @field_validator('sort_dir')
    def sort_dir_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['desc']):
            raise ValueError("must be one of enum values ('desc')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetTrades from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetTrades from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "market_id": obj.get("market_id"),
            "account_index": obj.get("account_index") if obj.get("account_index") is not None else -1,
            "order_index": obj.get("order_index"),
            "sort_by": obj.get("sort_by"),
            "sort_dir": obj.get("sort_dir") if obj.get("sort_dir") is not None else 'desc',
            "cursor": obj.get("cursor"),
            "from": obj.get("from") if obj.get("from") is not None else -1,
            "ask_filter": obj.get("ask_filter"),
            "limit": obj.get("limit")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_transfer_fee_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetTransferFeeInfo(BaseModel):
    """
    ReqGetTransferFeeInfo
    """ # noqa: E501
    auth: Optional[StrictStr] = None
    account_index: StrictInt
    to_account_index: Optional[StrictInt] = -1
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["auth", "account_index", "to_account_index"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetTransferFeeInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetTransferFeeInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "auth": obj.get("auth"),
            "account_index": obj.get("account_index"),
            "to_account_index": obj.get("to_account_index") if obj.get("to_account_index") is not None else -1
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_transfer_history.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetTransferHistory(BaseModel):
    """
    ReqGetTransferHistory
    """ # noqa: E501
    account_index: StrictInt
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    cursor: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "auth", "cursor"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetTransferHistory from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetTransferHistory from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "auth": obj.get("auth"),
            "cursor": obj.get("cursor")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_tx.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ReqGetTx(BaseModel):
    """
    ReqGetTx
    """ # noqa: E501
    by: StrictStr
    value: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["by", "value"]

    @field_validator('by')
    def by_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['hash', 'sequence_index']):
            raise ValueError("must be one of enum values ('hash', 'sequence_index')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetTx from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetTx from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "by": obj.get("by"),
            "value": obj.get("value")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\req_get_withdraw_history.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ReqGetWithdrawHistory(BaseModel):
    """
    ReqGetWithdrawHistory
    """ # noqa: E501
    account_index: StrictInt
    auth: Optional[StrictStr] = Field(default=None, description=" made optional to support header auth clients")
    cursor: Optional[StrictStr] = None
    filter: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["account_index", "auth", "cursor", "filter"]

    @field_validator('filter')
    def filter_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['all', 'pending', 'claimable']):
            raise ValueError("must be one of enum values ('all', 'pending', 'claimable')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ReqGetWithdrawHistory from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ReqGetWithdrawHistory from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account_index": obj.get("account_index"),
            "auth": obj.get("auth"),
            "cursor": obj.get("cursor"),
            "filter": obj.get("filter")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\resp_change_account_tier.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class RespChangeAccountTier(BaseModel):
    """
    RespChangeAccountTier
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RespChangeAccountTier from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RespChangeAccountTier from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\resp_get_fast_bridge_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class RespGetFastBridgeInfo(BaseModel):
    """
    RespGetFastBridgeInfo
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    fast_bridge_limit: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "fast_bridge_limit"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RespGetFastBridgeInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RespGetFastBridgeInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "fast_bridge_limit": obj.get("fast_bridge_limit")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\resp_public_pools_metadata.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.public_pool_metadata import PublicPoolMetadata
from typing import Optional, Set
from typing_extensions import Self

class RespPublicPoolsMetadata(BaseModel):
    """
    RespPublicPoolsMetadata
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    public_pools: List[PublicPoolMetadata]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "public_pools"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RespPublicPoolsMetadata from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in public_pools (list)
        _items = []
        if self.public_pools:
            for _item in self.public_pools:
                if _item:
                    _items.append(_item.to_dict())
            _dict['public_pools'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RespPublicPoolsMetadata from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "public_pools": [PublicPoolMetadata.from_dict(_item) for _item in obj["public_pools"]] if obj.get("public_pools") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\resp_send_tx.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class RespSendTx(BaseModel):
    """
    RespSendTx
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    tx_hash: StrictStr
    predicted_execution_time_ms: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "tx_hash", "predicted_execution_time_ms"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RespSendTx from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RespSendTx from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "tx_hash": obj.get("tx_hash"),
            "predicted_execution_time_ms": obj.get("predicted_execution_time_ms")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\resp_send_tx_batch.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class RespSendTxBatch(BaseModel):
    """
    RespSendTxBatch
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    tx_hash: List[StrictStr]
    predicted_execution_time_ms: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "tx_hash", "predicted_execution_time_ms"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RespSendTxBatch from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RespSendTxBatch from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "tx_hash": obj.get("tx_hash"),
            "predicted_execution_time_ms": obj.get("predicted_execution_time_ms")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\resp_withdrawal_delay.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class RespWithdrawalDelay(BaseModel):
    """
    RespWithdrawalDelay
    """ # noqa: E501
    seconds: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["seconds"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RespWithdrawalDelay from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RespWithdrawalDelay from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "seconds": obj.get("seconds")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\result_code.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class ResultCode(BaseModel):
    """
    ResultCode
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ResultCode from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ResultCode from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\risk_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict
from typing import Any, ClassVar, Dict, List
from lighter.models.risk_parameters import RiskParameters
from typing import Optional, Set
from typing_extensions import Self

class RiskInfo(BaseModel):
    """
    RiskInfo
    """ # noqa: E501
    cross_risk_parameters: RiskParameters
    isolated_risk_parameters: List[RiskParameters]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["cross_risk_parameters", "isolated_risk_parameters"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RiskInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of cross_risk_parameters
        if self.cross_risk_parameters:
            _dict['cross_risk_parameters'] = self.cross_risk_parameters.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in isolated_risk_parameters (list)
        _items = []
        if self.isolated_risk_parameters:
            for _item in self.isolated_risk_parameters:
                if _item:
                    _items.append(_item.to_dict())
            _dict['isolated_risk_parameters'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RiskInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "cross_risk_parameters": RiskParameters.from_dict(obj["cross_risk_parameters"]) if obj.get("cross_risk_parameters") is not None else None,
            "isolated_risk_parameters": [RiskParameters.from_dict(_item) for _item in obj["isolated_risk_parameters"]] if obj.get("isolated_risk_parameters") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\risk_parameters.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class RiskParameters(BaseModel):
    """
    RiskParameters
    """ # noqa: E501
    market_id: StrictInt
    collateral: StrictStr
    total_account_value: StrictStr
    initial_margin_req: StrictStr
    maintenance_margin_req: StrictStr
    close_out_margin_req: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["market_id", "collateral", "total_account_value", "initial_margin_req", "maintenance_margin_req", "close_out_margin_req"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of RiskParameters from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of RiskParameters from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "market_id": obj.get("market_id"),
            "collateral": obj.get("collateral"),
            "total_account_value": obj.get("total_account_value"),
            "initial_margin_req": obj.get("initial_margin_req"),
            "maintenance_margin_req": obj.get("maintenance_margin_req"),
            "close_out_margin_req": obj.get("close_out_margin_req")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\share_price.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictFloat, StrictInt
from typing import Any, ClassVar, Dict, List, Union
from typing import Optional, Set
from typing_extensions import Self

class SharePrice(BaseModel):
    """
    SharePrice
    """ # noqa: E501
    timestamp: StrictInt
    share_price: Union[StrictFloat, StrictInt]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["timestamp", "share_price"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SharePrice from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SharePrice from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "timestamp": obj.get("timestamp"),
            "share_price": obj.get("share_price")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\simple_order.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class SimpleOrder(BaseModel):
    """
    SimpleOrder
    """ # noqa: E501
    order_index: StrictInt
    order_id: StrictStr
    owner_account_index: StrictInt
    initial_base_amount: StrictStr
    remaining_base_amount: StrictStr
    price: StrictStr
    order_expiry: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["order_index", "order_id", "owner_account_index", "initial_base_amount", "remaining_base_amount", "price", "order_expiry"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SimpleOrder from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SimpleOrder from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "order_index": obj.get("order_index"),
            "order_id": obj.get("order_id"),
            "owner_account_index": obj.get("owner_account_index"),
            "initial_base_amount": obj.get("initial_base_amount"),
            "remaining_base_amount": obj.get("remaining_base_amount"),
            "price": obj.get("price"),
            "order_expiry": obj.get("order_expiry")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\status.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class Status(BaseModel):
    """
    Status
    """ # noqa: E501
    status: StrictInt
    network_id: StrictInt
    timestamp: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["status", "network_id", "timestamp"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Status from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Status from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "status": obj.get("status"),
            "network_id": obj.get("network_id"),
            "timestamp": obj.get("timestamp")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\sub_accounts.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.account import Account
from typing import Optional, Set
from typing_extensions import Self

class SubAccounts(BaseModel):
    """
    SubAccounts
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    l1_address: StrictStr
    sub_accounts: List[Account]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "l1_address", "sub_accounts"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SubAccounts from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in sub_accounts (list)
        _items = []
        if self.sub_accounts:
            for _item in self.sub_accounts:
                if _item:
                    _items.append(_item.to_dict())
            _dict['sub_accounts'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SubAccounts from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "l1_address": obj.get("l1_address"),
            "sub_accounts": [Account.from_dict(_item) for _item in obj["sub_accounts"]] if obj.get("sub_accounts") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\ticker.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from lighter.models.price_level import PriceLevel
from typing import Optional, Set
from typing_extensions import Self

class Ticker(BaseModel):
    """
    Ticker
    """ # noqa: E501
    s: StrictStr
    a: PriceLevel
    b: PriceLevel
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["s", "a", "b"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Ticker from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of a
        if self.a:
            _dict['a'] = self.a.to_dict()
        # override the default output from pydantic by calling `to_dict()` of b
        if self.b:
            _dict['b'] = self.b.to_dict()
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Ticker from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "s": obj.get("s"),
            "a": PriceLevel.from_dict(obj["a"]) if obj.get("a") is not None else None,
            "b": PriceLevel.from_dict(obj["b"]) if obj.get("b") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\trade.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class Trade(BaseModel):
    """
    Trade
    """ # noqa: E501
    trade_id: StrictInt
    tx_hash: StrictStr
    type: StrictStr
    market_id: StrictInt
    size: StrictStr
    price: StrictStr
    usd_amount: StrictStr
    ask_id: StrictInt
    bid_id: StrictInt
    ask_account_id: StrictInt
    bid_account_id: StrictInt
    is_maker_ask: StrictBool
    block_height: StrictInt
    timestamp: StrictInt
    taker_fee: Optional[StrictInt]
    taker_position_size_before: StrictStr
    taker_entry_quote_before: StrictStr
    taker_initial_margin_fraction_before: Optional[StrictInt]
    taker_position_sign_changed: Optional[StrictBool]
    maker_fee: Optional[StrictInt]
    maker_position_size_before: StrictStr
    maker_entry_quote_before: StrictStr
    maker_initial_margin_fraction_before: Optional[StrictInt]
    maker_position_sign_changed: Optional[StrictBool]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["trade_id", "tx_hash", "type", "market_id", "size", "price", "usd_amount", "ask_id", "bid_id", "ask_account_id", "bid_account_id", "is_maker_ask", "block_height", "timestamp", "taker_fee", "taker_position_size_before", "taker_entry_quote_before", "taker_initial_margin_fraction_before", "taker_position_sign_changed", "maker_fee", "maker_position_size_before", "maker_entry_quote_before", "maker_initial_margin_fraction_before", "maker_position_sign_changed"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['trade', 'liquidation', 'deleverage']):
            raise ValueError("must be one of enum values ('trade', 'liquidation', 'deleverage')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Trade from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Trade from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "trade_id": obj.get("trade_id"),
            "tx_hash": obj.get("tx_hash"),
            "type": obj.get("type"),
            "market_id": obj.get("market_id"),
            "size": obj.get("size"),
            "price": obj.get("price"),
            "usd_amount": obj.get("usd_amount"),
            "ask_id": obj.get("ask_id"),
            "bid_id": obj.get("bid_id"),
            "ask_account_id": obj.get("ask_account_id"),
            "bid_account_id": obj.get("bid_account_id"),
            "is_maker_ask": obj.get("is_maker_ask"),
            "block_height": obj.get("block_height"),
            "timestamp": obj.get("timestamp"),
            "taker_fee": obj.get("taker_fee"),
            "taker_position_size_before": obj.get("taker_position_size_before"),
            "taker_entry_quote_before": obj.get("taker_entry_quote_before"),
            "taker_initial_margin_fraction_before": obj.get("taker_initial_margin_fraction_before"),
            "taker_position_sign_changed": obj.get("taker_position_sign_changed"),
            "maker_fee": obj.get("maker_fee"),
            "maker_position_size_before": obj.get("maker_position_size_before"),
            "maker_entry_quote_before": obj.get("maker_entry_quote_before"),
            "maker_initial_margin_fraction_before": obj.get("maker_initial_margin_fraction_before"),
            "maker_position_sign_changed": obj.get("maker_position_sign_changed")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\trades.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.trade import Trade
from typing import Optional, Set
from typing_extensions import Self

class Trades(BaseModel):
    """
    Trades
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    next_cursor: Optional[StrictStr] = None
    trades: List[Trade]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "next_cursor", "trades"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Trades from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in trades (list)
        _items = []
        if self.trades:
            for _item in self.trades:
                if _item:
                    _items.append(_item.to_dict())
            _dict['trades'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Trades from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "next_cursor": obj.get("next_cursor"),
            "trades": [Trade.from_dict(_item) for _item in obj["trades"]] if obj.get("trades") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\transfer_fee_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class TransferFeeInfo(BaseModel):
    """
    TransferFeeInfo
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    transfer_fee_usdc: StrictInt
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "transfer_fee_usdc"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TransferFeeInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TransferFeeInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "transfer_fee_usdc": obj.get("transfer_fee_usdc")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\transfer_history.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.transfer_history_item import TransferHistoryItem
from typing import Optional, Set
from typing_extensions import Self

class TransferHistory(BaseModel):
    """
    TransferHistory
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    transfers: List[TransferHistoryItem]
    cursor: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "transfers", "cursor"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TransferHistory from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in transfers (list)
        _items = []
        if self.transfers:
            for _item in self.transfers:
                if _item:
                    _items.append(_item.to_dict())
            _dict['transfers'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TransferHistory from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "transfers": [TransferHistoryItem.from_dict(_item) for _item in obj["transfers"]] if obj.get("transfers") is not None else None,
            "cursor": obj.get("cursor")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\transfer_history_item.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class TransferHistoryItem(BaseModel):
    """
    TransferHistoryItem
    """ # noqa: E501
    id: StrictStr
    amount: StrictStr
    timestamp: StrictInt
    type: StrictStr
    from_l1_address: StrictStr
    to_l1_address: StrictStr
    from_account_index: StrictInt
    to_account_index: StrictInt
    tx_hash: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["id", "amount", "timestamp", "type", "from_l1_address", "to_l1_address", "from_account_index", "to_account_index", "tx_hash"]

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['L2TransferInflow', 'L2TransferOutflow']):
            raise ValueError("must be one of enum values ('L2TransferInflow', 'L2TransferOutflow')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TransferHistoryItem from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TransferHistoryItem from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "amount": obj.get("amount"),
            "timestamp": obj.get("timestamp"),
            "type": obj.get("type"),
            "from_l1_address": obj.get("from_l1_address"),
            "to_l1_address": obj.get("to_l1_address"),
            "from_account_index": obj.get("from_account_index"),
            "to_account_index": obj.get("to_account_index"),
            "tx_hash": obj.get("tx_hash")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\tx.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class Tx(BaseModel):
    """
    Tx
    """ # noqa: E501
    hash: StrictStr
    type: Annotated[int, Field(le=64, strict=True, ge=1)]
    info: StrictStr
    event_info: StrictStr
    status: StrictInt
    transaction_index: StrictInt
    l1_address: StrictStr
    account_index: StrictInt
    nonce: StrictInt
    expire_at: StrictInt
    block_height: StrictInt
    queued_at: StrictInt
    executed_at: StrictInt
    sequence_index: StrictInt
    parent_hash: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["hash", "type", "info", "event_info", "status", "transaction_index", "l1_address", "account_index", "nonce", "expire_at", "block_height", "queued_at", "executed_at", "sequence_index", "parent_hash"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Tx from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Tx from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "hash": obj.get("hash"),
            "type": obj.get("type"),
            "info": obj.get("info"),
            "event_info": obj.get("event_info"),
            "status": obj.get("status"),
            "transaction_index": obj.get("transaction_index"),
            "l1_address": obj.get("l1_address"),
            "account_index": obj.get("account_index"),
            "nonce": obj.get("nonce"),
            "expire_at": obj.get("expire_at"),
            "block_height": obj.get("block_height"),
            "queued_at": obj.get("queued_at"),
            "executed_at": obj.get("executed_at"),
            "sequence_index": obj.get("sequence_index"),
            "parent_hash": obj.get("parent_hash")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\txs.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.tx import Tx
from typing import Optional, Set
from typing_extensions import Self

class Txs(BaseModel):
    """
    Txs
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    txs: List[Tx]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "txs"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Txs from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in txs (list)
        _items = []
        if self.txs:
            for _item in self.txs:
                if _item:
                    _items.append(_item.to_dict())
            _dict['txs'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Txs from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "txs": [Tx.from_dict(_item) for _item in obj["txs"]] if obj.get("txs") is not None else None
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\tx_hash.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class TxHash(BaseModel):
    """
    TxHash
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    tx_hash: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "tx_hash"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TxHash from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TxHash from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "tx_hash": obj.get("tx_hash")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\tx_hashes.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class TxHashes(BaseModel):
    """
    TxHashes
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    tx_hash: List[StrictStr]
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "tx_hash"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of TxHashes from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of TxHashes from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "tx_hash": obj.get("tx_hash")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\validator_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictBool, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ValidatorInfo(BaseModel):
    """
    ValidatorInfo
    """ # noqa: E501
    address: StrictStr
    is_active: StrictBool
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["address", "is_active"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ValidatorInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ValidatorInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "address": obj.get("address"),
            "is_active": obj.get("is_active")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\withdraw_history.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from lighter.models.withdraw_history_item import WithdrawHistoryItem
from typing import Optional, Set
from typing_extensions import Self

class WithdrawHistory(BaseModel):
    """
    WithdrawHistory
    """ # noqa: E501
    code: StrictInt
    message: Optional[StrictStr] = None
    withdraws: List[WithdrawHistoryItem]
    cursor: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["code", "message", "withdraws", "cursor"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of WithdrawHistory from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of each item in withdraws (list)
        _items = []
        if self.withdraws:
            for _item in self.withdraws:
                if _item:
                    _items.append(_item.to_dict())
            _dict['withdraws'] = _items
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of WithdrawHistory from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "code": obj.get("code"),
            "message": obj.get("message"),
            "withdraws": [WithdrawHistoryItem.from_dict(_item) for _item in obj["withdraws"]] if obj.get("withdraws") is not None else None,
            "cursor": obj.get("cursor")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\withdraw_history_item.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class WithdrawHistoryItem(BaseModel):
    """
    WithdrawHistoryItem
    """ # noqa: E501
    id: StrictStr
    amount: StrictStr
    timestamp: StrictInt
    status: StrictStr
    type: StrictStr
    l1_tx_hash: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["id", "amount", "timestamp", "status", "type", "l1_tx_hash"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['failed', 'pending', 'claimable', 'refunded', 'completed']):
            raise ValueError("must be one of enum values ('failed', 'pending', 'claimable', 'refunded', 'completed')")
        return value

    @field_validator('type')
    def type_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['secure', 'fast']):
            raise ValueError("must be one of enum values ('secure', 'fast')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of WithdrawHistoryItem from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of WithdrawHistoryItem from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "id": obj.get("id"),
            "amount": obj.get("amount"),
            "timestamp": obj.get("timestamp"),
            "status": obj.get("status"),
            "type": obj.get("type"),
            "l1_tx_hash": obj.get("l1_tx_hash")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\zk_lighter_info.py
================================================================================

# coding: utf-8

"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, StrictStr
from typing import Any, ClassVar, Dict, List
from typing import Optional, Set
from typing_extensions import Self

class ZkLighterInfo(BaseModel):
    """
    ZkLighterInfo
    """ # noqa: E501
    contract_address: StrictStr
    additional_properties: Dict[str, Any] = {}
    __properties: ClassVar[List[str]] = ["contract_address"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ZkLighterInfo from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        * Fields in `self.additional_properties` are added to the output dict.
        """
        excluded_fields: Set[str] = set([
            "additional_properties",
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # puts key-value pairs in additional_properties in the top level
        if self.additional_properties is not None:
            for _key, _value in self.additional_properties.items():
                _dict[_key] = _value

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ZkLighterInfo from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "contract_address": obj.get("contract_address")
        })
        # store additional fields in additional_properties
        for _key in obj.keys():
            if _key not in cls.__properties:
                _obj.additional_properties[_key] = obj.get(_key)

        return _obj





================================================================================
File: .\lighter\models\__init__.py
================================================================================

# coding: utf-8

# flake8: noqa
"""
    

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


# import models into model package
from lighter.models.account import Account
from lighter.models.account_api_keys import AccountApiKeys
from lighter.models.account_limits import AccountLimits
from lighter.models.account_margin_stats import AccountMarginStats
from lighter.models.account_market_stats import AccountMarketStats
from lighter.models.account_metadata import AccountMetadata
from lighter.models.account_metadatas import AccountMetadatas
from lighter.models.account_pn_l import AccountPnL
from lighter.models.account_position import AccountPosition
from lighter.models.account_stats import AccountStats
from lighter.models.account_trade_stats import AccountTradeStats
from lighter.models.announcement import Announcement
from lighter.models.announcements import Announcements
from lighter.models.api_key import ApiKey
from lighter.models.block import Block
from lighter.models.blocks import Blocks
from lighter.models.bridge_supported_network import BridgeSupportedNetwork
from lighter.models.candlestick import Candlestick
from lighter.models.candlesticks import Candlesticks
from lighter.models.contract_address import ContractAddress
from lighter.models.current_height import CurrentHeight
from lighter.models.cursor import Cursor
from lighter.models.daily_return import DailyReturn
from lighter.models.deposit_history import DepositHistory
from lighter.models.deposit_history_item import DepositHistoryItem
from lighter.models.detailed_account import DetailedAccount
from lighter.models.detailed_accounts import DetailedAccounts
from lighter.models.detailed_candlestick import DetailedCandlestick
from lighter.models.enriched_tx import EnrichedTx
from lighter.models.exchange_stats import ExchangeStats
from lighter.models.export_data import ExportData
from lighter.models.funding import Funding
from lighter.models.funding_rate import FundingRate
from lighter.models.funding_rates import FundingRates
from lighter.models.fundings import Fundings
from lighter.models.l1_metadata import L1Metadata
from lighter.models.l1_provider_info import L1ProviderInfo
from lighter.models.liq_trade import LiqTrade
from lighter.models.liquidation import Liquidation
from lighter.models.liquidation_info import LiquidationInfo
from lighter.models.liquidation_infos import LiquidationInfos
from lighter.models.market_info import MarketInfo
from lighter.models.next_nonce import NextNonce
from lighter.models.order import Order
from lighter.models.order_book import OrderBook
from lighter.models.order_book_depth import OrderBookDepth
from lighter.models.order_book_detail import OrderBookDetail
from lighter.models.order_book_details import OrderBookDetails
from lighter.models.order_book_orders import OrderBookOrders
from lighter.models.order_book_stats import OrderBookStats
from lighter.models.order_books import OrderBooks
from lighter.models.orders import Orders
from lighter.models.pn_l_entry import PnLEntry
from lighter.models.position_funding import PositionFunding
from lighter.models.position_fundings import PositionFundings
from lighter.models.price_level import PriceLevel
from lighter.models.public_pool import PublicPool
from lighter.models.public_pool_info import PublicPoolInfo
from lighter.models.public_pool_metadata import PublicPoolMetadata
from lighter.models.public_pool_share import PublicPoolShare
from lighter.models.public_pools import PublicPools
from lighter.models.referral_point_entry import ReferralPointEntry
from lighter.models.referral_points import ReferralPoints
from lighter.models.req_export_data import ReqExportData
from lighter.models.req_get_account import ReqGetAccount
from lighter.models.req_get_account_active_orders import ReqGetAccountActiveOrders
from lighter.models.req_get_account_api_keys import ReqGetAccountApiKeys
from lighter.models.req_get_account_by_l1_address import ReqGetAccountByL1Address
from lighter.models.req_get_account_inactive_orders import ReqGetAccountInactiveOrders
from lighter.models.req_get_account_limits import ReqGetAccountLimits
from lighter.models.req_get_account_metadata import ReqGetAccountMetadata
from lighter.models.req_get_account_pn_l import ReqGetAccountPnL
from lighter.models.req_get_account_txs import ReqGetAccountTxs
from lighter.models.req_get_block import ReqGetBlock
from lighter.models.req_get_block_txs import ReqGetBlockTxs
from lighter.models.req_get_by_account import ReqGetByAccount
from lighter.models.req_get_candlesticks import ReqGetCandlesticks
from lighter.models.req_get_deposit_history import ReqGetDepositHistory
from lighter.models.req_get_fast_withdraw_info import ReqGetFastWithdrawInfo
from lighter.models.req_get_fundings import ReqGetFundings
from lighter.models.req_get_l1_metadata import ReqGetL1Metadata
from lighter.models.req_get_l1_tx import ReqGetL1Tx
from lighter.models.req_get_latest_deposit import ReqGetLatestDeposit
from lighter.models.req_get_liquidation_infos import ReqGetLiquidationInfos
from lighter.models.req_get_next_nonce import ReqGetNextNonce
from lighter.models.req_get_order_book_details import ReqGetOrderBookDetails
from lighter.models.req_get_order_book_orders import ReqGetOrderBookOrders
from lighter.models.req_get_order_books import ReqGetOrderBooks
from lighter.models.req_get_position_funding import ReqGetPositionFunding
from lighter.models.req_get_public_pools import ReqGetPublicPools
from lighter.models.req_get_public_pools_metadata import ReqGetPublicPoolsMetadata
from lighter.models.req_get_range_with_cursor import ReqGetRangeWithCursor
from lighter.models.req_get_range_with_index import ReqGetRangeWithIndex
from lighter.models.req_get_range_with_index_sortable import ReqGetRangeWithIndexSortable
from lighter.models.req_get_recent_trades import ReqGetRecentTrades
from lighter.models.req_get_referral_points import ReqGetReferralPoints
from lighter.models.req_get_trades import ReqGetTrades
from lighter.models.req_get_transfer_fee_info import ReqGetTransferFeeInfo
from lighter.models.req_get_transfer_history import ReqGetTransferHistory
from lighter.models.req_get_tx import ReqGetTx
from lighter.models.req_get_withdraw_history import ReqGetWithdrawHistory
from lighter.models.resp_change_account_tier import RespChangeAccountTier
from lighter.models.resp_get_fast_bridge_info import RespGetFastBridgeInfo
from lighter.models.resp_public_pools_metadata import RespPublicPoolsMetadata
from lighter.models.resp_send_tx import RespSendTx
from lighter.models.resp_send_tx_batch import RespSendTxBatch
from lighter.models.resp_withdrawal_delay import RespWithdrawalDelay
from lighter.models.result_code import ResultCode
from lighter.models.risk_info import RiskInfo
from lighter.models.risk_parameters import RiskParameters
from lighter.models.share_price import SharePrice
from lighter.models.simple_order import SimpleOrder
from lighter.models.status import Status
from lighter.models.sub_accounts import SubAccounts
from lighter.models.ticker import Ticker
from lighter.models.trade import Trade
from lighter.models.trades import Trades
from lighter.models.transfer_fee_info import TransferFeeInfo
from lighter.models.transfer_history import TransferHistory
from lighter.models.transfer_history_item import TransferHistoryItem
from lighter.models.tx import Tx
from lighter.models.tx_hash import TxHash
from lighter.models.tx_hashes import TxHashes
from lighter.models.txs import Txs
from lighter.models.validator_info import ValidatorInfo
from lighter.models.withdraw_history import WithdrawHistory
from lighter.models.withdraw_history_item import WithdrawHistoryItem
from lighter.models.zk_lighter_info import ZkLighterInfo



================================================================================
File: .\lighter\signers\README.md
================================================================================

Check the [go-sdk](https://github.com/elliottech/lighter-go) to see the source code for the binaries or to generate them youself.


================================================================================
File: .\lighter\transactions\cancel_order.py
================================================================================

import json
from typing import Optional


class CancelOrder:
    def __init__(self):
        self.account_index: Optional[int] = None
        self.order_book_index: Optional[int] = None
        self.order_nonce: Optional[int] = None
        self.expired_at: Optional[int] = None
        self.nonce: Optional[int] = None
        self.sig: Optional[str] = None

    @classmethod
    def from_json(cls, json_str: str) -> 'CancelOrder':
        params = json.loads(json_str)
        self = cls()
        self.account_index = params.get('AccountIndex')
        self.order_book_index = params.get('OrderBookIndex')
        self.order_nonce = params.get('OrderNonce')
        self.expired_at = params.get('ExpiredAt')
        self.nonce = params.get('Nonce')
        self.sig = params.get('Sig')
        return self

    def to_json(self) -> str:
        return json.dumps(self.__dict__, default=str)



================================================================================
File: .\lighter\transactions\create_order.py
================================================================================

import json
from typing import Optional


class CreateOrder:
    def __init__(self):
        self.account_index: Optional[int] = None
        self.order_book_index: Optional[int] = None
        self.base_amount: Optional[int] = None
        self.price: Optional[int] = None
        self.is_ask: Optional[int] = None
        self.order_type: Optional[int] = None
        self.expired_at: Optional[int] = None
        self.nonce: Optional[int] = None
        self.sig: Optional[str] = None

    @classmethod
    def from_json(cls, json_str: str) -> 'CreateOrder':
        params = json.loads(json_str)
        self = cls()
        self.account_index = params.get('AccountIndex')
        self.order_book_index = params.get('OrderBookIndex')
        self.base_amount = params.get('BaseAmount')
        self.price = params.get('Price')
        self.is_ask = params.get('IsAsk')
        self.order_type = params.get('OrderType')
        self.expired_at = params.get('ExpiredAt')
        self.nonce = params.get('Nonce')
        self.sig = params.get('Sig')
        return self

    def to_json(self) -> str:
        return json.dumps(self.__dict__, default=str)



================================================================================
File: .\lighter\transactions\withdraw.py
================================================================================

import json
from typing import Optional


class Withdraw:
    def __init__(self):
        self.from_account_index: Optional[int] = None
        self.collateral_amount: Optional[int] = None
        self.expired_at: Optional[int] = None
        self.nonce: Optional[int] = None
        self.sig: Optional[str] = None

    @classmethod
    def from_json(cls, json_str: str) -> 'Withdraw':
        params = json.loads(json_str)
        instance = cls()
        instance.from_account_index = params.get('FromAccountIndex')
        instance.collateral_amount = params.get('CollateralAmount')
        instance.expired_at = params.get('ExpiredAt')
        instance.nonce = params.get('Nonce')
        instance.sig = params.get('Sig')
        return instance

    def to_json(self) -> str:
        return json.dumps(self.__dict__, default=str)



================================================================================
File: .\lighter\transactions\__init__.py
================================================================================

from lighter.transactions.cancel_order import CancelOrder
from lighter.transactions.create_order import CreateOrder
from lighter.transactions.withdraw import Withdraw



